--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -795,7 +795,8 @@
 	zynq-zc770-xm012.dtb \
 	zynq-zc770-xm013.dtb \
 	zynq-zed.dtb \
-	zynq-zybo.dtb
+	zynq-zybo.dtb \
+	zynq-zturn.dtb
 dtb-$(CONFIG_MACH_ARMADA_370) += \
 	armada-370-db.dtb \
 	armada-370-dlink-dns327l.dtb \
--- /dev/null
+++ b/arch/arm/boot/dts/zynq-zturn.dts
@@ -0,0 +1,268 @@
+/*
+ *  Copyright (C) 2011 - 2014 Xilinx
+ *  Copyright (C) 2012 National Instruments Corp.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/dts-v1/;
+/include/ "zynq-7000.dtsi"
+
+
+/ {
+	model = "MYIR Z-turn Development Board";
+	compatible = "myir,zynq-zturn", "xlnx,zynq-7000";
+
+	aliases {
+		ethernet0 = &gem0;
+		serial0 = &uart1;
+		serial1 = &uart0;
+		spi0 = &qspi;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x30000000>; // Reserved 256MB for xylonfb driver
+	};
+
+	chosen {
+		bootargs = "console=ttyPS0,115200 root=/dev/ram rw earlyprintk";
+		linux,stdout-path = "/amba/serial@e0001000";
+	};
+};
+
+&gpio0 {
+    emio-gpio-width = <64>;
+    gpio-mask-high = <0x0>;
+    gpio-mask-low = <0x5600>;
+    xlnx,emio-gpio-width = <0x40>;
+    xlnx,mio-gpio-mask = <0x5600>;
+};
+
+&qspi {
+	status = "okay";
+	is-dual = <0>;
+	num-cs = <1>;
+	xlnx,fb-clk = <0x1>;
+	xlnx,qspi-mode = <0x0>;
+	flash@0 {
+		compatible = "n25q128";
+		reg = <0x0>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <50000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		partition@qspi-boot {
+			label = "qspi-boot";
+			reg = <0x0 0x080000>;
+		};
+		partition@qspi-bootenv {
+			label = "qspi-bootenv";
+			reg = <0x080000 0x020000>;
+		};		
+		partition@qspi-bitstream {
+			label = "qspi-bitstream";
+			reg = <0x0A0000 0x460000>;
+		};		
+		partition@qspi-kernel {
+			label = "qspi-kernel";
+			reg = <0x500000 0x480000>;
+		};
+		partition@qspi-devicetree {
+			label = "qspi-devicetree";
+			reg = <0x980000 0x010000>;
+		};
+		partition@qspi-rootfs {
+			label = "qspi-rootfs";
+			reg = <0x990000 0x600000>;
+		};
+		partition@qspi-data {
+			label = "data";
+			reg = <0xF90000 0x070000>;
+		};
+	};
+};
+
+&usb0 {
+	status = "okay";
+	dr_mode = "host";
+	phy_type = "ulpi";	
+};
+
+&gem0 {
+	status = "okay";
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethernet_phy>;
+
+	ethernet_phy: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&sdhci0 {
+	status = "okay";
+    xlnx,has-cd = <0x1>;
+    xlnx,has-power = <0x0>;
+    xlnx,has-wp = <0x1>;
+};
+
+&uart0 {
+	status = "okay";
+    current-speed = <115200>;
+    port-number = <1>;
+    xlnx,has-modem = <0x0>;
+};
+
+&uart1 {
+	status = "okay";
+    current-speed = <115200>;
+    port-number = <0>;
+    xlnx,has-modem = <0x0>;
+};
+
+&i2c0 {
+	status = "okay";
+//  bus-id = <0x0>;
+    clock-frequency = <400000>;
+    xlnx,has-interrupt = <0x1>;
+	
+    adxl345@53 {
+        compatible = "adi,adxl34x","adxl34x";
+        reg = <0x53>;
+        interrupt-parent = <&intc>;
+        interrupts = < 0 31 4 >;
+    };
+
+    sii902x@3b {
+        compatible = "sii902x";
+        reg = <0x3b>;
+        interrupt-parent = <&intc>;
+        interrupts = < 0 29 4 >;
+		mode_str = "1920x1080";
+		bits-per-pixel = <16>;
+    };
+
+	stlm75@49 {
+		status = "okay";
+		compatible = "myir-stlm75x";
+		reg = <0x49>;
+		interrupts = < 0 32 4 >;
+	};
+};
+
+/*
+&i2c1 {
+	status = "okay";
+    clock-frequency = <400000>;
+    xlnx,has-interrupt = <0x1>;
+    
+	ft0x5x_ts@38 {
+        compatible = "ft5x06_ts";
+        reg = <0x38>;
+        tp_int = <&gpio0 106 1>;
+        tp_resetn = <&gpio0 107 1>;
+	    polling_mode = /bits/ 8 <0>;
+        multi_touch = /bits/ 8 <0>;
+    };	
+};
+*/
+
+&can0 {
+	status = "okay";
+};
+
+&amba {
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		led_r {
+			label = "led_r";
+			gpios = <&gpio0 114 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		led_g {
+			label = "led_g";
+			gpios = <&gpio0 115 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		led_b {
+			label = "led_b";
+			gpios = <&gpio0 116 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		usr_led1 {
+			label = "usr_led1";
+			gpios = <&gpio0 0 1>;
+			default-state = "off";
+			linux,default-trigger = "none";
+		};
+		usr_led2 {
+			label = "usr_led2";
+			gpios = <&gpio0 9 1>;
+			default-state = "off";
+			linux,default-trigger = "none";
+		};
+	};
+	
+    gpio-beep {
+            compatible = "gpio-beeper";
+            lable = "pl-beep";
+            gpios = <&gpio0 117 0>;
+        };
+	
+/* MYIR, added USR key */
+	gpio-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		K1 {
+			label = "K1";
+			gpios = <&gpio0 50 1>;
+			linux,code = <102>; /* KEY_HOME */
+			gpio-key,wakeup;
+			autorepeat;
+		};
+
+/*	Switches
+		sw1 {
+			label = "sw1";
+			gpios = <&gpio0 110 1>;
+			linux,code = <103>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw2 {
+			label = "sw2";
+			gpios = <&gpio0 111 1>;
+			linux,code = <104>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw3 {
+			label = "sw3";
+			gpios = <&gpio0 112 1>;
+			linux,code = <104>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw4 {
+			label = "sw4";
+			gpios = <&gpio0 113 1>;
+			linux,code = <105>;
+			gpio-key,wakeup;
+			autorepeat;
+		}; */
+	};
+	
+};
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -57,6 +57,9 @@
 
 endif
 
+# Added by MYIR
+LOADADDR ?= 0x8000
+
 ifneq ($(LOADADDR),)
   UIMAGE_LOADADDR=$(LOADADDR)
 else
--- a/drivers/input/misc/adxl34x.c
+++ b/drivers/input/misc/adxl34x.c
@@ -222,7 +222,7 @@
 	.free_fall_threshold = 8,
 	.free_fall_time = 0x20,
 	.data_rate = 8,
-	.data_range = ADXL_FULL_RES,
+	.data_range = ADXL_FULL_RES|INT_INVERT, /* set to active LOW */
 
 	.ev_type = EV_ABS,
 	.ev_code_x = ABS_X,	/* EV_REL */
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x06_ts.h
@@ -0,0 +1,84 @@
+#ifndef __LINUX_FT5X0X_TS_H__
+#define __LINUX_FT5X0X_TS_H__
+ 
+#define SCREEN_MAX_X    800
+#define SCREEN_MAX_Y    480
+#define PRESS_MAX       255
+ 
+#define FT5X0X_NAME    "ft5x06_ts"
+ /* Structure for ft5x0x */
+struct ft5x0x_ts_platform_data {
+		u32    tp_resetn;	   /* reset pin */
+		u32    tp_int;		   /* int pin */
+        u16    irq;            /* irq number of ts used */
+        u8     polling_mode;   /* set 1 for polling mode and 0 for interruputing mode */
+        u8     multi_touch;    /* set 1 if supporting multi-touch */
+};
+
+enum ft5x0x_ts_regs {
+    FT5X0X_REG_THGROUP                    = 0x80,
+    FT5X0X_REG_THPEAK                        = 0x81,
+    FT5X0X_REG_THCAL                        = 0x82,
+    FT5X0X_REG_THWATER                    = 0x83,
+    FT5X0X_REG_THTEMP                    = 0x84,
+    FT5X0X_REG_THDIFF                        = 0x85,                
+    FT5X0X_REG_CTRL                        = 0x86,
+    FT5X0X_REG_TIMEENTERMONITOR            = 0x87,
+    FT5X0X_REG_PERIODACTIVE                = 0x88,
+    FT5X0X_REG_PERIODMONITOR            = 0x89,
+    FT5X0X_REG_HEIGHT_B                    = 0x8a,
+    FT5X0X_REG_MAX_FRAME                    = 0x8b,
+    FT5X0X_REG_DIST_MOVE                    = 0x8c,
+    FT5X0X_REG_DIST_POINT                = 0x8d,
+    FT5X0X_REG_FEG_FRAME                    = 0x8e,
+    FT5X0X_REG_SINGLE_CLICK_OFFSET        = 0x8f,
+    FT5X0X_REG_DOUBLE_CLICK_TIME_MIN    = 0x90,
+    FT5X0X_REG_SINGLE_CLICK_TIME            = 0x91,
+    FT5X0X_REG_LEFT_RIGHT_OFFSET        = 0x92,
+    FT5X0X_REG_UP_DOWN_OFFSET            = 0x93,
+    FT5X0X_REG_DISTANCE_LEFT_RIGHT        = 0x94,
+    FT5X0X_REG_DISTANCE_UP_DOWN        = 0x95,
+    FT5X0X_REG_ZOOM_DIS_SQR                = 0x96,
+    FT5X0X_REG_RADIAN_VALUE                =0x97,
+    FT5X0X_REG_MAX_X_HIGH                           = 0x98,
+    FT5X0X_REG_MAX_X_LOW                         = 0x99,
+    FT5X0X_REG_MAX_Y_HIGH                        = 0x9a,
+    FT5X0X_REG_MAX_Y_LOW                         = 0x9b,
+    FT5X0X_REG_K_X_HIGH                        = 0x9c,
+    FT5X0X_REG_K_X_LOW                         = 0x9d,
+    FT5X0X_REG_K_Y_HIGH                        = 0x9e,
+    FT5X0X_REG_K_Y_LOW                         = 0x9f,
+    FT5X0X_REG_AUTO_CLB_MODE            = 0xa0,
+    FT5X0X_REG_LIB_VERSION_H                 = 0xa1,
+    FT5X0X_REG_LIB_VERSION_L                 = 0xa2,        
+    FT5X0X_REG_CIPHER                        = 0xa3,
+    FT5X0X_REG_MODE                        = 0xa4,
+    FT5X0X_REG_PMODE                        = 0xa5,    /* Power Consume Mode        */    
+    FT5X0X_REG_FIRMID                        = 0xa6,
+    FT5X0X_REG_STATE                        = 0xa7,
+    FT5X0X_REG_FT5201ID                    = 0xa8,
+    FT5X0X_REG_ERR                        = 0xa9,
+    FT5X0X_REG_CLB                        = 0xaa,
+};
+ 
+//FT5X0X_REG_PMODE
+#define PMODE_ACTIVE        0x00
+#define PMODE_MONITOR       0x01
+#define PMODE_STANDBY       0x02
+#define PMODE_HIBERNATE     0x03
+ 
+ 
+    #ifndef ABS_MT_TOUCH_MAJOR
+    #define ABS_MT_TOUCH_MAJOR    0x30    /* touching ellipse */
+    #define ABS_MT_TOUCH_MINOR    0x31    /* (omit if circular) */
+    #define ABS_MT_WIDTH_MAJOR    0x32    /* approaching ellipse */
+    #define ABS_MT_WIDTH_MINOR    0x33    /* (omit if circular) */
+    #define ABS_MT_ORIENTATION    0x34    /* Ellipse orientation */
+    #define ABS_MT_POSITION_X    0x35    /* Center X ellipse position */
+    #define ABS_MT_POSITION_Y    0x36    /* Center Y ellipse position */
+    #define ABS_MT_TOOL_TYPE    0x37    /* Type of touching device */
+    #define ABS_MT_BLOB_ID        0x38    /* Group set of pkts as blob */
+    #endif /* ABS_MT_TOUCH_MAJOR */
+ 
+ 
+#endif
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x0x.c
@@ -0,0 +1,715 @@
+/* 
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *    note: only support mulititouch    Wenfs 2010-10-01
+ */
+
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+ 
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include "ft5x06_ts.h"
+
+#if 0
+#define DEBUG 	1
+#define DEBUG_0 1
+#endif
+ 
+#ifdef DEBUG_0
+#define TS_DEBUG(fmt,args...) printk(fmt, ##args )
+#else
+#define TS_DEBUG(fmt,args...)
+#endif
+ 
+#ifdef DEBUG
+#define TS_DEBUG1(fmt,args...) printk(fmt, ##args )
+#else
+#define TS_DEBUG1(fmt,args...)
+#endif
+ 
+static struct i2c_client *this_client;
+static struct ft5x0x_ts_platform_data *ts_plat_data;
+ 
+struct ts_event {
+    u16    x1;
+    u16    y1;
+    u16    x2;
+    u16    y2;
+    u16    x3;
+    u16    y3;
+    u16    x4;
+    u16    y4;
+    u16    x5;
+    u16    y5;
+    u16    pressure;
+    s16 touch_ID1;
+    s16 touch_ID2;
+    s16 touch_ID3;
+    s16 touch_ID4;
+    s16 touch_ID5;
+    u8  touch_point;
+};
+ 
+struct ft5x0x_ts_data {
+    struct input_dev    *input_dev;
+    struct ts_event        event;
+
+    struct delayed_work     poll_work;
+    int stop_poll_flag;
+    struct work_struct     pen_event_work;
+    struct workqueue_struct *ts_workqueue;
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend    early_suspend;
+#endif
+};
+ 
+static int ft5x0x_i2c_rxdata(char *rxdata, int length)
+{
+    int ret;
+ 
+    struct i2c_msg msgs[] = {
+        {
+            .addr    = this_client->addr,
+            .flags    = 0,
+            .len    = 1,
+            .buf    = rxdata,
+        },
+        {
+            .addr    = this_client->addr,
+            .flags    = I2C_M_RD,
+            .len    = length,
+            .buf    = rxdata,
+        },
+    };
+ 
+    //msleep(1);
+    ret = i2c_transfer(this_client->adapter, msgs, 2);
+    if (ret < 0)
+        pr_err("msg %s i2c read error: %d\n", __func__, ret);
+    
+    return ret;
+}
+
+static void ft5x0x_ts_release(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    //TS_DEBUG("ft5x0x_ts_release\n");
+
+	if (ts_plat_data->multi_touch) {
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+	} else {
+		input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+		input_report_key(data->input_dev, BTN_TOUCH, 0);
+	}
+    input_sync(data->input_dev);
+}
+ 
+static int ft5x0x_read_data(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    struct ts_event *event = &data->event;
+    u8 buf[32] = {0};
+    int ret = -1;
+    int status = 0;
+
+	if (ts_plat_data->multi_touch) {
+		ret = ft5x0x_i2c_rxdata(buf, 31);
+	} else {
+		ret = ft5x0x_i2c_rxdata(buf, 7);
+	}
+    if (ret < 0) {
+        printk("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+        return ret;
+    }
+ 
+    memset(event, 0, sizeof(struct ts_event));
+    event->touch_point = buf[2] & 0x07;// 000 0111
+ 
+    if (event->touch_point == 0) {
+        ft5x0x_ts_release();
+        return 1; 
+    }
+
+	if (ts_plat_data->multi_touch) {
+		switch (event->touch_point) {
+		case 5:
+			event->x5 = (s16)(buf[0x1b] & 0x0F)<<8 | (s16)buf[0x1c];
+			event->y5 = (s16)(buf[0x1d] & 0x0F)<<8 | (s16)buf[0x1e];
+			status = (s16)((buf[0x1b] & 0xc0) >> 6);
+			event->touch_ID5=(s16)(buf[0x1D] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 4:
+			event->x4 = (s16)(buf[0x15] & 0x0F)<<8 | (s16)buf[0x16];
+			event->y4 = (s16)(buf[0x17] & 0x0F)<<8 | (s16)buf[0x18];
+			status = (s16)((buf[0x15] & 0xc0) >> 6);
+			event->touch_ID4=(s16)(buf[0x17] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 3:
+			event->x3 = (s16)(buf[0x0f] & 0x0F)<<8 | (s16)buf[0x10];
+			event->y3 = (s16)(buf[0x11] & 0x0F)<<8 | (s16)buf[0x12];
+			status = (s16)((buf[0x0f] & 0xc0) >> 6);
+			event->touch_ID3=(s16)(buf[0x11] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 2:
+			event->x2 = (s16)(buf[9] & 0x0F)<<8 | (s16)buf[10];
+			event->y2 = (s16)(buf[11] & 0x0F)<<8 | (s16)buf[12];
+			status = (s16)((buf[0x9] & 0xc0) >> 6);
+			event->touch_ID2=(s16)(buf[0x0b] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 1:
+			event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+			event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+			status = (s16)((buf[0x3] & 0xc0) >> 6);
+			event->touch_ID1=(s16)(buf[0x05] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+			break;
+		default:
+			return -1;
+		}
+	} else {
+		if (event->touch_point == 1) {
+			event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+			event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+		}
+	}
+    event->pressure = 200;
+
+    dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+			event->x1, event->y1, event->x2, event->y2);
+ 
+    return 0;
+}
+ 
+static void ft5x0x_report_value(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    struct ts_event *event = &data->event;
+ 
+	TS_DEBUG("==ft5x0x_report_value =\n");
+
+	if (ts_plat_data->multi_touch) {
+		switch(event->touch_point) {
+		case 5:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID5);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x5);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y5);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 4:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID4);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x4);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y4);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 3:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID3);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x3);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y3);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 2:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID2);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x2);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y2);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 1:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID1);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x1);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y1);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+		default:
+			TS_DEBUG("==touch_point default =\n");
+			break;
+		}
+	} else {
+		if (event->touch_point == 1) {
+			input_report_abs(data->input_dev, ABS_X, event->x1);
+			input_report_abs(data->input_dev, ABS_Y, event->y1);
+			input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+		}
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+	}
+    input_sync(data->input_dev);
+ 
+    dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+			event->x1, event->y1, event->x2, event->y2);
+    TS_DEBUG1("1:(%d, %d) 2:(%d, %d) 3:(%d, %d) 4:(%d, %d) 5:(%d, %d)\n", 
+			  event->x1, event->y1, event->x2, event->y2, event->x3, event->y3,
+			  event->x4, event->y4, event->x5, event->y5);
+}    /*end ft5x0x_report_value*/
+
+/* Added by Kevin, test only */
+static void ft5x0x_poll_work(struct work_struct *work)
+{
+    int ret = -1;
+	struct delayed_work* dwork = to_delayed_work(work);
+	struct ft5x0x_ts_data *ts_data = container_of(dwork, struct ft5x0x_ts_data, poll_work);
+
+    ret = ft5x0x_read_data();
+    if (ret == 0) {
+        ft5x0x_report_value();
+    }
+
+    if (!ts_data->stop_poll_flag) {
+        queue_delayed_work(ts_data->ts_workqueue, &ts_data->poll_work, 2);
+    } else {
+        printk(KERN_ERR"stop polling...\n");
+    }
+}
+
+static void ft5x0x_ts_pen_irq_work(struct work_struct *work)
+{
+    int ret = -1;
+ 
+    TS_DEBUG("==work 1=\n");
+    ret = ft5x0x_read_data();    
+    if (ret == 0) {    
+        ft5x0x_report_value();
+    }
+    else
+        TS_DEBUG("data package read error\n");
+    TS_DEBUG("==work 2=\n");
+}
+
+static irqreturn_t ft5x0x_ts_interrupt(int irq, void *dev_id)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts = dev_id;
+ 
+    TS_DEBUG("==int ft5x0x_ts_interrupt=\n");
+    if (!work_pending(&ft5x0x_ts->pen_event_work)) {
+        queue_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->pen_event_work);
+    }
+ 
+    return IRQ_HANDLED;
+}
+ 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ft5x0x_ts_suspend(struct early_suspend *handler)
+{
+	//    struct ft5x0x_ts_data *ts;
+	//    ts =  container_of(handler, struct ft5x0x_ts_data, early_suspend);
+ 
+    TS_DEBUG("==ft5x0x_ts_suspend=\n");
+	//    disable_irq(this_client->irq);
+	//    disable_irq(IRQ_EINT(6));
+	//    cancel_work_sync(&ts->pen_event_work);
+	//    flush_workqueue(ts->ts_workqueue);
+    // ==set mode ==, 
+	//        ft5x0x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+}
+ 
+static void ft5x0x_ts_resume(struct early_suspend *handler)
+{
+    TS_DEBUG("==ft5x0x_ts_resume=\n");
+    // wake the mode
+	//    __gpio_as_output(GPIO_FT5X0X_WAKE);        
+	//    __gpio_clear_pin(GPIO_FT5X0X_WAKE);        //set wake = 0,base on system
+	//     msleep(100);
+	//    __gpio_set_pin(GPIO_FT5X0X_WAKE);            //set wake = 1,base on system
+	//    msleep(100);
+	//    enable_irq(this_client->irq);
+	//    enable_irq(IRQ_EINT(6));
+}
+#endif  //CONFIG_HAS_EARLYSUSPEND
+
+/* Parse the ft5x0x from device tree, MYiR */
+#if defined(CONFIG_OF)
+static const struct of_device_id ft5x0x_ts_match[];
+
+static struct ft5x0x_ts_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	struct ft5x0x_ts_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+	const struct of_device_id *match;
+
+	match = of_match_device(of_match_ptr(ft5x0x_ts_match), dev);
+	if (!match)
+		return ERR_PTR(-EINVAL);
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	if (of_property_read_u8(np, "polling_mode", &pdata->polling_mode)) {
+		dev_err(dev, "Failed to get polling_mode property, set to 0\n");
+		pdata->polling_mode = 0;
+	}
+
+	if (of_property_read_u8(np, "multi_touch", &pdata->multi_touch)) {
+		dev_err(dev, "Failed to get multi_touch property, set to 0\n");
+		pdata->multi_touch = 0;
+	}
+
+	pdata->tp_int = of_get_named_gpio_flags(np, "tp_int", 0, NULL);
+	if (gpio_is_valid(pdata->tp_int)) {	
+		//printk("tp int gpio=%d\n", pdata->tp_int);
+		if (gpio_request(pdata->tp_int, "touch irq")) {
+			printk("request touch gpio[%d] err\n", pdata->tp_int);
+			pdata->tp_int = -1;
+		} else {
+			pdata->irq = gpio_to_irq(pdata->tp_int);
+			//printk("touch tp_int irq=%d\n", pdata->irq);
+		}
+	}
+	
+	pdata->tp_resetn = of_get_named_gpio_flags(np, "tp_resetn", 0, NULL);
+	printk("tp reset gpio=%d\n", pdata->tp_resetn);
+
+	TS_DEBUG("ft5x0x detected, polling_mode: %d, multi_touch: %d\n",
+			pdata->polling_mode, pdata->multi_touch);
+
+	dev_dbg(dev, "ft5x0x detected, polling_mode: %d, multi_touch: %d\n",
+			pdata->polling_mode, pdata->multi_touch);
+
+	return pdata;
+}
+#else
+static struct ft5x0x_ts_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
+static int 
+ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts;
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+    struct input_dev *input_dev;
+    int err = 0;
+    
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        err = -ENODEV;
+        goto exit_check_functionality_failed;
+    }
+
+	/*
+	 * Add by JBO
+	 * Use platform data to initialize ft5x0x
+	 */
+	this_client = client;
+	ts_plat_data = dev_get_platdata(&client->dev);
+	if (np) {
+		ts_plat_data = ft5x0x_parse_dt(dev);
+		if (IS_ERR(ts_plat_data))
+			goto exit_get_platdata_failed;
+
+		if (client->irq && !ts_plat_data->irq) {
+			ts_plat_data->irq = client->irq;
+		} else {
+			client->irq = ts_plat_data->irq;
+		}
+	} else if (!ts_plat_data)
+		goto exit_get_platdata_failed;
+
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		err = gpio_request(ts_plat_data->tp_resetn, "tp_resetn");
+		if (!err) {
+			gpio_direction_output(ts_plat_data->tp_resetn, 1);
+			gpio_export(ts_plat_data->tp_resetn, 0);
+			// may be you need some delay here
+		} else {
+			printk("request tp_resetn[gpio %d] err:%d\n", 
+					ts_plat_data->tp_resetn, err);
+		}
+	}
+	//  Read device ID
+    err = 0xa1;
+    if (ft5x0x_i2c_rxdata((char *)&err, 2) < 0) {
+    	printk(KERN_ERR"ft5x0x read ID error!\n");
+		goto exit_check_functionality_failed;
+    }
+    printk(KERN_ERR "ft5x0x id: 0x%04X\n", err);
+    err = 0;
+
+    TS_DEBUG("==kzalloc=\n");
+    ft5x0x_ts = kzalloc(sizeof(*ft5x0x_ts), GFP_KERNEL);
+    if (!ft5x0x_ts)    {
+        err = -ENOMEM;
+        goto exit_alloc_data_failed;
+    }
+ 
+    TS_DEBUG("==i2c_set_clientdata=\n");
+	//    this_client = client;
+    i2c_set_clientdata(client, ft5x0x_ts);
+	//    i2c_jz_setclk(client, 100*1000);
+ 
+    TS_DEBUG("==INIT_WORK=\n");
+
+	if (ts_plat_data->polling_mode) {
+		/* Added by Kevin, test only */
+		TS_DEBUG("poll mode\n");	
+		INIT_DELAYED_WORK(&ft5x0x_ts->poll_work, ft5x0x_poll_work);
+		ft5x0x_ts->stop_poll_flag = 0;
+	} else {
+		INIT_WORK(&ft5x0x_ts->pen_event_work, ft5x0x_ts_pen_irq_work);
+	}
+
+    TS_DEBUG("==create_singlethread_workqueue=\n");
+    ft5x0x_ts->ts_workqueue = create_singlethread_workqueue(dev_name(&client->dev));
+    if (!ft5x0x_ts->ts_workqueue) {
+        err = -ESRCH;
+        goto exit_create_singlethread;
+    }
+
+	if (!ts_plat_data->polling_mode) {
+		err = request_irq(ts_plat_data->irq, ft5x0x_ts_interrupt, 
+				 IRQF_TRIGGER_FALLING, "ft5x0x_ts", ft5x0x_ts);
+		if (err < 0) {
+			dev_err(&client->dev, "ft5x0x_probe: request irq failed\n");
+			goto exit_irq_request_failed;
+		}
+	}
+
+    TS_DEBUG("==input_allocate_device=\n");
+    input_dev = input_allocate_device();
+    if (!input_dev) {
+        err = -ENOMEM;
+        dev_err(&client->dev, "failed to allocate input device\n");
+        goto exit_input_dev_alloc_failed;
+    }
+    
+    ft5x0x_ts->input_dev = input_dev;
+
+	if (ts_plat_data->multi_touch) {
+		set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+		set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+		set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+		set_bit(ABS_MT_WIDTH_MAJOR, input_dev->absbit);
+ 
+		input_set_abs_params(input_dev,
+							 ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_TOUCH_MAJOR, 0, PRESS_MAX, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);
+	} else {
+		set_bit(ABS_X, input_dev->absbit);
+		set_bit(ABS_Y, input_dev->absbit);
+		set_bit(ABS_PRESSURE, input_dev->absbit);
+		set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+		input_set_abs_params(input_dev, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+		input_set_abs_params(input_dev, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+	}
+ 
+    set_bit(EV_ABS, input_dev->evbit);
+    set_bit(EV_KEY, input_dev->evbit);
+ 
+    input_dev->name        = FT5X0X_NAME;        //dev_name(&client->dev)
+    err = input_register_device(input_dev);
+    if (err) {
+        dev_err(&client->dev,
+				"ft5x0x_ts_probe: failed to register input device: %s\n",
+				dev_name(&client->dev));
+        goto exit_input_register_device_failed;
+    }
+ 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    TS_DEBUG("==register_early_suspend =\n");
+    ft5x0x_ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    ft5x0x_ts->early_suspend.suspend = ft5x0x_ts_suspend;
+    ft5x0x_ts->early_suspend.resume    = ft5x0x_ts_resume;
+    register_early_suspend(&ft5x0x_ts->early_suspend);
+#endif
+	//wake the CTPM
+	//    __gpio_as_output(GPIO_FT5X0X_WAKE);        
+	//    __gpio_clear_pin(GPIO_FT5X0X_WAKE);        //set wake = 0,base on system
+	//     msleep(100);
+	//    __gpio_set_pin(GPIO_FT5X0X_WAKE);            //set wake = 1,base on system
+	//    msleep(100);
+	//    ft5x0x_set_reg(0x88, 0x05); //5, 6,7,8
+	//    ft5x0x_set_reg(0x80, 30);
+	//    msleep(50);
+
+	if (!ts_plat_data->polling_mode) {
+		//   enable_irq(this_client->irq);
+		//    enable_irq(IRQ_EINT(6));
+
+	} else {
+		/* Added by Kevin, test only */
+		TS_DEBUG("queue delay work\n");	
+		queue_delayed_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->poll_work, 2); 
+	}
+
+    TS_DEBUG("==probe over =, this_client->irq=%d\n\n\n", ts_plat_data->irq);
+    return 0;
+ 
+ exit_input_register_device_failed:
+    input_free_device(input_dev);
+ exit_input_dev_alloc_failed:
+	if (!ts_plat_data->polling_mode)
+		free_irq(ts_plat_data->irq, ft5x0x_ts);
+	//    free_irq(IRQ_EINT(6), ft5x0x_ts);
+ exit_irq_request_failed:
+
+	//exit_platform_data_null:
+	if (!ts_plat_data->polling_mode)
+		cancel_delayed_work_sync(&ft5x0x_ts->poll_work);
+	else
+		cancel_work_sync(&ft5x0x_ts->pen_event_work);
+
+    destroy_workqueue(ft5x0x_ts->ts_workqueue);
+ exit_create_singlethread:
+    TS_DEBUG("==singlethread error =\n\n\n");
+    i2c_set_clientdata(client, NULL);
+    kfree(ft5x0x_ts);
+ exit_alloc_data_failed:
+ exit_get_platdata_failed:
+ 	if (gpio_is_valid(ts_plat_data->tp_int)) {
+ 		gpio_free(ts_plat_data->tp_int);
+ 	}
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		gpio_free(ts_plat_data->tp_resetn);
+	}
+ exit_check_functionality_failed:
+    return err;
+}
+ 
+static int ft5x0x_ts_remove(struct i2c_client *client)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+    TS_DEBUG("==ft5x0x_ts_remove=\n");
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&ft5x0x_ts->early_suspend);
+#endif
+
+	if (!ts_plat_data->polling_mode) {
+		printk("free irq %d\n", client->irq);
+		free_irq(client->irq, ft5x0x_ts);
+		cancel_work_sync(&ft5x0x_ts->pen_event_work);
+	} else {
+		/* Added by Kevin, test only */
+		ft5x0x_ts->stop_poll_flag = 1;
+		cancel_delayed_work_sync(&ft5x0x_ts->poll_work);
+	}
+    destroy_workqueue(ft5x0x_ts->ts_workqueue);
+    i2c_set_clientdata(client, NULL);
+
+    input_unregister_device(ft5x0x_ts->input_dev);
+    kfree(ft5x0x_ts);
+	
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		printk("gpio free %d\n", ts_plat_data->tp_resetn);
+		gpio_free(ts_plat_data->tp_resetn);
+	}
+
+    if (gpio_is_valid(ts_plat_data->tp_int)) {
+    	printk("gpio free %d\n", ts_plat_data->tp_int);
+    	gpio_free(ts_plat_data->tp_int);
+    }
+    return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id ft5x0x_ts_match[] = {
+	{ .compatible = FT5X0X_NAME, },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ft5x0x_ts_match);
+#endif
+
+static const struct i2c_device_id ft5x0x_ts_id[] = {
+    { FT5X0X_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ft5x0x_ts_id);
+
+static struct i2c_driver ft5x0x_ts_driver = {
+    .probe        = ft5x0x_ts_probe,
+    .remove        = ft5x0x_ts_remove,
+    .id_table    = ft5x0x_ts_id,
+    .driver    = {
+        .name    = FT5X0X_NAME,
+		.owner    = THIS_MODULE,
+		.of_match_table = of_match_ptr(ft5x0x_ts_match),
+    },
+};
+
+static int __init ft5x0x_ts_init(void)
+{
+	int err = 0;
+	
+	if (i2c_add_driver(&ft5x0x_ts_driver) != 0) {
+		printk("i2c_add_driver: can't add i2c driver\n");
+		err = -ENODEV;
+		goto err_driver;
+	}
+
+	printk("ft5x0x_ts_init successful\n");
+	
+	return 0;
+
+ err_driver:
+	printk("ft5x0x_ts_init fail\n");
+	return err;
+}
+
+static void __exit ft5x0x_ts_exit(void)
+{
+	i2c_del_driver(&ft5x0x_ts_driver);
+	this_client = NULL;
+}
+
+ 
+module_init(ft5x0x_ts_init);
+module_exit(ft5x0x_ts_exit);
+ 
+MODULE_AUTHOR("Kevin Su<kevin.su@myirtech.com>");
+MODULE_DESCRIPTION("FocalTech ft5x0x TouchScreen driver");
+MODULE_LICENSE("GPL");
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1155,4 +1155,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called bu21023_ts.
 
+config TOUCHSCREEN_FT5X0X
+	tristate "FT5X0X touchscreens"
+	depends on I2C
+	help
+	  Say Y here if you have a touchscreen using the ft5x0x chip
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called zforce_ts.	  
+
 endif
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -93,5 +93,6 @@
 obj-$(CONFIG_TOUCHSCREEN_SX8654)	+= sx8654.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -816,6 +816,13 @@
 
 	  If unsure, say N
 
+config MYIR_STLM75X
+	tristate "MYIR stlm75x temperature sensor"
+	depends on ARCH_ZYNQ
+	    default y
+	help
+	  This option enables support for the stlm75x temperature driver.
+
 source "drivers/misc/jesd204b/Kconfig"
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -56,6 +56,7 @@
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
 obj-$(CONFIG_ECHO)		+= echo/
+obj-$(CONFIG_MYIR_STLM75X)	+= myir_stlm75x.o
 obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_PANEL)             += panel.o
--- /dev/null
+++ b/drivers/misc/myir_stlm75x.c
@@ -0,0 +1,249 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+//#include <linux/sysdev.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/kdev_t.h>
+#include <linux/i2c.h>
+
+#define DEV_NAME		"myir-stlm75x"
+
+/*********************
+ *	Register define  *
+ *********************/
+#define REG_TEMP	0x0
+#define REG_CON		0x1
+#define REG_TOS		0x2
+#define REG_THYS	0x3
+
+#define MAX_CONV_MS	150
+#define SIGN_MASK	(0x1 << 15)
+#define TEMP_SHIFT	7
+#define TEMP_MASK	(0xFF << TEMP_SHIFT)
+#define DEGREE_PER_CNT	0.5
+
+struct myir_stlm75x_data {
+	struct i2c_client *client;
+	struct class class;
+	struct mutex mutex;
+	u16 temp_tos;
+	u16 temp_thys;
+	u16 temp_value;
+};
+
+inline int to_readable_value(u16 _value)
+{
+	int value;
+	if (_value & SIGN_MASK) {
+		value = -(~((_value & TEMP_MASK) >> TEMP_SHIFT) + 1);
+	} else {
+		value = ((_value & TEMP_MASK) >> TEMP_SHIFT);
+	}
+//	printk(KERN_ERR "value to read: %d\n", value);
+	return value;
+}
+
+#if 0
+inline u16 to_register_value(int/*float*/ degreex2)
+{
+	u16 ret;
+	if (degreex2 > 255) {
+		degreex2 = 255;
+	} else if (degreex2 < -255) {
+		degreex2 = -255;
+	}
+	ret = (u16)degreex2;
+	if (degreex2 >= 0) {
+		ret = (ret << TEMP_SHIFT) & TEMP_MASK;
+	} else {
+		ret = (ret << TEMP_SHIFT) & 0xFFFF;
+	}
+	printk(KERN_ERR "value to write: %#X\n", ret);
+	return ret;
+}
+#endif
+
+static int myir_stlm75x_readwrite(struct i2c_client *client,
+                   u16 wr_len, u8 *wr_buf,
+                   u16 rd_len, u8 *rd_buf)
+{
+    struct i2c_msg wrmsg[2];
+    int i = 0;
+    int ret;
+
+    if (wr_len) {
+        wrmsg[i].addr  = client->addr;
+        wrmsg[i].flags = 0;
+        wrmsg[i].len = wr_len;
+        wrmsg[i].buf = wr_buf;
+        i++;
+    }
+    if (rd_len) {
+        wrmsg[i].addr  = client->addr;
+        wrmsg[i].flags = I2C_M_RD;
+        wrmsg[i].len = rd_len;
+        wrmsg[i].buf = rd_buf;
+        i++;
+    }
+
+    ret = i2c_transfer(client->adapter, wrmsg, i);
+    if (ret < 0)
+        return ret;
+    if (ret != i)
+        return -EIO;
+
+    return 0;
+}
+
+static int myir_stlm75x_write_word(struct myir_stlm75x_data *pdata,
+                     u8 addr, u16 value)
+{
+    u8 wrbuf[3]={0};
+
+    wrbuf[0] = addr;
+    wrbuf[1] = (value>>8)&0xFF;
+    wrbuf[2] = value&0xFF;
+
+    return myir_stlm75x_readwrite(pdata->client, 3, wrbuf, 0, NULL);
+}
+
+static int myir_stlm75x_write_byte(struct myir_stlm75x_data *pdata,
+                     u8 addr, u8 value)
+{
+    u8 wrbuf[2]={0};
+
+    wrbuf[0] = addr;
+    wrbuf[1] = value;
+
+    return myir_stlm75x_readwrite(pdata->client, 2, wrbuf, 0, NULL);
+}
+
+static int myir_stlm75x_read_word(struct myir_stlm75x_data *pdata,
+                    u8 addr)
+{
+    u8 wrbuf[2], rdbuf[2]={0};
+    int error;
+
+    wrbuf[0] = addr;
+
+    error = myir_stlm75x_readwrite(pdata->client, 1, wrbuf, 2, rdbuf);
+    if (error)
+        return error;
+
+    return rdbuf[0]<<8|rdbuf[1];
+}
+
+static int myir_stlm75x_read_byte(struct myir_stlm75x_data *pdata,
+                    u8 addr)
+{
+    u8 wrbuf[2], rdbuf[2]={0};
+    int error;
+
+    wrbuf[0] = addr;
+
+    error = myir_stlm75x_readwrite(pdata->client, 1, wrbuf, 1, rdbuf);
+    if (error)
+        return error;
+
+    return rdbuf[0];
+}
+
+/* class attribute show function. */
+static ssize_t myir_stlm75x_show(struct class *cls, struct class_attribute *attr, char *buf)
+{
+	struct myir_stlm75x_data *pdata = (struct myir_stlm75x_data *)container_of(cls, struct myir_stlm75x_data, class);
+	int ret;
+	int value;
+	unsigned long start_time;
+	
+	mutex_lock(&pdata->mutex);
+	
+	start_time = jiffies;
+	pdata->temp_value = myir_stlm75x_read_word(pdata, REG_TEMP);
+//	printk(KERN_ERR "pdata->temp_value: %#X", pdata->temp_value);
+	value = to_readable_value(pdata->temp_value);
+	ret = sprintf(buf, "%d.%s\n", value/2, value%2?"5":"0");
+
+	while (time_before(jiffies, start_time + msecs_to_jiffies(MAX_CONV_MS))) schedule();
+	
+	mutex_unlock(&pdata->mutex);
+	
+	return ret;
+}
+
+/* Attributes declaration: Here I have declared only one attribute attr1 */
+static struct class_attribute myir_stlm75x_class_attrs[] = {
+	__ATTR(value_degree, S_IRUGO | S_IWUSR , myir_stlm75x_show, NULL), //use macro for permission
+	__ATTR_NULL
+};
+
+static int myir_stlm75x_probe(struct i2c_client *client,
+                     const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct myir_stlm75x_data *pdata = NULL;
+	
+	printk(KERN_ALERT "%s()\n", __func__);
+	
+	pdata = kmalloc(sizeof(struct myir_stlm75x_data), GFP_KERNEL);
+	if(!pdata) {
+		printk(KERN_ERR "No memory!\n");
+		return -ENOMEM;
+	}
+	memset(pdata, 0, sizeof(struct myir_stlm75x_data));
+
+	pdata->client = client;
+	
+	/* Init class */
+	mutex_init(&pdata->mutex);
+	pdata->class.name = DEV_NAME;
+	pdata->class.owner = THIS_MODULE;
+	pdata->class.class_attrs = myir_stlm75x_class_attrs;
+	ret = class_register(&pdata->class);
+	if(ret) {
+		printk(KERN_ERR "class_register failed!\n");
+		goto class_register_fail;
+	}
+	i2c_set_clientdata(client, pdata);
+	
+	printk(KERN_ALERT "%s driver initialized successfully!\n", DEV_NAME);
+	return 0;
+
+class_register_fail:
+	
+	return ret;
+}
+
+static int myir_stlm75x_remove(struct i2c_client *client)
+{
+    struct myir_stlm75x_data *pdata = i2c_get_clientdata(client);
+	
+	class_unregister(&pdata->class);
+	kfree(pdata);
+	i2c_set_clientdata(client, NULL);
+    return 0;
+}
+
+static const struct i2c_device_id myir_stlm75x_id[] = {
+    { DEV_NAME, 0 },
+    { }
+};
+
+static struct i2c_driver myir_stlm75x_driver = {
+    .driver = {
+        .owner	= THIS_MODULE,
+        .name	= DEV_NAME,
+    },
+    .id_table	= myir_stlm75x_id,
+    .probe		= myir_stlm75x_probe,
+    .remove		= myir_stlm75x_remove,
+};
+
+module_i2c_driver(myir_stlm75x_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Su <kevin.su@myirtech.com>");
+MODULE_DESCRIPTION("MYIR stlm75x temperature driver.");
--- a/drivers/gpu/drm/xylon/xylon_encoder.c
+++ b/drivers/gpu/drm/xylon/xylon_encoder.c
@@ -170,7 +170,7 @@
 	encoder->slave.base.possible_crtcs = 1;
 	ret = drm_encoder_init(dev, &encoder->slave.base,
 			       &xylon_drm_encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS);
+			       DRM_MODE_ENCODER_TMDS, NULL);
 	if (ret) {
 		DRM_ERROR("failed initialize encoder\n");
 		return ERR_PTR(ret);
--- /dev/null
+++ b/drivers/video/sii902x/edid.h
@@ -0,0 +1,138 @@
+/* 
+ * edid.h - EDID/DDC Header
+ *
+ * Based on:
+ *   1. XFree86 4.3.0, edid.h
+ *      Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ * 
+ *   2. John Fremlin <vii@users.sourceforge.net> and 
+ *      Ani Joshi <ajoshi@unixbox.com>
+ *
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+*/
+
+#ifndef __EDID_H__
+#define __EDID_H__
+
+#define EDID_LENGTH				0x80
+#define EDID_HEADER				0x00
+#define EDID_HEADER_END				0x07
+
+#define ID_MANUFACTURER_NAME			0x08
+#define ID_MANUFACTURER_NAME_END		0x09
+#define ID_MODEL				0x0a
+
+#define ID_SERIAL_NUMBER			0x0c
+
+#define MANUFACTURE_WEEK			0x10
+#define MANUFACTURE_YEAR			0x11
+
+#define EDID_STRUCT_VERSION			0x12
+#define EDID_STRUCT_REVISION			0x13
+
+#define EDID_STRUCT_DISPLAY                     0x14
+
+#define DPMS_FLAGS				0x18
+#define ESTABLISHED_TIMING_1			0x23
+#define ESTABLISHED_TIMING_2			0x24
+#define MANUFACTURERS_TIMINGS			0x25
+
+/* standard timings supported */
+#define STD_TIMING                              8
+#define STD_TIMING_DESCRIPTION_SIZE             2
+#define STD_TIMING_DESCRIPTIONS_START           0x26
+
+#define DETAILED_TIMING_DESCRIPTIONS_START	0x36
+#define DETAILED_TIMING_DESCRIPTION_SIZE	18
+#define NO_DETAILED_TIMING_DESCRIPTIONS		4
+
+#define DETAILED_TIMING_DESCRIPTION_1		0x36
+#define DETAILED_TIMING_DESCRIPTION_2		0x48
+#define DETAILED_TIMING_DESCRIPTION_3		0x5a
+#define DETAILED_TIMING_DESCRIPTION_4		0x6c
+
+#define DESCRIPTOR_DATA				5
+
+#define UPPER_NIBBLE( x ) \
+        (((128|64|32|16) & (x)) >> 4)
+
+#define LOWER_NIBBLE( x ) \
+        ((1|2|4|8) & (x))
+
+#define COMBINE_HI_8LO( hi, lo ) \
+        ( (((unsigned)hi) << 8) | (unsigned)lo )
+
+#define COMBINE_HI_4LO( hi, lo ) \
+        ( (((unsigned)hi) << 4) | (unsigned)lo )
+
+#define PIXEL_CLOCK_LO     (unsigned)block[ 0 ]
+#define PIXEL_CLOCK_HI     (unsigned)block[ 1 ]
+#define PIXEL_CLOCK	   (COMBINE_HI_8LO( PIXEL_CLOCK_HI,PIXEL_CLOCK_LO )*10000)
+#define H_ACTIVE_LO        (unsigned)block[ 2 ]
+#define H_BLANKING_LO      (unsigned)block[ 3 ]
+#define H_ACTIVE_HI        UPPER_NIBBLE( (unsigned)block[ 4 ] )
+#define H_ACTIVE           COMBINE_HI_8LO( H_ACTIVE_HI, H_ACTIVE_LO )
+#define H_BLANKING_HI      LOWER_NIBBLE( (unsigned)block[ 4 ] )
+#define H_BLANKING         COMBINE_HI_8LO( H_BLANKING_HI, H_BLANKING_LO )
+
+#define V_ACTIVE_LO        (unsigned)block[ 5 ]
+#define V_BLANKING_LO      (unsigned)block[ 6 ]
+#define V_ACTIVE_HI        UPPER_NIBBLE( (unsigned)block[ 7 ] )
+#define V_ACTIVE           COMBINE_HI_8LO( V_ACTIVE_HI, V_ACTIVE_LO )
+#define V_BLANKING_HI      LOWER_NIBBLE( (unsigned)block[ 7 ] )
+#define V_BLANKING         COMBINE_HI_8LO( V_BLANKING_HI, V_BLANKING_LO )
+
+#define H_SYNC_OFFSET_LO   (unsigned)block[ 8 ]
+#define H_SYNC_WIDTH_LO    (unsigned)block[ 9 ]
+
+#define V_SYNC_OFFSET_LO   UPPER_NIBBLE( (unsigned)block[ 10 ] )
+#define V_SYNC_WIDTH_LO    LOWER_NIBBLE( (unsigned)block[ 10 ] )
+
+#define V_SYNC_WIDTH_HI    ((unsigned)block[ 11 ] & (1|2))
+#define V_SYNC_OFFSET_HI   (((unsigned)block[ 11 ] & (4|8)) >> 2)
+
+#define H_SYNC_WIDTH_HI    (((unsigned)block[ 11 ] & (16|32)) >> 4)
+#define H_SYNC_OFFSET_HI   (((unsigned)block[ 11 ] & (64|128)) >> 6)
+
+#define V_SYNC_WIDTH       COMBINE_HI_4LO( V_SYNC_WIDTH_HI, V_SYNC_WIDTH_LO )
+#define V_SYNC_OFFSET      COMBINE_HI_4LO( V_SYNC_OFFSET_HI, V_SYNC_OFFSET_LO )
+
+#define H_SYNC_WIDTH       COMBINE_HI_8LO( H_SYNC_WIDTH_HI, H_SYNC_WIDTH_LO )
+#define H_SYNC_OFFSET      COMBINE_HI_8LO( H_SYNC_OFFSET_HI, H_SYNC_OFFSET_LO )
+
+#define H_SIZE_LO          (unsigned)block[ 12 ]
+#define V_SIZE_LO          (unsigned)block[ 13 ]
+
+#define H_SIZE_HI          UPPER_NIBBLE( (unsigned)block[ 14 ] )
+#define V_SIZE_HI          LOWER_NIBBLE( (unsigned)block[ 14 ] )
+
+#define H_SIZE             COMBINE_HI_8LO( H_SIZE_HI, H_SIZE_LO )
+#define V_SIZE             COMBINE_HI_8LO( V_SIZE_HI, V_SIZE_LO )
+
+#define H_BORDER           (unsigned)block[ 15 ]
+#define V_BORDER           (unsigned)block[ 16 ]
+
+#define FLAGS              (unsigned)block[ 17 ]
+
+#define INTERLACED         (FLAGS&128)
+#define SYNC_TYPE          (FLAGS&3<<3)	/* bits 4,3 */
+#define SYNC_SEPARATE      (3<<3)
+#define HSYNC_POSITIVE     (FLAGS & 4)
+#define VSYNC_POSITIVE     (FLAGS & 2)
+
+#define V_MIN_RATE              block[ 5 ]
+#define V_MAX_RATE              block[ 6 ]
+#define H_MIN_RATE              block[ 7 ]
+#define H_MAX_RATE              block[ 8 ]
+#define MAX_PIXEL_CLOCK         (((int)block[ 9 ]) * 10)
+#define GTF_SUPPORT		block[10]
+
+#define DPMS_ACTIVE_OFF		(1 << 5)
+#define DPMS_SUSPEND		(1 << 6)
+#define DPMS_STANDBY		(1 << 7)
+
+#endif /* __EDID_H__ */
--- /dev/null
+++ b/drivers/video/sii902x/Kconfig
@@ -0,0 +1,15 @@
+menuconfig MYIR_SII902X
+	tristate "MYIR sii902x HDMI driver support"
+	depends on FB
+	default y
+	help
+	  Choose this option if you want to use the MYIR sii902x hdmi
+	  for video output.
+	  
+config SII902X_EDID_READING
+	bool "Auto set videomode by reading monitor EDID (untested)"
+	depends on MYIR_SII902X
+	default n
+	help
+	  Choose this to enable videomode auto set by reading
+	  monitor EDID. Use system default videomode if unchecked.
--- /dev/null
+++ b/drivers/video/sii902x/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SII902X_EDID_READING)	+= myir_edid.o
+obj-$(CONFIG_MYIR_SII902X) += myir_sii902x.o
--- /dev/null
+++ b/drivers/video/sii902x/myir_edid.c
@@ -0,0 +1,768 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file myir_edid.c
+ *
+ * @brief MYIR EDID driver
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/i2c.h>
+#include <linux/fb.h>
+#include "myir_edid.h"
+#include "edid.h"
+
+#define DEBUG	1  /* define this for verbose EDID parsing output */
+#ifdef DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_INFO fmt, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+const struct fb_videomode myir_cea_mode[64] = {
+	/* #1: 640x480p@59.94/60Hz 4:3 */
+	[1] = {
+		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #2: 720x480p@59.94/60Hz 4:3 */
+	[2] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #3: 720x480p@59.94/60Hz 16:9 */
+	[3] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #4: 1280x720p@59.94/60Hz 16:9 */
+	[4] = {
+		NULL, 60, 1280, 720, 13468, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #5: 1920x1080i@59.94/60Hz 16:9 */
+	[5] = {
+		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
+	[6] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
+	[7] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
+	[8] = {
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
+	[9] = {
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #14: 1440x480p@59.94/60Hz 4:3 */
+	[14] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #15: 1440x480p@59.94/60Hz 16:9 */
+	[15] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #16: 1920x1080p@60Hz 16:9 */
+	[16] = {
+		NULL, 60, 1920, 1080, 6734, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #17: 720x576pH@50Hz 4:3 */
+	[17] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #18: 720x576pH@50Hz 16:9 */
+	[18] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #19: 1280x720p@50Hz */
+	[19] = {
+		NULL, 50, 1280, 720, 13468, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #20: 1920x1080i@50Hz */
+	[20] = {
+		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #23: 720(1440)x288pH@50Hz 4:3 */
+	[23] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #24: 720(1440)x288pH@50Hz 16:9 */
+	[24] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #29: 720(1440)x576pH@50Hz 4:3 */
+	[29] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #30: 720(1440)x576pH@50Hz 16:9 */
+	[30] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #31: 1920x1080p@50Hz */
+	[31] = {
+		NULL, 50, 1920, 1080, 6734, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #32: 1920x1080p@23.98/24Hz */
+	[32] = {
+		NULL, 24, 1920, 1080, 13468, 148, 638, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #33: 1920x1080p@25Hz */
+	[33] = {
+		NULL, 25, 1920, 1080, 13468, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #34: 1920x1080p@30Hz */
+	[34] = {
+		NULL, 30, 1920, 1080, 13468, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #41: 1280x720p@100Hz 16:9 */
+	[41] = {
+		NULL, 100, 1280, 720, 6734, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #47: 1280x720p@119.88/120Hz 16:9 */
+	[47] = {
+		NULL, 120, 1280, 720, 6734, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+};
+
+/*
+ * We have a special version of fb_mode_is_equal that ignores
+ * pixclock, since for many CEA modes, 2 frequencies are supported
+ * e.g. 640x480 @ 60Hz or 59.94Hz
+ */
+int myir_edid_fb_mode_is_equal(bool use_aspect,
+			const struct fb_videomode *mode1,
+			const struct fb_videomode *mode2)
+{
+	u32 mask;
+
+	if (use_aspect)
+		mask = ~0;
+	else
+		mask = ~FB_VMODE_ASPECT_MASK;
+
+	return (mode1->xres         == mode2->xres &&
+		mode1->yres         == mode2->yres &&
+		mode1->hsync_len    == mode2->hsync_len &&
+		mode1->vsync_len    == mode2->vsync_len &&
+		mode1->left_margin  == mode2->left_margin &&
+		mode1->right_margin == mode2->right_margin &&
+		mode1->upper_margin == mode2->upper_margin &&
+		mode1->lower_margin == mode2->lower_margin &&
+		mode1->sync         == mode2->sync &&
+		/* refresh check, 59.94Hz and 60Hz have the same parameter
+		 * in struct of myir_cea_mode */
+		abs(mode1->refresh - mode2->refresh) <= 1 &&
+		(mode1->vmode & mask) == (mode2->vmode & mask));
+}
+
+static void get_detailed_timing(unsigned char *block,
+				struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+	mode->pixclock /= 1000;
+	mode->pixclock = KHZ2PICOS(mode->pixclock);
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
+				     (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	if ((H_SIZE / 16) == (V_SIZE / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((H_SIZE / 4) == (V_SIZE / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+	else if ((mode->xres / 16) == (mode->yres / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((mode->xres / 4) == (mode->yres / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+
+	if (mode->vmode & FB_VMODE_ASPECT_16_9)
+		DPRINTK("Aspect ratio: 16:9\n");
+	if (mode->vmode & FB_VMODE_ASPECT_4_3)
+		DPRINTK("Aspect ratio: 4:3\n");
+	DPRINTK("      %d MHz ",  PIXEL_CLOCK/1000000);
+	DPRINTK("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	DPRINTK("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	DPRINTK("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	       (VSYNC_POSITIVE) ? "+" : "-");
+}
+
+int myir_edid_parse_ext_blk(unsigned char *edid,
+		struct myir_edid_cfg *cfg,
+		struct fb_monspecs *specs)
+{
+	char detail_timing_desc_offset;
+	struct fb_videomode *mode, *m;
+	unsigned char index = 0x0;
+	unsigned char *block;
+	int i, num = 0, revision;
+
+	if (edid[index++] != 0x2) /* only support cea ext block now */
+		return -1;
+	revision = edid[index++];
+	DPRINTK("cea extent revision %d\n", revision);
+	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
+	if (mode == NULL)
+		return -1;
+
+	detail_timing_desc_offset = edid[index++];
+
+	if (revision >= 2) {
+		cfg->cea_underscan = (edid[index] >> 7) & 0x1;
+		cfg->cea_basicaudio = (edid[index] >> 6) & 0x1;
+		cfg->cea_ycbcr444 = (edid[index] >> 5) & 0x1;
+		cfg->cea_ycbcr422 = (edid[index] >> 4) & 0x1;
+
+		DPRINTK("CEA underscan %d\n", cfg->cea_underscan);
+		DPRINTK("CEA basicaudio %d\n", cfg->cea_basicaudio);
+		DPRINTK("CEA ycbcr444 %d\n", cfg->cea_ycbcr444);
+		DPRINTK("CEA ycbcr422 %d\n", cfg->cea_ycbcr422);
+	}
+
+	if (revision >= 3) {
+		/* short desc */
+		DPRINTK("CEA Short desc timmings\n");
+		index++;
+		while (index < detail_timing_desc_offset) {
+			unsigned char tagcode, blklen;
+
+			tagcode = (edid[index] >> 5) & 0x7;
+			blklen = (edid[index]) & 0x1f;
+
+			DPRINTK("Tagcode %x Len %d\n", tagcode, blklen);
+
+			switch (tagcode) {
+			case 0x2: /*Video data block*/
+				{
+					int cea_idx;
+					i = 0;
+					while (i < blklen) {
+						index++;
+						cea_idx = edid[index] & 0x7f;
+						if (cea_idx < ARRAY_SIZE(myir_cea_mode) &&
+								(myir_cea_mode[cea_idx].xres)) {
+							DPRINTK("Support CEA Format #%d\n", cea_idx);
+							mode[num] = myir_cea_mode[cea_idx];
+							mode[num].flag |= FB_MODE_IS_STANDARD;
+							num++;
+						}
+						i++;
+					}
+					break;
+				}
+			case 0x3: /*Vendor specific data*/
+				{
+					unsigned char IEEE_reg_iden[3];
+					unsigned char deep_color;
+					unsigned char latency_present;
+					unsigned char I_latency_present;
+					unsigned char hdmi_video_present;
+					unsigned char hdmi_3d_present;
+					unsigned char hdmi_3d_multi_present;
+					unsigned char hdmi_vic_len;
+					unsigned char hdmi_3d_len;
+					unsigned char index_inc = 0;
+					unsigned char vsd_end;
+
+					vsd_end = index + blklen;
+
+					IEEE_reg_iden[0] = edid[index+1];
+					IEEE_reg_iden[1] = edid[index+2];
+					IEEE_reg_iden[2] = edid[index+3];
+					cfg->physical_address[0] = (edid[index+4] & 0xf0) >> 4;
+					cfg->physical_address[1] = (edid[index+4] & 0x0f);
+					cfg->physical_address[2] = (edid[index+5] & 0xf0) >> 4;
+					cfg->physical_address[3] = (edid[index+5] & 0x0f);
+
+					if ((IEEE_reg_iden[0] == 0x03) &&
+							(IEEE_reg_iden[1] == 0x0c) &&
+							(IEEE_reg_iden[2] == 0x00))
+						cfg->hdmi_cap = 1;
+
+					if (blklen > 5) {
+						deep_color = edid[index+6];
+						if (deep_color & 0x80)
+							cfg->vsd_support_ai = true;
+						if (deep_color & 0x40)
+							cfg->vsd_dc_48bit = true;
+						if (deep_color & 0x20)
+							cfg->vsd_dc_36bit = true;
+						if (deep_color & 0x10)
+							cfg->vsd_dc_30bit = true;
+						if (deep_color & 0x08)
+							cfg->vsd_dc_y444 = true;
+						if (deep_color & 0x01)
+							cfg->vsd_dvi_dual = true;
+					}
+
+					DPRINTK("VSD hdmi capability %d\n", cfg->hdmi_cap);
+					DPRINTK("VSD support ai %d\n", cfg->vsd_support_ai);
+					DPRINTK("VSD support deep color 48bit %d\n", cfg->vsd_dc_48bit);
+					DPRINTK("VSD support deep color 36bit %d\n", cfg->vsd_dc_36bit);
+					DPRINTK("VSD support deep color 30bit %d\n", cfg->vsd_dc_30bit);
+					DPRINTK("VSD support deep color y444 %d\n", cfg->vsd_dc_y444);
+					DPRINTK("VSD support dvi dual %d\n", cfg->vsd_dvi_dual);
+
+					if (blklen > 6)
+						cfg->vsd_max_tmdsclk_rate = edid[index+7] * 5;
+					DPRINTK("VSD MAX TMDS CLOCK RATE %d\n", cfg->vsd_max_tmdsclk_rate);
+
+					if (blklen > 7) {
+						latency_present = edid[index+8] >> 7;
+						I_latency_present =  (edid[index+8] & 0x40) >> 6;
+						hdmi_video_present = (edid[index+8] & 0x20) >> 5;
+						cfg->vsd_cnc3 = (edid[index+8] & 0x8) >> 3;
+						cfg->vsd_cnc2 = (edid[index+8] & 0x4) >> 2;
+						cfg->vsd_cnc1 = (edid[index+8] & 0x2) >> 1;
+						cfg->vsd_cnc0 = edid[index+8] & 0x1;
+
+						DPRINTK("VSD cnc0 %d\n", cfg->vsd_cnc0);
+						DPRINTK("VSD cnc1 %d\n", cfg->vsd_cnc1);
+						DPRINTK("VSD cnc2 %d\n", cfg->vsd_cnc2);
+						DPRINTK("VSD cnc3 %d\n", cfg->vsd_cnc3);
+						DPRINTK("latency_present %d\n", latency_present);
+						DPRINTK("I_latency_present %d\n", I_latency_present);
+						DPRINTK("hdmi_video_present %d\n", hdmi_video_present);
+
+					} else {
+						index += blklen;
+						break;
+					}
+
+					index += 9;
+
+					/*latency present */
+					if (latency_present) {
+						cfg->vsd_video_latency = edid[index++];
+						cfg->vsd_audio_latency = edid[index++];
+
+						if (I_latency_present) {
+							cfg->vsd_I_video_latency = edid[index++];
+							cfg->vsd_I_audio_latency = edid[index++];
+						} else {
+							cfg->vsd_I_video_latency = cfg->vsd_video_latency;
+							cfg->vsd_I_audio_latency = cfg->vsd_audio_latency;
+						}
+
+						DPRINTK("VSD latency video_latency  %d\n", cfg->vsd_video_latency);
+						DPRINTK("VSD latency audio_latency  %d\n", cfg->vsd_audio_latency);
+						DPRINTK("VSD latency I_video_latency  %d\n", cfg->vsd_I_video_latency);
+						DPRINTK("VSD latency I_audio_latency  %d\n", cfg->vsd_I_audio_latency);
+					}
+
+					if (hdmi_video_present) {
+						hdmi_3d_present = edid[index] >> 7;
+						hdmi_3d_multi_present = (edid[index] & 0x60) >> 5;
+						index++;
+						hdmi_vic_len = (edid[index] & 0xe0) >> 5;
+						hdmi_3d_len = edid[index] & 0x1f;
+						index++;
+
+						DPRINTK("hdmi_3d_present %d\n", hdmi_3d_present);
+						DPRINTK("hdmi_3d_multi_present %d\n", hdmi_3d_multi_present);
+						DPRINTK("hdmi_vic_len %d\n", hdmi_vic_len);
+						DPRINTK("hdmi_3d_len %d\n", hdmi_3d_len);
+
+						if (hdmi_vic_len > 0) {
+							for (i = 0; i < hdmi_vic_len; i++) {
+								cfg->hdmi_vic[i] = edid[index++];
+								DPRINTK("HDMI_vic=%d\n", cfg->hdmi_vic[i]);
+							}
+						}
+
+						if (hdmi_3d_len > 0) {
+							if (hdmi_3d_present) {
+								if (hdmi_3d_multi_present == 0x1) {
+									cfg->hdmi_3d_struct_all = (edid[index] << 8) | edid[index+1];
+									index_inc = 2;
+								} else if (hdmi_3d_multi_present == 0x2) {
+									cfg->hdmi_3d_struct_all = (edid[index] << 8) | edid[index+1];
+									cfg->hdmi_3d_mask_all = (edid[index+2] << 8) | edid[index+3];
+									index_inc = 4;
+								} else
+									index_inc = 0;
+							}
+
+							DPRINTK("HDMI 3d struct all =0x%x\n", cfg->hdmi_3d_struct_all);
+							DPRINTK("HDMI 3d mask all =0x%x\n", cfg->hdmi_3d_mask_all);
+
+							/* Read 2D vic 3D_struct */
+							if ((hdmi_3d_len - index_inc) > 0) {
+								DPRINTK("Support 3D video format\n");
+								i = 0;
+								while ((hdmi_3d_len - index_inc) > 0) {
+
+									cfg->hdmi_3d_format[i].vic_order_2d = edid[index+index_inc] >> 4;
+									cfg->hdmi_3d_format[i].struct_3d = edid[index+index_inc] & 0x0f;
+									index_inc++;
+
+									if (cfg->hdmi_3d_format[i].struct_3d ==  8) {
+										cfg->hdmi_3d_format[i].detail_3d = edid[index+index_inc] >> 4;
+										index_inc++;
+									} else if (cfg->hdmi_3d_format[i].struct_3d > 8) {
+										cfg->hdmi_3d_format[i].detail_3d = 0;
+										index_inc++;
+									}
+
+									DPRINTK("vic_order_2d=%d, 3d_struct=%d, 3d_detail=0x%x\n",
+											cfg->hdmi_3d_format[i].vic_order_2d,
+											cfg->hdmi_3d_format[i].struct_3d,
+											cfg->hdmi_3d_format[i].detail_3d);
+									i++;
+								}
+							}
+							index += index_inc;
+						}
+					}
+
+					index = vsd_end;
+
+					break;
+				}
+			case 0x1: /*Audio data block*/
+				{
+					u8 audio_format, max_ch, byte1, byte2, byte3;
+
+					i = 0;
+					cfg->max_channels = 0;
+					cfg->sample_rates = 0;
+					cfg->sample_sizes = 0;
+
+					while (i < blklen) {
+						byte1 = edid[index + 1];
+						byte2 = edid[index + 2];
+						byte3 = edid[index + 3];
+						index += 3;
+						i += 3;
+
+						audio_format = byte1 >> 3;
+						max_ch = (byte1 & 0x07) + 1;
+
+						DPRINTK("Audio Format Descriptor : %2d\n", audio_format);
+						DPRINTK("Max Number of Channels  : %2d\n", max_ch);
+						DPRINTK("Sample Rates            : %02x\n", byte2);
+
+						/* ALSA can't specify specific compressed
+						 * formats, so only care about PCM for now. */
+						if (audio_format == AUDIO_CODING_TYPE_LPCM) {
+							if (max_ch > cfg->max_channels)
+								cfg->max_channels = max_ch;
+
+							cfg->sample_rates |= byte2;
+							cfg->sample_sizes |= byte3 & 0x7;
+							DPRINTK("Sample Sizes            : %02x\n",
+								byte3 & 0x7);
+						}
+					}
+					break;
+				}
+			case 0x4: /*Speaker allocation block*/
+				{
+					i = 0;
+					while (i < blklen) {
+						cfg->speaker_alloc = edid[index + 1];
+						index += 3;
+						i += 3;
+						DPRINTK("Speaker Alloc           : %02x\n", cfg->speaker_alloc);
+					}
+					break;
+				}
+			case 0x7: /*User extended block*/
+			default:
+				/* skip */
+				DPRINTK("Not handle block, tagcode = 0x%x\n", tagcode);
+				index += blklen;
+				break;
+			}
+
+			index++;
+		}
+	}
+
+	/* long desc */
+	DPRINTK("CEA long desc timmings\n");
+	index = detail_timing_desc_offset;
+	block = edid + index;
+	while (index < (EDID_LENGTH - DETAILED_TIMING_DESCRIPTION_SIZE)) {
+		if (!(block[0] == 0x00 && block[1] == 0x00)) {
+			get_detailed_timing(block, &mode[num]);
+			num++;
+		}
+		block += DETAILED_TIMING_DESCRIPTION_SIZE;
+		index += DETAILED_TIMING_DESCRIPTION_SIZE;
+	}
+
+	if (!num) {
+		kfree(mode);
+		return 0;
+	}
+
+	m = kmalloc((num + specs->modedb_len) *
+			sizeof(struct fb_videomode), GFP_KERNEL);
+	if (!m)
+		return 0;
+
+	if (specs->modedb_len) {
+		memmove(m, specs->modedb,
+			specs->modedb_len * sizeof(struct fb_videomode));
+		kfree(specs->modedb);
+	}
+	memmove(m+specs->modedb_len, mode,
+		num * sizeof(struct fb_videomode));
+	kfree(mode);
+
+	specs->modedb_len += num;
+	specs->modedb = m;
+
+	return 0;
+}
+EXPORT_SYMBOL(myir_edid_parse_ext_blk);
+
+static int myir_edid_readblk(struct i2c_adapter *adp,
+		unsigned short addr, unsigned char *edid)
+{
+	int ret = 0, extblknum = 0;
+	unsigned char regaddr = 0x0;
+	struct i2c_msg msg[2] = {
+		{
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block, ret=%d(expected:%d)\n", ret, ARRAY_SIZE(msg));
+		return -EIO;
+	}
+
+	if (edid[1] == 0x00)
+		return -ENOENT;
+
+	extblknum = edid[0x7E];
+	
+	if (extblknum) {
+		regaddr = 128;
+		msg[1].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID ext block, ret=%d(expected:%d)\n", ret, ARRAY_SIZE(msg));
+			return -EIO;
+		}
+	}
+
+	return extblknum;
+}
+
+static int myir_edid_readsegblk(struct i2c_adapter *adp, unsigned short addr,
+			unsigned char *edid, int seg_num)
+{
+	int ret = 0;
+	unsigned char segment = 0x1, regaddr = 0;
+	struct i2c_msg msg[3] = {
+		{
+		.addr	= 0x30,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &segment,
+		}, {
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block\n");
+		return -EIO;
+	}
+
+	if (seg_num == 2) {
+		regaddr = 128;
+		msg[2].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID block\n");
+			return -EIO;
+		}
+	}
+
+	return ret;
+}
+
+int myir_edid_var_to_vic(struct fb_var_screeninfo *var)
+{
+	int i;
+	struct fb_videomode m;
+
+	for (i = 0; i < ARRAY_SIZE(myir_cea_mode); i++) {
+		fb_var_to_videomode(&m, var);
+		if (myir_edid_fb_mode_is_equal(false, &m, &myir_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(myir_cea_mode))
+		return 0;
+
+	return i;
+}
+EXPORT_SYMBOL(myir_edid_var_to_vic);
+
+int myir_edid_mode_to_vic(const struct fb_videomode *mode)
+{
+	int i;
+	bool use_aspect = (mode->vmode & FB_VMODE_ASPECT_MASK);
+
+	for (i = 0; i < ARRAY_SIZE(myir_cea_mode); i++) {
+		if (myir_edid_fb_mode_is_equal(use_aspect, mode, &myir_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(myir_cea_mode))
+		return 0;
+
+	return i;
+}
+EXPORT_SYMBOL(myir_edid_mode_to_vic);
+
+/* make sure edid has 512 bytes*/
+int myir_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct myir_edid_cfg *cfg, struct fb_info *fbi)
+{
+	int ret = 0, extblknum;
+
+	if (!adp || !edid || !cfg || !fbi)
+		return -EINVAL;
+
+	memset(edid, 0, EDID_LENGTH*4);
+	memset(cfg, 0, sizeof(struct myir_edid_cfg));
+
+	extblknum = myir_edid_readblk(adp, addr, edid);
+
+	printk(KERN_ERR"extblknum1: %d\n", extblknum);
+	printk(KERN_ERR"extblknum2: %d\n", extblknum);
+	printk(KERN_ERR"extblknum3: %d\n", extblknum);
+	
+	if (extblknum < 0)
+		return extblknum;
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	if (extblknum) {
+		int i;
+
+		/* need read segment block? */
+		if (extblknum > 1) {
+			ret = myir_edid_readsegblk(adp, addr,
+				edid + EDID_LENGTH*2, extblknum - 1);
+			if (ret < 0) {
+				return ret;
+			}
+		}
+
+		for (i = 1; i <= extblknum; i++)
+			/* edid ext block parsing */
+			myir_edid_parse_ext_blk(edid + i*EDID_LENGTH,
+					cfg, &fbi->monspecs);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(myir_edid_read);
--- /dev/null
+++ b/drivers/video/sii902x/myir_edid.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file myir_edid.h
+ *
+ * @brief MYIR EDID tools
+ *
+ * @ingroup Framebuffer
+ */
+
+#ifndef MYIR_EDID_H
+#define MYIR_EDID_H
+
+#include <linux/fb.h>
+
+#define FB_VMODE_ASPECT_4_3	0x10
+#define FB_VMODE_ASPECT_16_9	0x20
+#define FB_VMODE_ASPECT_MASK	(FB_VMODE_ASPECT_4_3 | FB_VMODE_ASPECT_16_9)
+
+enum cea_audio_coding_types {
+	AUDIO_CODING_TYPE_REF_STREAM_HEADER	=  0,
+	AUDIO_CODING_TYPE_LPCM			=  1,
+	AUDIO_CODING_TYPE_AC3			=  2,
+	AUDIO_CODING_TYPE_MPEG1			=  3,
+	AUDIO_CODING_TYPE_MP3			=  4,
+	AUDIO_CODING_TYPE_MPEG2			=  5,
+	AUDIO_CODING_TYPE_AACLC			=  6,
+	AUDIO_CODING_TYPE_DTS			=  7,
+	AUDIO_CODING_TYPE_ATRAC			=  8,
+	AUDIO_CODING_TYPE_SACD			=  9,
+	AUDIO_CODING_TYPE_EAC3			= 10,
+	AUDIO_CODING_TYPE_DTS_HD		= 11,
+	AUDIO_CODING_TYPE_MLP			= 12,
+	AUDIO_CODING_TYPE_DST			= 13,
+	AUDIO_CODING_TYPE_WMAPRO		= 14,
+	AUDIO_CODING_TYPE_RESERVED		= 15,
+};
+
+struct myir_hdmi_3d_format {
+	unsigned char vic_order_2d;
+	unsigned char struct_3d;
+	unsigned char detail_3d;
+	unsigned char reserved;
+};
+
+struct myir_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+
+	/*VSD*/
+	bool vsd_support_ai;
+	bool vsd_dc_48bit;
+	bool vsd_dc_36bit;
+	bool vsd_dc_30bit;
+	bool vsd_dc_y444;
+	bool vsd_dvi_dual;
+
+	bool vsd_cnc0;
+	bool vsd_cnc1;
+	bool vsd_cnc2;
+	bool vsd_cnc3;
+
+	u8 vsd_video_latency;
+	u8 vsd_audio_latency;
+	u8 vsd_I_video_latency;
+	u8 vsd_I_audio_latency;
+
+	u8 physical_address[4];
+	u8 hdmi_vic[64];
+	struct myir_hdmi_3d_format hdmi_3d_format[64];
+	u16 hdmi_3d_mask_all;
+	u16 hdmi_3d_struct_all;
+	u32 vsd_max_tmdsclk_rate;
+
+	u8 max_channels;
+	u8 sample_sizes;
+	u8 sample_rates;
+	u8 speaker_alloc;
+};
+
+int myir_edid_var_to_vic(struct fb_var_screeninfo *var);
+int myir_edid_mode_to_vic(const struct fb_videomode *mode);
+int myir_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct myir_edid_cfg *cfg, struct fb_info *fbi);
+int myir_edid_parse_ext_blk(unsigned char *edid, struct myir_edid_cfg *cfg,
+	struct fb_monspecs *specs);
+#endif
--- /dev/null
+++ b/drivers/video/sii902x/myir_sii902x.c
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for Sii902x.
+ */
+
+/*!
+ * @file myir_sii902x.c
+ *
+ * @brief  Frame buffer driver for SII902X
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#define DEBUG	1
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/fsl_devices.h>
+#include <linux/interrupt.h>
+#include <linux/reset.h>
+#include <asm/mach-types.h>
+#include "myir_edid.h"
+
+#define SII_EDID_LEN	512
+#define DRV_NAME 		"sii902x"
+#define DET_RETRY_CNT	2
+
+struct sii902x_data {
+	struct i2c_client *client;
+	struct delayed_work det_work;
+	struct fb_info *fbi;
+	struct myir_edid_cfg edid_cfg;
+	u8 cable_plugin;
+	u8 edid[SII_EDID_LEN];
+	bool waiting_for_fb;
+	bool dft_mode_set;
+	const char *mode_str;
+	int bits_per_pixel;
+	int retries;
+} sii902x;
+
+static void sii902x_poweron(void);
+static void sii902x_poweroff(void);
+
+#if defined(DEBUG) && defined(CONFIG_SII902X_EDID_READING)
+static void dump_fb_videomode(struct fb_videomode *m)
+{
+	pr_debug("fb_videomode = %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
+		m->refresh, m->xres, m->yres, m->pixclock, m->left_margin,
+		m->right_margin, m->upper_margin, m->lower_margin,
+		m->hsync_len, m->vsync_len, m->sync, m->vmode, m->flag);
+}
+#endif
+
+static __attribute__ ((unused)) void dump_regs(u8 reg, int len)
+{
+	u8 buf[50];
+	int i;
+
+	i2c_smbus_read_i2c_block_data(sii902x.client, reg, len, buf);
+	for (i = 0; i < len; i++)
+		dev_dbg(&sii902x.client->dev, "reg[0x%02X]: 0x%02X\n",
+				i+reg, buf[i]);
+}
+
+static ssize_t sii902x_show_name(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	strcpy(buf, sii902x.fbi->fix.id);
+	sprintf(buf+strlen(buf), "\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(fb_name, S_IRUGO, sii902x_show_name, NULL);
+
+static ssize_t sii902x_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (sii902x.cable_plugin == 0)
+		strcpy(buf, "plugout\n");
+	else
+		strcpy(buf, "plugin\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(cable_state, S_IRUGO, sii902x_show_state, NULL);
+
+static ssize_t sii902x_show_edid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int len = 0;
+#ifdef CONFIG_SII902X_EDID_READING
+	int i, j;
+	for (j = 0; j < SII_EDID_LEN/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					sii902x.edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
+#else
+	len = sprintf(buf, "EDID reading is not supported.\n");
+#endif
+	return len;
+}
+
+static DEVICE_ATTR(edid, S_IRUGO, sii902x_show_edid, NULL);
+
+static void sii902x_setup(struct fb_info *fbi)
+{
+	u16 data[4];
+	u32 refresh;
+	u8 *tmp;
+	int i;
+
+	dev_dbg(&sii902x.client->dev, "Sii902x: setup..\n");
+
+	/* Power up */
+	i2c_smbus_write_byte_data(sii902x.client, 0x1E, 0x00);
+
+	/* set TPI video mode */
+	data[0] = PICOS2KHZ(fbi->var.pixclock) / 10;
+	data[2] = fbi->var.hsync_len + fbi->var.left_margin +
+		  fbi->var.xres + fbi->var.right_margin;
+	data[3] = fbi->var.vsync_len + fbi->var.upper_margin +
+		  fbi->var.yres + fbi->var.lower_margin;
+	refresh = data[2] * data[3];
+	refresh = (PICOS2KHZ(fbi->var.pixclock) * 1000) / refresh;
+	data[1] = refresh * 100;
+	tmp = (u8 *)data;
+	for (i = 0; i < 8; i++)
+		i2c_smbus_write_byte_data(sii902x.client, i, tmp[i]);
+
+	/* input bus/pixel: full pixel wide (24bit), rising edge */
+	i2c_smbus_write_byte_data(sii902x.client, 0x08, 0x70);
+	/* Set input format to RGB */
+	i2c_smbus_write_byte_data(sii902x.client, 0x09, 0x00);
+	/* set output format to RGB */
+	i2c_smbus_write_byte_data(sii902x.client, 0x0A, 0x00);
+	/* audio setup */
+	i2c_smbus_write_byte_data(sii902x.client, 0x25, 0x00);
+	i2c_smbus_write_byte_data(sii902x.client, 0x26, 0x40);
+	i2c_smbus_write_byte_data(sii902x.client, 0x27, 0x00);
+}
+
+#ifdef CONFIG_SII902X_EDID_READING
+static int sii902x_read_edid(struct fb_info *fbi)
+{
+	int old, dat, ret, cnt = 100;
+	unsigned short addr = 0x50;
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);
+
+	old = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old | 0x4);
+	do {
+		cnt--;
+		msleep(10);
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+	} while ((!(dat & 0x2)) && cnt);
+
+	if (!cnt) {
+		ret = -1;
+		goto done;
+	}
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old | 0x06);
+
+	/* edid reading */
+	ret = myir_edid_read(sii902x.client->adapter, addr,
+				sii902x.edid, &sii902x.edid_cfg, fbi);
+
+	printk(KERN_ERR"myir_edid_read: ret=%d", ret);
+
+	cnt = 100;
+	do {
+		cnt--;
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, old & ~0x6);
+		msleep(10);
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+	} while ((dat & 0x6) && cnt);
+
+	if (!cnt) {
+		ret = -1;
+	}
+
+done:
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old);
+	return ret;
+}
+
+static int sii902x_cable_connected(void)
+{
+	int i;
+	const struct fb_videomode *mode;
+	struct fb_videomode m;
+	int ret;
+
+	ret = sii902x_read_edid(sii902x.fbi);
+	if (ret < 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: read edid fail\n");
+		/* Power on sii902x */
+		sii902x_poweron();
+	} else {
+		if (sii902x.fbi->monspecs.modedb_len > 0) {
+
+			fb_destroy_modelist(&sii902x.fbi->modelist);
+
+			for (i = 0; i < sii902x.fbi->monspecs.modedb_len; i++) {
+
+				mode = &sii902x.fbi->monspecs.modedb[i];
+
+				if (!(mode->vmode & FB_VMODE_INTERLACED)) {
+
+					dev_dbg(&sii902x.client->dev, "Added mode %d:", i);
+					dev_dbg(&sii902x.client->dev,
+						"xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+						mode->xres, mode->yres, mode->refresh,
+						mode->vmode, mode->flag);
+
+					fb_add_videomode(mode, &sii902x.fbi->modelist);
+				}
+			}
+
+			/* Set the default mode only once. */
+			if (!sii902x.dft_mode_set &&
+					sii902x.mode_str && sii902x.bits_per_pixel) {
+
+				dev_dbg(&sii902x.client->dev, "%s: setting to default=%s bpp=%d\n",
+						__func__, sii902x.mode_str, sii902x.bits_per_pixel);
+
+				fb_find_mode(&sii902x.fbi->var, sii902x.fbi,
+						sii902x.mode_str, NULL, 0, NULL,
+						sii902x.bits_per_pixel);
+
+				sii902x.dft_mode_set = true;
+			}
+
+			fb_var_to_videomode(&m, &sii902x.fbi->var);
+			dump_fb_videomode(&m);
+
+			mode = fb_find_nearest_mode(&m,
+					&sii902x.fbi->modelist);
+
+			/* update fbi mode  */
+			sii902x.fbi->mode = (struct fb_videomode *)mode;
+
+			fb_videomode_to_var(&sii902x.fbi->var, mode);
+
+			sii902x.fbi->var.activate |= FB_ACTIVATE_FORCE;
+			console_lock();
+			sii902x.fbi->flags |= FBINFO_MISC_USEREVENT;
+			fb_set_var(sii902x.fbi, &sii902x.fbi->var);
+			sii902x.fbi->flags &= ~FBINFO_MISC_USEREVENT;
+			console_unlock();
+		}
+		/* Power on sii902x */
+		sii902x_poweron();
+	}
+	return ret;
+}
+#else
+static int sii902x_cable_connected(void)
+{
+	/* Power on sii902x */
+	sii902x_poweron();
+	
+	return 0;
+}
+#endif /* CONFIG_SII902X_EDID_READING */
+
+static void det_worker(struct work_struct *work)
+{
+	int dat;
+	char event_string[16];
+	char *envp[] = { event_string, NULL };
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);
+
+	dat = i2c_smbus_read_byte_data(sii902x.client, 0x3D);
+
+	printk(KERN_ERR"status: %#X, sii902x.retries: %d\n", dat, sii902x.retries);
+//	if ((dat & 0x1) || sii902x.retries > 0) {
+	if (dat >= 0) {
+		/* cable connection changes */
+		if (dat & 0x4) {
+			sii902x.cable_plugin = 1;
+			dev_dbg(&sii902x.client->dev, "EVENT=plugin\n");
+			sprintf(event_string, "EVENT=plugin");
+			if (sii902x_cable_connected() < 0 && sii902x.retries > 0) {
+				sii902x.retries --;
+				schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(500));
+			} else {
+				sii902x.retries = 0;
+			}
+		} else {
+			sii902x.retries = 0;
+			sii902x.cable_plugin = 0;
+			dev_dbg(&sii902x.client->dev, "EVENT=plugout\n");
+			sprintf(event_string, "EVENT=plugout");
+			/* Power off sii902x */
+			sii902x_poweroff();
+		}
+		kobject_uevent_env(&sii902x.client->dev.kobj, KOBJ_CHANGE, envp);
+	} else {
+		dev_err(&sii902x.client->dev, "i2c bus error!!!\n");
+		sii902x.retries = 0;
+	}
+	i2c_smbus_write_byte_data(sii902x.client, 0x3D, dat);
+
+	dev_dbg(&sii902x.client->dev, "exit %s\n", __func__);
+}
+
+static irqreturn_t sii902x_detect_handler(int irq, void *data)
+{
+	if (sii902x.fbi) {
+		if (sii902x.retries == 0) {/* no need to schedule workqueue if retries > 0 */
+			sii902x.retries = DET_RETRY_CNT;
+			schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(100/*20*/));
+		}
+	} else {
+		sii902x.waiting_for_fb = true;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sii902x_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+	struct fb_info *fbi = event->info;
+	
+	dev_dbg(&sii902x.client->dev, "%s event=0x%lx, \n", __func__, val);
+		
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+	if (sii902x.fbi == NULL) {
+			sii902x.fbi = fbi;
+			if (sii902x.waiting_for_fb) {
+				sii902x.retries = DET_RETRY_CNT;
+				sii902x.waiting_for_fb = false;
+				sii902x_setup(fbi);
+				schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(20));
+			}
+		}
+		fb_show_logo(fbi, 0);
+		break;
+	case FB_EVENT_MODE_CHANGE:
+		printk(KERN_DEBUG"%s event=[%s]\n", __func__, "FB_EVENT_MODE_CHANGE");
+		sii902x_setup(fbi);
+		break;
+	case FB_EVENT_BLANK:
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			dev_dbg(&sii902x.client->dev, "FB_BLANK_UNBLANK\n");
+			sii902x_poweron();
+		} else {
+			dev_dbg(&sii902x.client->dev, "FB_BLANK_BLANK\n");
+			sii902x_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = sii902x_fb_event,
+};
+
+static int myir_get_of_property(void)
+{
+	struct device_node *np = sii902x.client->dev.of_node;
+	const char *mode_str;
+	int bits_per_pixel, ret;
+
+	ret = of_property_read_string(np, "mode_str", &mode_str);
+	if (ret < 0) {
+		dev_warn(&sii902x.client->dev, "get of property mode_str fail\n");
+		return ret;
+	}
+	ret = of_property_read_u32(np, "bits-per-pixel", &bits_per_pixel);
+	if (ret) {
+		dev_warn(&sii902x.client->dev, "get of property bpp fail\n");
+		return ret;
+	}
+
+	sii902x.mode_str = mode_str;
+	sii902x.bits_per_pixel = bits_per_pixel;
+
+	return ret;
+}
+
+static int sii902x_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int i, dat, ret;
+#ifdef CONFIG_SII902X_EDID_READING
+	struct fb_info edid_fbi;
+#endif
+	memset(&sii902x, 0, sizeof(sii902x));
+
+	sii902x.client = client;
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);;
+
+	/* Recommend to reset sii902x here, not yet implemented */
+	
+	/* Set 902x in hardware TPI mode on and jump out of D3 state */
+	if (i2c_smbus_write_byte_data(sii902x.client, 0xc7, 0x00) < 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: cound not find device\n");
+		return -ENODEV;
+	}
+
+	/* read device ID */
+	for (i = 10; i > 0; i--) {
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1B);
+		printk(KERN_DEBUG "Sii902x: read id = 0x%02X", dat);
+		if (dat == 0xb0) {
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x1C);
+			printk(KERN_DEBUG "-0x%02X", dat);
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x1D);
+			printk(KERN_DEBUG "-0x%02X", dat);
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x30);
+			printk(KERN_DEBUG "-0x%02X\n", dat);
+			break;
+		}
+	}
+	if (i == 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: cound not find device\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_SII902X_EDID_READING
+	/* try to read edid */
+	ret = sii902x_read_edid(&edid_fbi);
+	if (ret < 0)
+		dev_warn(&sii902x.client->dev, "Can not read edid\n");
+#else
+	sii902x.edid_cfg.hdmi_cap = 1;
+#endif
+		
+	if (sii902x.client->irq) {
+		ret = request_irq(sii902x.client->irq, sii902x_detect_handler,
+				/*IRQF_TRIGGER_FALLING*/IRQF_TRIGGER_RISING,
+				"SII902x_det", &sii902x);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not request det irq %d\n",
+				sii902x.client->irq);
+		else {
+			/*enable cable hot plug irq*/
+			i2c_smbus_write_byte_data(sii902x.client, 0x3c, 0x01);
+			INIT_DELAYED_WORK(&(sii902x.det_work), det_worker);
+		}
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_fb_name);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for fb name\n");
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_cable_state);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for cable state\n");
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_edid);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for edid\n");
+
+	}
+
+	myir_get_of_property();
+	sii902x.waiting_for_fb = true;
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int sii902x_remove(struct i2c_client *client)
+{
+	fb_unregister_client(&nb);
+	sii902x_poweroff();
+	
+	device_remove_file(&client->dev, &dev_attr_fb_name);
+	device_remove_file(&client->dev, &dev_attr_cable_state);
+	device_remove_file(&client->dev, &dev_attr_edid);
+	
+	return 0;
+}
+
+static void sii902x_poweron(void)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	/* Turn on DVI or HDMI */
+	if (sii902x.edid_cfg.hdmi_cap)
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x01);
+	else
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x00);
+	return;
+}
+
+static void sii902x_poweroff(void)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	/* disable tmds before changing resolution */
+	if (sii902x.edid_cfg.hdmi_cap)
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x11);
+	else
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x10);
+
+	return;
+}
+
+static const struct i2c_device_id sii902x_id[] = {
+	{ DRV_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, sii902x_id);
+
+static const struct of_device_id sii902x_dt_ids[] = {
+	{ .compatible = DRV_NAME, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sii902x_dt_ids);
+
+static struct i2c_driver sii902x_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sii902x_dt_ids,
+	},
+	.probe		= sii902x_probe,
+	.remove		= sii902x_remove,
+	.id_table	= sii902x_id,
+};
+
+module_i2c_driver(sii902x_driver);
+
+MODULE_AUTHOR("MYIR Tech, Inc.");
+MODULE_DESCRIPTION("SII902x DVI/HDMI driver");
+MODULE_LICENSE("GPL");
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -30,6 +30,9 @@
 
 source "drivers/video/backlight/Kconfig"
 
+# Added by MYIR
+source "drivers/video/sii902x/Kconfig"
+
 config VGASTATE
        tristate
        default n
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -7,6 +7,8 @@
 
 obj-y				  += fbdev/
 
+obj-$(CONFIG_MYIR_SII902X)	  += sii902x/
+
 obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
 ifeq ($(CONFIG_OF),y)
 obj-$(CONFIG_VIDEOMODE_HELPERS) += of_display_timing.o of_videomode.o
