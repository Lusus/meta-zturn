--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -795,7 +795,8 @@
 	zynq-zc770-xm012.dtb \
 	zynq-zc770-xm013.dtb \
 	zynq-zed.dtb \
-	zynq-zybo.dtb
+	zynq-zybo.dtb \
+	zynq-zturn.dtb
 dtb-$(CONFIG_MACH_ARMADA_370) += \
 	armada-370-db.dtb \
 	armada-370-dlink-dns327l.dtb \
--- /dev/null
+++ b/arch/arm/boot/dts/zynq-7000-org.dtsi
@@ -0,0 +1,402 @@
+/*
+ *  Copyright (C) 2011 - 2014 Xilinx
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/include/ "skeleton.dtsi"
+
+/ {
+	compatible = "xlnx,zynq-7000";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu@0 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <0>;
+			clocks = <&clkc 3>;
+			clock-latency = <1000>;
+			cpu0-supply = <&regulator_vccpint>;
+			operating-points = <
+				/* kHz    uV */
+				666667  1000000
+				333334  1000000
+			>;
+		};
+
+		cpu@1 {
+			compatible = "arm,cortex-a9";
+			device_type = "cpu";
+			reg = <1>;
+			clocks = <&clkc 3>;
+		};
+	};
+
+	pmu {
+		compatible = "arm,cortex-a9-pmu";
+		interrupts = <0 5 4>, <0 6 4>;
+		interrupt-parent = <&intc>;
+		reg = < 0xf8891000 0x1000 0xf8893000 0x1000 >;
+	};
+
+	regulator_vccpint: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCCPINT";
+		regulator-min-microvolt = <1000000>;
+		regulator-max-microvolt = <1000000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	amba {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		interrupt-parent = <&intc>;
+		ranges;
+
+		adc@f8007100 {
+			compatible = "xlnx,zynq-xadc-1.00.a";
+			reg = <0xf8007100 0x20>;
+			interrupts = <0 7 4>;
+			interrupt-parent = <&intc>;
+			clocks = <&clkc 12>;
+		};
+
+		can0: can@e0008000 {
+			compatible = "xlnx,zynq-can-1.0";
+			status = "disabled";
+			clocks = <&clkc 19>, <&clkc 36>;
+			clock-names = "can_clk", "pclk";
+			reg = <0xe0008000 0x1000>;
+			interrupts = <0 28 4>;
+			interrupt-parent = <&intc>;
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		can1: can@e0009000 {
+			compatible = "xlnx,zynq-can-1.0";
+			status = "disabled";
+			clocks = <&clkc 20>, <&clkc 37>;
+			clock-names = "can_clk", "pclk";
+			reg = <0xe0009000 0x1000>;
+			interrupts = <0 51 4>;
+			interrupt-parent = <&intc>;
+			tx-fifo-depth = <0x40>;
+			rx-fifo-depth = <0x40>;
+		};
+
+		gpio0: gpio@e000a000 {
+			compatible = "xlnx,zynq-gpio-1.0";
+			#gpio-cells = <2>;
+			clocks = <&clkc 42>;
+			gpio-controller;
+			interrupt-parent = <&intc>;
+			interrupts = <0 20 4>;
+			reg = <0xe000a000 0x1000>;
+		};
+
+		i2c0: i2c@e0004000 {
+			compatible = "cdns,i2c-r1p10";
+			status = "disabled";
+			clocks = <&clkc 38>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 25 4>;
+			reg = <0xe0004000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@e0005000 {
+			compatible = "cdns,i2c-r1p10";
+			status = "disabled";
+			clocks = <&clkc 39>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 48 4>;
+			reg = <0xe0005000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		intc: interrupt-controller@f8f01000 {
+			compatible = "arm,cortex-a9-gic";
+			#interrupt-cells = <3>;
+			interrupt-controller;
+			reg = <0xF8F01000 0x1000>,
+			      <0xF8F00100 0x100>;
+		};
+
+		L2: cache-controller {
+			compatible = "arm,pl310-cache";
+			reg = <0xF8F02000 0x1000>;
+			arm,data-latency = <3 2 2>;
+			arm,tag-latency = <2 2 2>;
+			cache-unified;
+			cache-level = <2>;
+		};
+
+		memory-controller@f8006000 {
+			compatible = "xlnx,zynq-ddrc-1.0";
+			reg = <0xf8006000 0x1000>;
+			xlnx,has-ecc = <0x0>;
+		};
+
+		ocmc: ocmc@f800c000 {
+			compatible = "xlnx,zynq-ocmc-1.0";
+			interrupt-parent = <&intc>;
+			interrupts = <0 3 4>;
+			reg = <0xf800c000 0x1000>;
+		};
+
+		uart0: serial@e0000000 {
+			compatible = "xlnx,xuartps";
+			status = "disabled";
+			clocks = <&clkc 23>, <&clkc 40>;
+			clock-names = "uart_clk", "pclk";
+			reg = <0xE0000000 0x1000>;
+			interrupts = <0 27 4>;
+		};
+
+		uart1: serial@e0001000 {
+			compatible = "xlnx,xuartps";
+			status = "disabled";
+			clocks = <&clkc 24>, <&clkc 41>;
+			clock-names = "uart_clk", "pclk";
+			reg = <0xE0001000 0x1000>;
+			interrupts = <0 50 4>;
+		};
+
+		spi0: spi@e0006000 {
+			compatible = "xlnx,zynq-spi-r1p6";
+			reg = <0xe0006000 0x1000>;
+			status = "disabled";
+			interrupt-parent = <&intc>;
+			interrupts = <0 26 4>;
+			clocks = <&clkc 25>, <&clkc 34>;
+			clock-names = "ref_clk", "pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi1: spi@e0007000 {
+			compatible = "xlnx,zynq-spi-r1p6";
+			reg = <0xe0007000 0x1000>;
+			status = "disabled";
+			interrupt-parent = <&intc>;
+			interrupts = <0 49 4>;
+			clocks = <&clkc 26>, <&clkc 35>;
+			clock-names = "ref_clk", "pclk";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		qspi: spi@e000d000 {
+			clock-names = "ref_clk", "pclk";
+			clocks = <&clkc 10>, <&clkc 43>;
+			compatible = "xlnx,zynq-qspi-1.0";
+			status = "disabled";
+			interrupt-parent = <&intc>;
+			interrupts = <0 19 4>;
+			reg = <0xe000d000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		smcc: memory-controller@e000e000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			status = "disabled";
+			clock-names = "memclk", "aclk";
+			clocks = <&clkc 11>, <&clkc 44>;
+			compatible = "arm,pl353-smc-r2p1";
+			interrupt-parent = <&intc>;
+			interrupts = <0 18 4>;
+			ranges ;
+			reg = <0xe000e000 0x1000>;
+			nand0: flash@e1000000 {
+				status = "disabled";
+				compatible = "arm,pl353-nand-r2p1";
+				reg = <0xe1000000 0x1000000>;
+				#address-cells = <0x1>;
+				#size-cells = <0x1>;
+			};
+			nor0: flash@e2000000 {
+				status = "disabled";
+				compatible = "cfi-flash";
+				reg = <0xe2000000 0x1000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+			};
+		};
+
+		gem0: ethernet@e000b000 {
+			compatible = "xlnx,ps7-ethernet-1.00.a";
+			reg = <0xe000b000 0x1000>;
+			status = "disabled";
+			interrupts = <0 22 4>;
+			clocks = <&clkc 13>, <&clkc 30>;
+			clock-names = "ref_clk", "aper_clk";
+			local-mac-address = [00 0a 35 00 00 00];
+			xlnx,has-mdio = <0x1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		gem1: ethernet@e000c000 {
+			compatible = "xlnx,ps7-ethernet-1.00.a";
+			reg = <0xe000c000 0x1000>;
+			status = "disabled";
+			interrupts = <0 45 4>;
+			clocks = <&clkc 14>, <&clkc 31>;
+			clock-names = "ref_clk", "aper_clk";
+			local-mac-address = [00 0a 35 00 00 00];
+			xlnx,has-mdio = <0x1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		sdhci0: sdhci@e0100000 {
+			compatible = "arasan,sdhci-8.9a";
+			status = "disabled";
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clkc 21>, <&clkc 32>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 24 4>;
+			reg = <0xe0100000 0x1000>;
+		};
+
+		sdhci1: sdhci@e0101000 {
+			compatible = "arasan,sdhci-8.9a";
+			status = "disabled";
+			clock-names = "clk_xin", "clk_ahb";
+			clocks = <&clkc 22>, <&clkc 33>;
+			interrupt-parent = <&intc>;
+			interrupts = <0 47 4>;
+			reg = <0xe0101000 0x1000>;
+		};
+
+		slcr: slcr@f8000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "xlnx,zynq-slcr", "syscon";
+			reg = <0xF8000000 0x1000>;
+			ranges;
+			clkc: clkc@100 {
+				#clock-cells = <1>;
+				compatible = "xlnx,ps7-clkc";
+				ps-clk-frequency = <33333333>;
+				fclk-enable = <0xf>;
+				clock-output-names = "armpll", "ddrpll", "iopll", "cpu_6or4x",
+						"cpu_3or2x", "cpu_2x", "cpu_1x", "ddr2x", "ddr3x",
+						"dci", "lqspi", "smc", "pcap", "gem0", "gem1",
+						"fclk0", "fclk1", "fclk2", "fclk3", "can0", "can1",
+						"sdio0", "sdio1", "uart0", "uart1", "spi0", "spi1",
+						"dma", "usb0_aper", "usb1_aper", "gem0_aper",
+						"gem1_aper", "sdio0_aper", "sdio1_aper",
+						"spi0_aper", "spi1_aper", "can0_aper", "can1_aper",
+						"i2c0_aper", "i2c1_aper", "uart0_aper", "uart1_aper",
+						"gpio_aper", "lqspi_aper", "smc_aper", "swdt",
+						"dbg_trc", "dbg_apb";
+				reg = <0x100 0x100>;
+			};
+		};
+
+		dmac_s: dmac@f8003000 {
+			compatible = "arm,pl330", "arm,primecell";
+			reg = <0xf8003000 0x1000>;
+			interrupt-parent = <&intc>;
+			interrupt-names = "abort", "dma0", "dma1", "dma2", "dma3",
+				"dma4", "dma5", "dma6", "dma7";
+			interrupts = <0 13 4>,
+			             <0 14 4>, <0 15 4>,
+			             <0 16 4>, <0 17 4>,
+			             <0 40 4>, <0 41 4>,
+			             <0 42 4>, <0 43 4>;
+			#dma-cells = <1>;
+			#dma-channels = <8>;
+			#dma-requests = <4>;
+			clocks = <&clkc 27>;
+			clock-names = "apb_pclk";
+		};
+
+		devcfg: devcfg@f8007000 {
+			clock-names = "ref_clk", "fclk0", "fclk1", "fclk2", "fclk3";
+			clocks = <&clkc 12>, <&clkc 15>, <&clkc 16>, <&clkc 17>, <&clkc 18>;
+			compatible = "xlnx,zynq-devcfg-1.0";
+			interrupt-parent = <&intc>;
+			interrupts = <0 8 4>;
+			reg = <0xf8007000 0x100>;
+		};
+
+		global_timer: timer@f8f00200 {
+			compatible = "arm,cortex-a9-global-timer";
+			reg = <0xf8f00200 0x20>;
+			interrupts = <1 11 0x301>;
+			interrupt-parent = <&intc>;
+			clocks = <&clkc 4>;
+		};
+
+		ttc0: timer@f8001000 {
+			interrupt-parent = <&intc>;
+			interrupts = <0 10 4>, <0 11 4>, <0 12 4>;
+			compatible = "cdns,ttc";
+			clocks = <&clkc 6>;
+			reg = <0xF8001000 0x1000>;
+		};
+
+		ttc1: timer@f8002000 {
+			interrupt-parent = <&intc>;
+			interrupts = <0 37 4>, <0 38 4>, <0 39 4>;
+			compatible = "cdns,ttc";
+			clocks = <&clkc 6>;
+			reg = <0xF8002000 0x1000>;
+		};
+
+		scutimer: timer@f8f00600 {
+			interrupt-parent = <&intc>;
+			interrupts = <1 13 0x301>;
+			compatible = "arm,cortex-a9-twd-timer";
+			reg = <0xf8f00600 0x20>;
+			clocks = <&clkc 4>;
+		};
+
+		watchdog0: watchdog@f8005000 {
+			clocks = <&clkc 45>;
+			compatible = "xlnx,zynq-wdt-r1p2";
+			device_type = "watchdog";
+			interrupt-parent = <&intc>;
+			interrupts = <0 9 1>;
+			reg = <0xf8005000 0x1000>;
+			reset = <0>;
+			timeout-sec = <10>;
+		};
+
+		usb0: usb@e0002000 {
+			clocks = <&clkc 28>;
+			compatible = "xlnx,ps7-usb-1.00.a", "xlnx,zynq-usb-1.00.a";
+			status = "disabled";
+			interrupt-parent = <&intc>;
+			interrupts = <0 21 4>;
+			reg = <0xe0002000 0x1000>;
+		};
+
+		usb1: usb@e0003000 {
+			clocks = <&clkc 29>;
+			compatible = "xlnx,ps7-usb-1.00.a", "xlnx,zynq-usb-1.00.a";
+			status = "disabled";
+			interrupt-parent = <&intc>;
+			interrupts = <0 44 4>;
+			reg = <0xe0003000 0x1000>;
+		};
+	};
+};
--- /dev/null
+++ b/arch/arm/boot/dts/zynq-zturn.dts
@@ -0,0 +1,269 @@
+/*
+ *  Copyright (C) 2011 - 2014 Xilinx
+ *  Copyright (C) 2012 National Instruments Corp.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+/dts-v1/;
+/include/ "zynq-7000.dtsi"
+
+
+/ {
+	model = "MYIR Z-turn Development Board";
+	compatible = "myir,zynq-zturn", "xlnx,zynq-7000";
+
+	aliases {
+		ethernet0 = &gem0;
+		serial0 = &uart1;
+		serial1 = &uart0;
+		spi0 = &qspi;
+	};
+
+	memory {
+		device_type = "memory";
+		reg = <0x0 0x30000000>; // Reserved 256MB for xylonfb driver
+	};
+
+	chosen {
+		bootargs = "console=ttyPS0,115200 root=/dev/ram rw earlyprintk";
+		linux,stdout-path = "/amba/serial@e0001000";
+	};
+};
+
+&gpio0 {
+    emio-gpio-width = <64>;
+    gpio-mask-high = <0x0>;
+    gpio-mask-low = <0x5600>;
+    xlnx,emio-gpio-width = <0x40>;
+    xlnx,mio-gpio-mask = <0x5600>;
+};
+
+&qspi {
+	status = "okay";
+	is-dual = <0>;
+	num-cs = <1>;
+	xlnx,fb-clk = <0x1>;
+	xlnx,qspi-mode = <0x0>;
+	flash@0 {
+		compatible = "n25q128";
+		reg = <0x0>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		spi-max-frequency = <50000000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		partition@qspi-boot {
+			label = "qspi-boot";
+			reg = <0x0 0x080000>;
+		};
+		partition@qspi-bootenv {
+			label = "qspi-bootenv";
+			reg = <0x080000 0x020000>;
+		};		
+		partition@qspi-bitstream {
+			label = "qspi-bitstream";
+			reg = <0x0A0000 0x460000>;
+		};		
+		partition@qspi-kernel {
+			label = "qspi-kernel";
+			reg = <0x500000 0x480000>;
+		};
+		partition@qspi-devicetree {
+			label = "qspi-devicetree";
+			reg = <0x980000 0x010000>;
+		};
+		partition@qspi-rootfs {
+			label = "qspi-rootfs";
+			reg = <0x990000 0x600000>;
+		};
+		partition@qspi-data {
+			label = "data";
+			reg = <0xF90000 0x070000>;
+		};
+	};
+};
+
+&usb0 {
+	status = "okay";
+	dr_mode = "host";
+	phy_type = "ulpi";	
+};
+
+&gem0 {
+	status = "okay";
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethernet_phy>;
+
+	ethernet_phy: ethernet-phy@0 {
+		reg = <0>;
+	};
+};
+
+&sdhci0 {
+	status = "okay";
+    xlnx,has-cd = <0x1>;
+    xlnx,has-power = <0x0>;
+    xlnx,has-wp = <0x1>;
+};
+
+&uart0 {
+	status = "okay";
+    current-speed = <115200>;
+    port-number = <1>;
+    xlnx,has-modem = <0x0>;
+};
+
+&uart1 {
+	status = "okay";
+    current-speed = <115200>;
+    port-number = <0>;
+    xlnx,has-modem = <0x0>;
+};
+
+&i2c0 {
+	status = "okay";
+//  bus-id = <0x0>;
+    clock-frequency = <400000>;
+    xlnx,has-interrupt = <0x1>;
+	
+    adxl345@53 {
+        compatible = "adi,adxl34x","adxl34x";
+        reg = <0x53>;
+        interrupt-parent = <&intc>;
+        interrupts = < 0 31 4 >;
+    };
+
+    sii902x@3b {
+        compatible = "sii902x";
+        reg = <0x3b>;
+        interrupt-parent = <&intc>;
+        interrupts = < 0 29 4 >;
+		mode_str = "1920x1080";
+		bits-per-pixel = <16>;
+    };
+
+	stlm75@49 {
+		status = "okay";
+		compatible = "myir-stlm75x";
+		reg = <0x49>;
+		interrupts = < 0 32 4 >;
+	};
+};
+
+/*
+&i2c1 {
+	status = "okay";
+    clock-frequency = <400000>;
+    xlnx,has-interrupt = <0x1>;
+    
+	ft0x5x_ts@38 {
+        compatible = "ft5x06_ts";
+        reg = <0x38>;
+        tp_int = <&gpio0 106 1>;
+        tp_resetn = <&gpio0 107 1>;
+	    polling_mode = /bits/ 8 <0>;
+        multi_touch = /bits/ 8 <0>;
+    };	
+};
+*/
+
+&can0 {
+	status = "okay";
+};
+
+&amba {
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		led_r {
+			label = "led_r";
+			gpios = <&gpio0 114 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		led_g {
+			label = "led_g";
+			gpios = <&gpio0 115 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		led_b {
+			label = "led_b";
+			gpios = <&gpio0 116 1>;
+			default-state = "on";
+			linux,default-trigger = "heartbeat";
+		};
+		usr_led1 {
+			label = "usr_led1";
+			gpios = <&gpio0 0 1>;
+			default-state = "off";
+			linux,default-trigger = "none";
+		};
+		usr_led2 {
+			label = "usr_led2";
+			gpios = <&gpio0 9 1>;
+			default-state = "off";
+			linux,default-trigger = "none";
+		};
+	};
+	
+    gpio-beep {
+            compatible = "gpio-beeper";
+            lable = "pl-beep";
+            gpios = <&gpio0 117 0>;
+        };
+	
+/* MYIR, added USR key */
+	gpio-keys {
+		compatible = "gpio-keys";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		autorepeat;
+		K1 {
+			label = "K1";
+			gpios = <&gpio0 50 1>;
+			linux,code = <102>; /* KEY_HOME */
+			gpio-key,wakeup;
+			autorepeat;
+		};
+
+/*	Switches
+		sw1 {
+			label = "sw1";
+			gpios = <&gpio0 110 1>;
+			linux,code = <103>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw2 {
+			label = "sw2";
+			gpios = <&gpio0 111 1>;
+			linux,code = <104>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw3 {
+			label = "sw3";
+			gpios = <&gpio0 112 1>;
+			linux,code = <104>;
+			gpio-key,wakeup;
+			autorepeat;
+		};
+		sw4 {
+			label = "sw4";
+			gpios = <&gpio0 113 1>;
+			linux,code = <105>;
+			gpio-key,wakeup;
+			autorepeat;
+		}; */
+	};
+	
+ /include/ "zynq-zturn-xylon.dtsi"
+};
--- /dev/null
+++ b/arch/arm/boot/dts/zynq-zturn-xylon.dtsi
@@ -0,0 +1,235 @@
+logiclk_0: logiclk@43c00000 {
+	compatible = "xylon,logiclk-1.02.b";
+	reg = <0x43c00000 0x10000>;
+	osc-clk-freq-hz = <0x5f5e100>;
+	xlnx,clk-multiply = <0x9>;
+	xlnx,clk0-divide = <0xc>;
+	xlnx,clk1-divide = <0x6>;
+	xlnx,clk2-divide = <0x1>;
+	xlnx,clk3-divide = <0x1>;
+	xlnx,clk4-divide = <0x1>;
+	xlnx,clk5-divide = <0x1>;
+	xlnx,drp-bandwidth = "OPTIMIZED";
+	xlnx,drp-clkfbout-mult = <0x9>;
+	xlnx,drp-clkfbout-phase = <0x0>;
+	xlnx,drp-clkout0-divide = <0x6>;
+	xlnx,drp-clkout0-duty = <0xc350>;
+	xlnx,drp-clkout0-phase = <0x0>;
+	xlnx,drp-clkout1-divide = <0x1>;
+	xlnx,drp-clkout1-duty = <0xc350>;
+	xlnx,drp-clkout1-phase = <0x0>;
+	xlnx,drp-clkout2-divide = <0x1>;
+	xlnx,drp-clkout2-duty = <0xc350>;
+	xlnx,drp-clkout2-phase = <0x0>;
+	xlnx,drp-clkout3-divide = <0x1>;
+	xlnx,drp-clkout3-duty = <0xc350>;
+	xlnx,drp-clkout3-phase = <0x0>;
+	xlnx,drp-clkout4-divide = <0x1>;
+	xlnx,drp-clkout4-duty = <0xc350>;
+	xlnx,drp-clkout4-phase = <0x0>;
+	xlnx,drp-clkout5-divide = <0x1>;
+	xlnx,drp-clkout5-duty = <0xc350>;
+	xlnx,drp-clkout5-phase = <0x0>;
+	xlnx,drp-divclk-divide = <0x1>;
+	xlnx,ip-license-type = <0x1>;
+	xlnx,ip-major-revision = <0x1>;
+	xlnx,ip-minor-revision = <0x2>;
+	xlnx,ip-patch-level = <0x1>;
+	xlnx,regs-interface = <0x2>;
+	xlnx,rst-polarity = <0x0>;
+	xlnx,splb-awidth = <0x20>;
+	xlnx,splb-dwidth = <0x20>;
+	xlnx,splb-mid-width = <0x1>;
+	xlnx,splb-native-dwidth = <0x20>;
+	xlnx,splb-num-masters = <0x2>;
+	xlnx,use-clk-drp = <0x1>;
+	xlnx,use-vlink-clk = <0x0>;
+} ;
+
+logicvc_1: logicvc@43c10000 {
+	compatible = "xylon,logicvc-3.02.a";
+	interrupt-parent = <&intc>;
+	interrupts = <0 30 4>;
+	reg = <0x43c10000 0x10000>;
+	xlnx,buffer-0-offset = <0x438>;
+	xlnx,buffer-1-offset = <0x438>;
+	xlnx,buffer-2-offset = <0x438>;
+	xlnx,buffer-3-offset = <0x438>;
+	xlnx,buffer-4-offset = <0x438>;
+	xlnx,display-color-space = <0x0>;
+	xlnx,display-interface = <0x0>;
+	xlnx,dvi-clk-mode = <0x0>;
+	xlnx,e-data-width = <0x18>;
+	xlnx,e-layer = <0x0>;
+	xlnx,increase-fifo = <0x4>;
+	xlnx,ip-license-check = <0x1>;
+	xlnx,ip-license-type = <0x1>;
+	xlnx,ip-major-revision = <0x3>;
+	xlnx,ip-minor-revision = <0x2>;
+	xlnx,ip-patch-level = <0x0>;
+	xlnx,ip-time-before-break = <0x1>;
+	xlnx,layer-0-alpha-mode = <0x1>;
+	xlnx,layer-0-data-width = <0x18>;
+	xlnx,layer-0-offset = <0x1c7a>;
+	xlnx,layer-0-type = <0x0>;
+	xlnx,layer-1-alpha-mode = <0x0>;
+	xlnx,layer-1-data-width = <0x18>;
+	xlnx,layer-1-offset = <0xfd2>;
+	xlnx,layer-1-type = <0x0>;
+	xlnx,layer-2-alpha-mode = <0x0>;
+	xlnx,layer-2-data-width = <0x18>;
+	xlnx,layer-2-offset = <0x0>;
+	xlnx,layer-2-type = <0x0>;
+	xlnx,layer-3-alpha-mode = <0x3>;
+	xlnx,layer-3-data-width = <0x8>;
+	xlnx,layer-3-offset = <0x32a0>;
+	xlnx,layer-3-type = <0x0>;
+	xlnx,layer-4-alpha-mode = <0x0>;
+	xlnx,layer-4-data-width = <0x18>;
+	xlnx,layer-4-offset = <0x2000>;
+	xlnx,layer-4-type = <0x0>;
+	xlnx,lvds-data-width = <0x4>;
+	xlnx,mem-burst = <0x4>;
+	xlnx,mem-byte-swap = <0x0>;
+	xlnx,mem-little-endian = <0x1>;
+	xlnx,mplb-awidth = <0x20>;
+	xlnx,mplb-dwidth = <0x40>;
+	xlnx,mplb-num-masters = <0x8>;
+	xlnx,mplb-priority = <0x3>;
+	xlnx,mplb-smallest-slave = <0x20>;
+	xlnx,num-of-layers = <0x3>;
+	xlnx,opb-awidth = <0x20>;
+	xlnx,opb-dwidth = <0x20>;
+	xlnx,pixel-data-width = <0x10>;
+	xlnx,little-endian = <0x1>;
+	xlnx,readable-regs = <0x1>;
+	xlnx,reg-byte-swap = <0x0>;
+	xlnx,regs-interface = <0x2>;
+	xlnx,row-stride = <0x800>;
+	xlnx,splb-awidth = <0x20>;
+	xlnx,splb-dwidth = <0x20>;
+	xlnx,splb-mid-width = <0x1>;
+	xlnx,splb-native-dwidth = <0x20>;
+	xlnx,splb-num-masters = <0x2>;
+	xlnx,use-e-parallel-input = <0x0>;
+	xlnx,use-e-vclk-bufgmux = <0x0>;
+	xlnx,use-multiplier = <0x2>;
+	xlnx,vmem-baseaddr = <0x30000000>;
+	xlnx,vmem-highaddr = <0x3fffffff>;
+	pixel-clock-source = <2>;
+	pixel-data-invert = <0>;
+	pixel-clock-active-high = <0>;
+	pixel-component-format = "ARGB";
+	pixel-component-layer = <0x0 0x1 0x2>;
+	xlnx,use-vclk2 = <0x1>;
+	xlnx,use-xtreme-dsp = <0x1>;
+	xlnx,vclk-period = <0x61a8>;
+	xlnx,vmem-interface = <0x2>;
+	xlnx,xcolor = <0x0>;
+	xlnx,xmb-data-bus-width = <0x40>;
+	xlnx,use-background = <0x1>;
+	xlnx,use-size-position = <0x1>;
+	active-layer = <0x1>;
+	videomode = "1920x1080";
+	edid {
+		preffered-videomode = <0x1>;
+		display-data = <0x1>;
+   };
+
+	xylon-video-params {	
+		480x272_LCDV1{
+			name = "480x272_LCDV1";
+			pwr_en = <&gpio0 108 1>;
+			bl_en = <&gpio0 109 1>;			
+			refresh = <60>;
+			xres = <480>;
+			yres = <272>;
+			pixclock-khz = <10000>;
+			left-margin = <40>;
+			right-margin = <40>;
+			upper-margin = <29>;
+			lower-margin = <13>;
+			hsync-len = <48>;
+			vsync-len = <3>;
+			sync = <0>;
+			vmode = <0>;
+		};
+		800x480_LCDV2 {
+			name = "800x480_LCDV2";
+			pwr_en = <&gpio0 108 1>;
+			bl_en = <&gpio0 109 1>;
+			refresh = <60>;
+			xres = <800>;
+			yres = <480>;
+			pixclock-khz = <33330>;
+			left-margin = <210>;
+			right-margin = <46>;
+			upper-margin = <22>;
+			lower-margin = <23>;
+			hsync-len = <20>;
+			vsync-len = <10>;
+			sync = <0>;
+			vmode = <0>;
+		};
+		1024x768 {
+			name = "1024x768";
+			refresh = <60>;
+			xres = <1024>;
+			yres = <768>;
+			pixclock-khz = <65000>;
+			left-margin = <160>;
+			right-margin = <24>;
+			upper-margin = <29>;
+			lower-margin = <3>;
+			hsync-len = <136>;
+			vsync-len = <6>;
+			sync = <1>;
+			vmode = <0>;
+		};
+		1280x720 {
+			name = "1280x720";
+			refresh = <60>;
+			xres = <1280>;
+			yres = <720>;
+			pixclock-khz = <74250>;
+			left-margin = <220>;
+			right-margin = <110>;
+			upper-margin = <20>;
+			lower-margin = <5>;
+			hsync-len = <40>;
+			vsync-len = <5>;
+			sync = <1>;
+			vmode = <0>;
+		};
+		1680x1050 {
+			name = "1680x1050";
+			refresh = <60>;
+			xres = <1680>;
+			yres = <1050>;
+			pixclock-khz = <119000>;
+			left-margin = <80>;
+			right-margin = <48>;
+			upper-margin = <21>;
+			lower-margin = <3>;
+			hsync-len = <32>;
+			vsync-len = <6>;
+			sync = <0>;
+			vmode = <0>;
+		};
+		1920x1080 {
+			name = "1920x1080";
+			refresh = <60>;
+			xres = <1920>;
+			yres = <1080>;
+			pixclock-khz = <148500>;
+			left-margin = <148>;
+			right-margin = <88>;
+			upper-margin = <36>;
+			lower-margin = <4>;
+			hsync-len = <44>;
+			vsync-len = <5>;
+			sync = <0>;
+			vmode = <0>;
+		};
+	};
+} ;
--- a/arch/arm/boot/Makefile
+++ b/arch/arm/boot/Makefile
@@ -57,6 +57,9 @@
 
 endif
 
+# Added by MYIR
+LOADADDR ?= 0x8000
+
 ifneq ($(LOADADDR),)
   UIMAGE_LOADADDR=$(LOADADDR)
 else
--- /dev/null
+++ b/arch/arm/configs/zynq_zturn_defconfig
@@ -0,0 +1,3794 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 3.15.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT_MAP=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPUFREQ=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-xilinx"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_FHANDLE=y
+CONFIG_USELIB=y
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+CONFIG_PREEMPT_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=32
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_RCU_FAST_NO_HZ is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_BOOST is not set
+# CONFIG_RCU_NOCB_CPU is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CPUSETS is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_RESOURCE_COUNTERS is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+CONFIG_RD_XZ=y
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+# CONFIG_BUG is not set
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE_LEGACY is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_MULTI_CPU_AUTO is not set
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HI3xxx is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_SHMOBILE_MULTI is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_U8500 is not set
+CONFIG_ARCH_VEXPRESS=y
+
+#
+# Versatile Express platform type
+#
+CONFIG_ARCH_VEXPRESS_CORTEX_A5_A9_ERRATA=y
+# CONFIG_ARCH_VEXPRESS_CA9X4 is not set
+# CONFIG_ARCH_VEXPRESS_SPC is not set
+CONFIG_PLAT_VERSATILE_CLCD=y
+CONFIG_PLAT_VERSATILE_SCHED_CLOCK=y
+# CONFIG_ARCH_WM8850 is not set
+CONFIG_ARCH_ZYNQ=y
+
+#
+# Xilinx Specific Options
+#
+CONFIG_XILINX_PREFETCH=y
+CONFIG_XILINX_AXIPCIE=y
+CONFIG_PLAT_VERSATILE=y
+CONFIG_ARM_TIMER_SP804=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+CONFIG_SWP_EMULATE=y
+# CONFIG_CPU_BIG_ENDIAN is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_KUSER_HELPERS=y
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
+CONFIG_CACHE_PL310=y
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARCH_SUPPORTS_BIG_ENDIAN=y
+CONFIG_ARM_NR_BANKS=8
+CONFIG_MULTI_IRQ_HANDLER=y
+# CONFIG_ARM_ERRATA_430973 is not set
+CONFIG_PL310_ERRATA_588369=y
+# CONFIG_ARM_ERRATA_643719 is not set
+CONFIG_ARM_ERRATA_720789=y
+CONFIG_PL310_ERRATA_727915=y
+CONFIG_PL310_ERRATA_753970=y
+CONFIG_ARM_ERRATA_754322=y
+CONFIG_ARM_ERRATA_754327=y
+CONFIG_ARM_ERRATA_764369=y
+CONFIG_PL310_ERRATA_769419=y
+CONFIG_ARM_ERRATA_775420=y
+# CONFIG_ARM_ERRATA_798181 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+CONFIG_ICST=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+CONFIG_PCI=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_IOV is not set
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+
+#
+# PCI host controller drivers
+#
+# CONFIG_PCIEPORTBUS is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+CONFIG_SMP=y
+CONFIG_SMP_ON_UP=y
+CONFIG_ARM_CPU_TOPOLOGY=y
+CONFIG_SCHED_MC=y
+CONFIG_SCHED_SMT=y
+CONFIG_HAVE_ARM_SCU=y
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_HAVE_ARM_TWD=y
+# CONFIG_MCPM is not set
+# CONFIG_BIG_LITTLE is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_NR_CPUS=4
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=1024
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_THUMB2_KERNEL is not set
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+# CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_COMPACTION is not set
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+# CONFIG_ARM_APPENDED_DTB is not set
+CONFIG_CMDLINE="console=ttyPS0,115200n8 root=/dev/ram rw initrd=0x00800000,16M earlyprintk mtdparts=physmap-flash.0:512K(nor-fsbl),512K(nor-u-boot),5M(nor-linux),9M(nor-user),1M(nor-scratch),-(nor-rootfs)"
+CONFIG_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_CMDLINE_EXTEND is not set
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_GENERIC_CPUFREQ_CPU0=y
+
+#
+# ARM CPU frequency scaling drivers
+#
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_ZYNQ_CPUIDLE=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+CONFIG_VFPv3=y
+CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_HAS_OPP=y
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=m
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=m
+# CONFIG_IP_MROUTE is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_LRO=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=m
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_GRE is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_NET_MPLS_GSO is not set
+# CONFIG_HSR is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+# CONFIG_CAN_LEDS is not set
+# CONFIG_CAN_AT91 is not set
+# CONFIG_CAN_TI_HECC is not set
+# CONFIG_CAN_MCP251X is not set
+# CONFIG_CAN_FLEXCAN is not set
+# CONFIG_PCH_CAN is not set
+# CONFIG_CAN_GRCAN is not set
+CONFIG_CAN_XILINXCAN=y
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_SOFTING is not set
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+# CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+# CONFIG_MAC80211_RC_PID is not set
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+# CONFIG_MAC80211_LEDS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_RFKILL_REGULATOR is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_DMA_SHARED_BUFFER=y
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=128
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+CONFIG_CMA_AREAS=7
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCI is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
+CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_ST_SPI_FSM is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_DENALI is not set
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_RICOH is not set
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_DOCG4 is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+CONFIG_MTD_NAND_PL353=y
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+
+#
+# Device Tree and Open Firmware support
+#
+# CONFIG_OF_SELFTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_OF_MTD=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_PARPORT is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_VIRTIO_BLK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ATMEL_PWM is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_ARM_CHARLCD is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_BMP085_SPI is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+CONFIG_XILINX_TRAFGEN=y
+CONFIG_MYIR_STLM75X=y
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+# CONFIG_ECHO is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_HAVE_PATA_PLATFORM=y
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NLMON is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMD is not set
+CONFIG_NET_VENDOR_ARC=y
+# CONFIG_ARC_EMAC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+CONFIG_NET_CADENCE=y
+CONFIG_MACB=y
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BCMGENET is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+CONFIG_TIGON3=y
+# CONFIG_BNX2X is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+# CONFIG_E1000 is not set
+CONFIG_E1000E=y
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+# CONFIG_IXGB is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGBEVF is not set
+# CONFIG_I40E is not set
+# CONFIG_I40EVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+CONFIG_R8169=y
+# CONFIG_SH_ETH is not set
+# CONFIG_NET_VENDOR_RDC is not set
+CONFIG_NET_VENDOR_SAMSUNG=y
+# CONFIG_SXGBE_ETH is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_NET_VENDOR_XILINX=y
+CONFIG_XILINX_EMACLITE=y
+CONFIG_XILINX_AXI_EMAC=y
+CONFIG_XILINX_PS_EMAC=y
+# CONFIG_XILINX_PS_EMAC_HWTSTAMP is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+CONFIG_AT803X_PHY=y
+# CONFIG_AMD_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+CONFIG_MDIO_BITBANG=y
+# CONFIG_MDIO_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+# CONFIG_PPP_MPPE is not set
+CONFIG_PPP_MULTILINK=y
+# CONFIG_PPPOE is not set
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_ATMEL is not set
+# CONFIG_AT76C50X_USB is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_MWL8K is not set
+# CONFIG_ATH_CARDS is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_BRCMSMAC is not set
+# CONFIG_BRCMFMAC is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_IWLWIFI is not set
+# CONFIG_IWL4965 is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_HERMES is not set
+# CONFIG_P54_COMMON is not set
+# CONFIG_RT2X00 is not set
+CONFIG_RTL_CARDS=y
+# CONFIG_RTL8192CE is not set
+# CONFIG_RTL8192SE is not set
+# CONFIG_RTL8192DE is not set
+# CONFIG_RTL8723AE is not set
+# CONFIG_RTL8723BE is not set
+# CONFIG_RTL8188EE is not set
+CONFIG_RTL8192CU=y
+CONFIG_RTLWIFI=y
+CONFIG_RTLWIFI_USB=y
+CONFIG_RTLWIFI_DEBUG=y
+CONFIG_RTL8192C_COMMON=y
+# CONFIG_WL_TI is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_MWIFIEX is not set
+# CONFIG_CW1200 is not set
+# CONFIG_RSI_91X is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+CONFIG_INPUT_SPARSEKMAP=y
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=m
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_SENTELIC is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+CONFIG_MOUSE_SYNAPTICS_USB=y
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_SUR40 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+CONFIG_TOUCHSCREEN_FT5X0X=y
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_GP2A is not set
+CONFIG_INPUT_GPIO_BEEPER=y
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+CONFIG_INPUT_ADXL34X=y
+CONFIG_INPUT_ADXL34X_I2C=y
+# CONFIG_INPUT_ADXL34X_SPI is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_SOC_BUTTON_ARRAY is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_MFD_HSU is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_PCH_UART is not set
+CONFIG_SERIAL_XILINX_PS_UART=y
+CONFIG_SERIAL_XILINX_PS_UART_CONSOLE=y
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_VIRTIO_CONSOLE is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_XILINX_DEVCFG=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+CONFIG_I2C_CADENCE=y
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EG20T is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_VERSATILE is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_CADENCE=y
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PL022 is not set
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_TOPCLIFF_PCH is not set
+# CONFIG_SPI_XCOMM is not set
+CONFIG_SPI_XILINX=y
+CONFIG_SPI_ZYNQ_QSPI=y
+# CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers:
+#
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_EM is not set
+# CONFIG_GPIO_ZEVIO is not set
+# CONFIG_GPIO_PL061 is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_SCH311X is not set
+# CONFIG_GPIO_SYSCON is not set
+CONFIG_GPIO_XILINX=y
+CONFIG_GPIO_ZYNQ=y
+# CONFIG_GPIO_VX855 is not set
+# CONFIG_GPIO_GRGPIO is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+
+#
+# PCI GPIO expanders:
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_AMD8111 is not set
+# CONFIG_GPIO_ML_IOH is not set
+# CONFIG_GPIO_RDC321X is not set
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# LPC GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_GPIO_BCM_KONA is not set
+
+#
+# USB GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_SMB347 is not set
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_RESTART is not set
+CONFIG_POWER_RESET_VEXPRESS=y
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_HTU21 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+CONFIG_PMBUS=y
+CONFIG_SENSORS_PMBUS=y
+# CONFIG_SENSORS_ADM1275 is not set
+# CONFIG_SENSORS_LM25066 is not set
+# CONFIG_SENSORS_LTC2978 is not set
+# CONFIG_SENSORS_MAX16064 is not set
+# CONFIG_SENSORS_MAX34440 is not set
+# CONFIG_SENSORS_MAX8688 is not set
+CONFIG_SENSORS_UCD9000=y
+CONFIG_SENSORS_UCD9200=y
+# CONFIG_SENSORS_ZL6100 is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VEXPRESS is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_IMX_THERMAL is not set
+
+#
+# Texas Instruments thermal drivers
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+CONFIG_XILINX_WATCHDOG=y
+# CONFIG_ARM_SP805_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+CONFIG_CADENCE_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8921_CORE is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TIMBERDALE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_VEXPRESS_CONFIG=y
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VEXPRESS is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_RC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_SOC_CAMERA is not set
+CONFIG_VIDEO_XILINX=y
+CONFIG_VIDEO_XILINX_CFA=y
+CONFIG_VIDEO_XILINX_CRESAMPLE=y
+# CONFIG_VIDEO_XILINX_HLS is not set
+CONFIG_VIDEO_XILINX_REMAPPER=y
+CONFIG_VIDEO_XILINX_RGB2YUV=y
+CONFIG_VIDEO_XILINX_SCALER=y
+CONFIG_VIDEO_XILINX_SWITCH=y
+CONFIG_VIDEO_XILINX_TPG=y
+CONFIG_VIDEO_XILINX_VTC=y
+# CONFIG_V4L_MEM2MEM_DRIVERS is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, frontends)
+#
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+
+#
+# Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+CONFIG_VIDEO_ADV7604=y
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7191 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_AD9389B is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_THS8200 is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9M032 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T001 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+# CONFIG_VIDEO_S5K6AA is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_SMIAPP is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_AS3645A is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Audio/Video compression chips
+#
+# CONFIG_VIDEO_SAA6752HS is not set
+
+#
+# Miscellaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+
+#
+# Sensors used on soc_camera driver
+#
+
+#
+# Customise DVB Frontends
+#
+CONFIG_DVB_AU8522=m
+CONFIG_DVB_AU8522_V4L=m
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+
+#
+# Direct Rendering Manager
+#
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_KMS_FB_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+CONFIG_DRM_GEM_CMA_HELPER=y
+CONFIG_DRM_KMS_CMA_HELPER=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+CONFIG_DRM_ENCODER_ADV7511=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_ARMADA is not set
+# CONFIG_DRM_RCAR_DU is not set
+# CONFIG_DRM_SHMOBILE is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+CONFIG_DRM_XILINX=y
+CONFIG_DRM_XILINX_DP=y
+CONFIG_DRM_XYLON=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_ARMCLCD is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_XILINX is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_EXYNOS_VIDEO is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_FB_XYLON=y
+# CONFIG_FB_XYLON_PLATFORM is not set
+CONFIG_FB_XYLON_OF=y
+CONFIG_FB_XYLON_PIXCLK=y
+CONFIG_FB_XYLON_PIXCLK_ZYNQ_PS=y
+CONFIG_FB_XYLON_PIXCLK_LOGICLK=y
+# CONFIG_FB_XYLON_PIXCLK_SI570 is not set
+# CONFIG_FB_XYLON_MISC is not set
+CONFIG_MYIR_SII902X=y
+# CONFIG_SII902X_EDID_READING is not set
+# CONFIG_VGASTATE is not set
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_DMAENGINE_PCM=y
+CONFIG_SND_COMPRESS_OFFLOAD=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+
+#
+# HD-Audio
+#
+# CONFIG_SND_HDA_INTEL is not set
+CONFIG_SND_ARM=y
+# CONFIG_SND_ARMAACI is not set
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+CONFIG_SND_SOC_ADI=y
+CONFIG_SND_SOC_ADI_AXI_I2S=y
+CONFIG_SND_SOC_ADI_AXI_SPDIF=y
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271 is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_HDMI_CODEC is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1792A is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8804 is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CP2112 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_HUION is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=y
+CONFIG_USB_ZYNQ_DR_OF=y
+CONFIG_USB_EHCI_ZYNQ=y
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FUSBH200_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+# CONFIG_USB_RENESAS_USBHS is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_SERIAL_GENERIC=y
+# CONFIG_USB_SERIAL_SIMPLE is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_ZTE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_AM335X_PHY_USB is not set
+# CONFIG_SAMSUNG_USB2PHY is not set
+# CONFIG_SAMSUNG_USB3PHY is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_RCAR_PHY is not set
+CONFIG_USB_ULPI=y
+CONFIG_USB_ULPI_VIEWPORT=y
+CONFIG_USB_ZYNQ_PHY=y
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+CONFIG_USB_ZYNQ=y
+CONFIG_USB_ZYNQ_ERRATA_DT654401=y
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+CONFIG_USB_GADGET_XILINX=y
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_S3C_HSOTG is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_DUMMY_HCD is not set
+CONFIG_USB_LIBCOMPOSITE=m
+CONFIG_USB_F_SS_LB=m
+CONFIG_USB_F_MASS_STORAGE=m
+CONFIG_USB_CONFIGFS=m
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+# CONFIG_USB_CONFIGFS_ACM is not set
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+# CONFIG_USB_CONFIGFS_RNDIS is not set
+# CONFIG_USB_CONFIGFS_EEM is not set
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+# CONFIG_USB_CONFIGFS_F_FS is not set
+CONFIG_USB_ZERO=m
+# CONFIG_USB_ZERO_HNPTEST is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_ARMMMCI is not set
+CONFIG_MMC_SDHCI=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+# CONFIG_MMC_SDHCI_PXAV3 is not set
+# CONFIG_MMC_SDHCI_PXAV2 is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_PCA9685 is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_BLINKM is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_BACKLIGHT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+CONFIG_LEDS_TRIGGER_TRANSIENT=y
+CONFIG_LEDS_TRIGGER_CAMERA=y
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+CONFIG_EDAC_LEGACY_SYSFS=y
+# CONFIG_EDAC_DEBUG is not set
+CONFIG_EDAC_MM_EDAC=y
+# CONFIG_EDAC_PL310_L2 is not set
+CONFIG_EDAC_ZYNQ=y
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12057 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+CONFIG_RTC_DRV_PCF8563=y
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_MOXART is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_XILINX_DMA_ENGINES=y
+CONFIG_XILINX_AXIDMA=y
+# CONFIG_XILINX_DMATEST is not set
+CONFIG_XILINX_AXIVDMA=y
+# CONFIG_XILINX_VDMATEST is not set
+CONFIG_XILINX_AXICDMA=y
+# CONFIG_XILINX_CDMATEST is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_DW_DMAC_CORE is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+CONFIG_PL330_DMA=y
+# CONFIG_FSL_EDMA is not set
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_CIF is not set
+CONFIG_UIO_PDRV_GENIRQ=y
+# CONFIG_UIO_DMEM_GENIRQ is not set
+# CONFIG_UIO_AEC is not set
+# CONFIG_UIO_SERCOS3 is not set
+# CONFIG_UIO_PCI_GENERIC is not set
+# CONFIG_UIO_NETX is not set
+# CONFIG_UIO_MF624 is not set
+CONFIG_UIO_XILINX_APM=y
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=m
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_BALLOON is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_VERSATILE=y
+# CONFIG_COMMON_CLK_SI5351 is not set
+CONFIG_COMMON_CLK_SI570=y
+# CONFIG_COMMON_CLK_AXI_CLKGEN is not set
+# CONFIG_COMMON_CLK_QCOM is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_CADENCE_TTC_TIMER=y
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_OF_IOMMU=y
+
+#
+# Remoteproc drivers
+#
+CONFIG_REMOTEPROC=m
+# CONFIG_STE_MODEM_RPROC is not set
+CONFIG_ZYNQ_REMOTEPROC=m
+CONFIG_MB_REMOTEPROC=m
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG=m
+# CONFIG_RPMSG_SERVER_SAMPLE is not set
+# CONFIG_RPMSG_FREERTOS_STAT is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+CONFIG_MEMORY=y
+CONFIG_PL353_SMC=y
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+# CONFIG_IIO_BUFFER_CB is not set
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGERED_BUFFER=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+
+#
+# Accelerometers
+#
+# CONFIG_BMA180 is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_KXSD9 is not set
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7266 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_EXYNOS_ADC is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_VF610_ADC is not set
+CONFIG_XILINX_XADC=y
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+
+#
+# Hid Sensor IIO Common
+#
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_AD5686 is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MCP4725 is not set
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_ITG3200 is not set
+
+#
+# Humidity sensors
+#
+# CONFIG_DHT11 is not set
+# CONFIG_SI7005 is not set
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_INV_MPU6050_IIO is not set
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_LTR501 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_VCNL4000 is not set
+
+#
+# Magnetometer sensors
+#
+# CONFIG_AK8975 is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+
+#
+# Inclinometer sensors
+#
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+
+#
+# Pressure sensors
+#
+# CONFIG_MPL3115 is not set
+# CONFIG_IIO_ST_PRESS is not set
+
+#
+# Temperature sensors
+#
+# CONFIG_TMP006 is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+# CONFIG_GENERIC_PHY is not set
+# CONFIG_PHY_SAMSUNG_USB2 is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_SWAP is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+CONFIG_TIMER_STATS=y
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_DEBUG_KOBJECT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU_DELAY is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=60
+# CONFIG_RCU_CPU_STALL_VERBOSE is not set
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_TEST_MODULE is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_PTDUMP is not set
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_PL01X is not set
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_OC_ETM is not set
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+# CONFIG_CRYPTO_GCM is not set
+CONFIG_CRYPTO_SEQIV=y
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA1_ARM is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_ARM is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+# CONFIG_XZ_DEC_SPARC is not set
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_AVERAGE=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_FONT_SUPPORT=y
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+CONFIG_VIRTUALIZATION=y
--- a/drivers/input/misc/adxl34x.c
+++ b/drivers/input/misc/adxl34x.c
@@ -222,7 +222,7 @@
 	.free_fall_threshold = 8,
 	.free_fall_time = 0x20,
 	.data_rate = 8,
-	.data_range = ADXL_FULL_RES,
+	.data_range = ADXL_FULL_RES|INT_INVERT, /* set to active LOW */
 
 	.ev_type = EV_ABS,
 	.ev_code_x = ABS_X,	/* EV_REL */
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x06_ts.h
@@ -0,0 +1,84 @@
+#ifndef __LINUX_FT5X0X_TS_H__
+#define __LINUX_FT5X0X_TS_H__
+ 
+#define SCREEN_MAX_X    800
+#define SCREEN_MAX_Y    480
+#define PRESS_MAX       255
+ 
+#define FT5X0X_NAME    "ft5x06_ts"
+ /* Structure for ft5x0x */
+struct ft5x0x_ts_platform_data {
+		u32    tp_resetn;	   /* reset pin */
+		u32    tp_int;		   /* int pin */
+        u16    irq;            /* irq number of ts used */
+        u8     polling_mode;   /* set 1 for polling mode and 0 for interruputing mode */
+        u8     multi_touch;    /* set 1 if supporting multi-touch */
+};
+
+enum ft5x0x_ts_regs {
+    FT5X0X_REG_THGROUP                    = 0x80,
+    FT5X0X_REG_THPEAK                        = 0x81,
+    FT5X0X_REG_THCAL                        = 0x82,
+    FT5X0X_REG_THWATER                    = 0x83,
+    FT5X0X_REG_THTEMP                    = 0x84,
+    FT5X0X_REG_THDIFF                        = 0x85,                
+    FT5X0X_REG_CTRL                        = 0x86,
+    FT5X0X_REG_TIMEENTERMONITOR            = 0x87,
+    FT5X0X_REG_PERIODACTIVE                = 0x88,
+    FT5X0X_REG_PERIODMONITOR            = 0x89,
+    FT5X0X_REG_HEIGHT_B                    = 0x8a,
+    FT5X0X_REG_MAX_FRAME                    = 0x8b,
+    FT5X0X_REG_DIST_MOVE                    = 0x8c,
+    FT5X0X_REG_DIST_POINT                = 0x8d,
+    FT5X0X_REG_FEG_FRAME                    = 0x8e,
+    FT5X0X_REG_SINGLE_CLICK_OFFSET        = 0x8f,
+    FT5X0X_REG_DOUBLE_CLICK_TIME_MIN    = 0x90,
+    FT5X0X_REG_SINGLE_CLICK_TIME            = 0x91,
+    FT5X0X_REG_LEFT_RIGHT_OFFSET        = 0x92,
+    FT5X0X_REG_UP_DOWN_OFFSET            = 0x93,
+    FT5X0X_REG_DISTANCE_LEFT_RIGHT        = 0x94,
+    FT5X0X_REG_DISTANCE_UP_DOWN        = 0x95,
+    FT5X0X_REG_ZOOM_DIS_SQR                = 0x96,
+    FT5X0X_REG_RADIAN_VALUE                =0x97,
+    FT5X0X_REG_MAX_X_HIGH                           = 0x98,
+    FT5X0X_REG_MAX_X_LOW                         = 0x99,
+    FT5X0X_REG_MAX_Y_HIGH                        = 0x9a,
+    FT5X0X_REG_MAX_Y_LOW                         = 0x9b,
+    FT5X0X_REG_K_X_HIGH                        = 0x9c,
+    FT5X0X_REG_K_X_LOW                         = 0x9d,
+    FT5X0X_REG_K_Y_HIGH                        = 0x9e,
+    FT5X0X_REG_K_Y_LOW                         = 0x9f,
+    FT5X0X_REG_AUTO_CLB_MODE            = 0xa0,
+    FT5X0X_REG_LIB_VERSION_H                 = 0xa1,
+    FT5X0X_REG_LIB_VERSION_L                 = 0xa2,        
+    FT5X0X_REG_CIPHER                        = 0xa3,
+    FT5X0X_REG_MODE                        = 0xa4,
+    FT5X0X_REG_PMODE                        = 0xa5,    /* Power Consume Mode        */    
+    FT5X0X_REG_FIRMID                        = 0xa6,
+    FT5X0X_REG_STATE                        = 0xa7,
+    FT5X0X_REG_FT5201ID                    = 0xa8,
+    FT5X0X_REG_ERR                        = 0xa9,
+    FT5X0X_REG_CLB                        = 0xaa,
+};
+ 
+//FT5X0X_REG_PMODE
+#define PMODE_ACTIVE        0x00
+#define PMODE_MONITOR       0x01
+#define PMODE_STANDBY       0x02
+#define PMODE_HIBERNATE     0x03
+ 
+ 
+    #ifndef ABS_MT_TOUCH_MAJOR
+    #define ABS_MT_TOUCH_MAJOR    0x30    /* touching ellipse */
+    #define ABS_MT_TOUCH_MINOR    0x31    /* (omit if circular) */
+    #define ABS_MT_WIDTH_MAJOR    0x32    /* approaching ellipse */
+    #define ABS_MT_WIDTH_MINOR    0x33    /* (omit if circular) */
+    #define ABS_MT_ORIENTATION    0x34    /* Ellipse orientation */
+    #define ABS_MT_POSITION_X    0x35    /* Center X ellipse position */
+    #define ABS_MT_POSITION_Y    0x36    /* Center Y ellipse position */
+    #define ABS_MT_TOOL_TYPE    0x37    /* Type of touching device */
+    #define ABS_MT_BLOB_ID        0x38    /* Group set of pkts as blob */
+    #endif /* ABS_MT_TOUCH_MAJOR */
+ 
+ 
+#endif
--- /dev/null
+++ b/drivers/input/touchscreen/ft5x0x.c
@@ -0,0 +1,715 @@
+/* 
+ * drivers/input/touchscreen/ft5x0x_ts.c
+ *
+ * FocalTech ft5x0x TouchScreen driver. 
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ *
+ *    note: only support mulititouch    Wenfs 2010-10-01
+ */
+
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/slab.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+ 
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+#endif
+
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include "ft5x06_ts.h"
+
+#if 0
+#define DEBUG 	1
+#define DEBUG_0 1
+#endif
+ 
+#ifdef DEBUG_0
+#define TS_DEBUG(fmt,args...) printk(fmt, ##args )
+#else
+#define TS_DEBUG(fmt,args...)
+#endif
+ 
+#ifdef DEBUG
+#define TS_DEBUG1(fmt,args...) printk(fmt, ##args )
+#else
+#define TS_DEBUG1(fmt,args...)
+#endif
+ 
+static struct i2c_client *this_client;
+static struct ft5x0x_ts_platform_data *ts_plat_data;
+ 
+struct ts_event {
+    u16    x1;
+    u16    y1;
+    u16    x2;
+    u16    y2;
+    u16    x3;
+    u16    y3;
+    u16    x4;
+    u16    y4;
+    u16    x5;
+    u16    y5;
+    u16    pressure;
+    s16 touch_ID1;
+    s16 touch_ID2;
+    s16 touch_ID3;
+    s16 touch_ID4;
+    s16 touch_ID5;
+    u8  touch_point;
+};
+ 
+struct ft5x0x_ts_data {
+    struct input_dev    *input_dev;
+    struct ts_event        event;
+
+    struct delayed_work     poll_work;
+    int stop_poll_flag;
+    struct work_struct     pen_event_work;
+    struct workqueue_struct *ts_workqueue;
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    struct early_suspend    early_suspend;
+#endif
+};
+ 
+static int ft5x0x_i2c_rxdata(char *rxdata, int length)
+{
+    int ret;
+ 
+    struct i2c_msg msgs[] = {
+        {
+            .addr    = this_client->addr,
+            .flags    = 0,
+            .len    = 1,
+            .buf    = rxdata,
+        },
+        {
+            .addr    = this_client->addr,
+            .flags    = I2C_M_RD,
+            .len    = length,
+            .buf    = rxdata,
+        },
+    };
+ 
+    //msleep(1);
+    ret = i2c_transfer(this_client->adapter, msgs, 2);
+    if (ret < 0)
+        pr_err("msg %s i2c read error: %d\n", __func__, ret);
+    
+    return ret;
+}
+
+static void ft5x0x_ts_release(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    //TS_DEBUG("ft5x0x_ts_release\n");
+
+	if (ts_plat_data->multi_touch) {
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+	} else {
+		input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+		input_report_key(data->input_dev, BTN_TOUCH, 0);
+	}
+    input_sync(data->input_dev);
+}
+ 
+static int ft5x0x_read_data(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    struct ts_event *event = &data->event;
+    u8 buf[32] = {0};
+    int ret = -1;
+    int status = 0;
+
+	if (ts_plat_data->multi_touch) {
+		ret = ft5x0x_i2c_rxdata(buf, 31);
+	} else {
+		ret = ft5x0x_i2c_rxdata(buf, 7);
+	}
+    if (ret < 0) {
+        printk("%s read_data i2c_rxdata failed: %d\n", __func__, ret);
+        return ret;
+    }
+ 
+    memset(event, 0, sizeof(struct ts_event));
+    event->touch_point = buf[2] & 0x07;// 000 0111
+ 
+    if (event->touch_point == 0) {
+        ft5x0x_ts_release();
+        return 1; 
+    }
+
+	if (ts_plat_data->multi_touch) {
+		switch (event->touch_point) {
+		case 5:
+			event->x5 = (s16)(buf[0x1b] & 0x0F)<<8 | (s16)buf[0x1c];
+			event->y5 = (s16)(buf[0x1d] & 0x0F)<<8 | (s16)buf[0x1e];
+			status = (s16)((buf[0x1b] & 0xc0) >> 6);
+			event->touch_ID5=(s16)(buf[0x1D] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 4:
+			event->x4 = (s16)(buf[0x15] & 0x0F)<<8 | (s16)buf[0x16];
+			event->y4 = (s16)(buf[0x17] & 0x0F)<<8 | (s16)buf[0x18];
+			status = (s16)((buf[0x15] & 0xc0) >> 6);
+			event->touch_ID4=(s16)(buf[0x17] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 3:
+			event->x3 = (s16)(buf[0x0f] & 0x0F)<<8 | (s16)buf[0x10];
+			event->y3 = (s16)(buf[0x11] & 0x0F)<<8 | (s16)buf[0x12];
+			status = (s16)((buf[0x0f] & 0xc0) >> 6);
+			event->touch_ID3=(s16)(buf[0x11] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 2:
+			event->x2 = (s16)(buf[9] & 0x0F)<<8 | (s16)buf[10];
+			event->y2 = (s16)(buf[11] & 0x0F)<<8 | (s16)buf[12];
+			status = (s16)((buf[0x9] & 0xc0) >> 6);
+			event->touch_ID2=(s16)(buf[0x0b] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+		case 1:
+			event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+			event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+			status = (s16)((buf[0x3] & 0xc0) >> 6);
+			event->touch_ID1=(s16)(buf[0x05] & 0xF0)>>4;
+			if (status == 1) {
+				ft5x0x_ts_release();
+			}
+			break;
+		default:
+			return -1;
+		}
+	} else {
+		if (event->touch_point == 1) {
+			event->x1 = (s16)(buf[3] & 0x0F)<<8 | (s16)buf[4];
+			event->y1 = (s16)(buf[5] & 0x0F)<<8 | (s16)buf[6];
+		}
+	}
+    event->pressure = 200;
+
+    dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+			event->x1, event->y1, event->x2, event->y2);
+ 
+    return 0;
+}
+ 
+static void ft5x0x_report_value(void)
+{
+    struct ft5x0x_ts_data *data = i2c_get_clientdata(this_client);
+    struct ts_event *event = &data->event;
+ 
+	TS_DEBUG("==ft5x0x_report_value =\n");
+
+	if (ts_plat_data->multi_touch) {
+		switch(event->touch_point) {
+		case 5:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID5);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x5);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y5);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 4:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID4);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x4);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y4);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 3:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID3);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x3);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y3);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 2:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID2);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x2);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y2);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+			TS_DEBUG("===x2 = %d,y2 = %d ====\n",event->x2,event->y2);
+		case 1:
+			input_report_abs(data->input_dev, ABS_MT_TRACKING_ID, event->touch_ID1);
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, event->pressure);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_X, event->x1);
+			input_report_abs(data->input_dev, ABS_MT_POSITION_Y, event->y1);
+			input_report_abs(data->input_dev, ABS_MT_WIDTH_MAJOR, 1);
+			input_mt_sync(data->input_dev);
+		default:
+			TS_DEBUG("==touch_point default =\n");
+			break;
+		}
+	} else {
+		if (event->touch_point == 1) {
+			input_report_abs(data->input_dev, ABS_X, event->x1);
+			input_report_abs(data->input_dev, ABS_Y, event->y1);
+			input_report_abs(data->input_dev, ABS_PRESSURE, event->pressure);
+		}
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+	}
+    input_sync(data->input_dev);
+ 
+    dev_dbg(&this_client->dev, "%s: 1:%d %d 2:%d %d \n", __func__,
+			event->x1, event->y1, event->x2, event->y2);
+    TS_DEBUG1("1:(%d, %d) 2:(%d, %d) 3:(%d, %d) 4:(%d, %d) 5:(%d, %d)\n", 
+			  event->x1, event->y1, event->x2, event->y2, event->x3, event->y3,
+			  event->x4, event->y4, event->x5, event->y5);
+}    /*end ft5x0x_report_value*/
+
+/* Added by Kevin, test only */
+static void ft5x0x_poll_work(struct work_struct *work)
+{
+    int ret = -1;
+	struct delayed_work* dwork = to_delayed_work(work);
+	struct ft5x0x_ts_data *ts_data = container_of(dwork, struct ft5x0x_ts_data, poll_work);
+
+    ret = ft5x0x_read_data();
+    if (ret == 0) {
+        ft5x0x_report_value();
+    }
+
+    if (!ts_data->stop_poll_flag) {
+        queue_delayed_work(ts_data->ts_workqueue, &ts_data->poll_work, 2);
+    } else {
+        printk(KERN_ERR"stop polling...\n");
+    }
+}
+
+static void ft5x0x_ts_pen_irq_work(struct work_struct *work)
+{
+    int ret = -1;
+ 
+    TS_DEBUG("==work 1=\n");
+    ret = ft5x0x_read_data();    
+    if (ret == 0) {    
+        ft5x0x_report_value();
+    }
+    else
+        TS_DEBUG("data package read error\n");
+    TS_DEBUG("==work 2=\n");
+}
+
+static irqreturn_t ft5x0x_ts_interrupt(int irq, void *dev_id)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts = dev_id;
+ 
+    TS_DEBUG("==int ft5x0x_ts_interrupt=\n");
+    if (!work_pending(&ft5x0x_ts->pen_event_work)) {
+        queue_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->pen_event_work);
+    }
+ 
+    return IRQ_HANDLED;
+}
+ 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void ft5x0x_ts_suspend(struct early_suspend *handler)
+{
+	//    struct ft5x0x_ts_data *ts;
+	//    ts =  container_of(handler, struct ft5x0x_ts_data, early_suspend);
+ 
+    TS_DEBUG("==ft5x0x_ts_suspend=\n");
+	//    disable_irq(this_client->irq);
+	//    disable_irq(IRQ_EINT(6));
+	//    cancel_work_sync(&ts->pen_event_work);
+	//    flush_workqueue(ts->ts_workqueue);
+    // ==set mode ==, 
+	//        ft5x0x_set_reg(FT5X0X_REG_PMODE, PMODE_HIBERNATE);
+}
+ 
+static void ft5x0x_ts_resume(struct early_suspend *handler)
+{
+    TS_DEBUG("==ft5x0x_ts_resume=\n");
+    // wake the mode
+	//    __gpio_as_output(GPIO_FT5X0X_WAKE);        
+	//    __gpio_clear_pin(GPIO_FT5X0X_WAKE);        //set wake = 0,base on system
+	//     msleep(100);
+	//    __gpio_set_pin(GPIO_FT5X0X_WAKE);            //set wake = 1,base on system
+	//    msleep(100);
+	//    enable_irq(this_client->irq);
+	//    enable_irq(IRQ_EINT(6));
+}
+#endif  //CONFIG_HAS_EARLYSUSPEND
+
+/* Parse the ft5x0x from device tree, MYiR */
+#if defined(CONFIG_OF)
+static const struct of_device_id ft5x0x_ts_match[];
+
+static struct ft5x0x_ts_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	struct ft5x0x_ts_platform_data *pdata;
+	struct device_node *np = dev->of_node;
+	const struct of_device_id *match;
+
+	match = of_match_device(of_match_ptr(ft5x0x_ts_match), dev);
+	if (!match)
+		return ERR_PTR(-EINVAL);
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	if (of_property_read_u8(np, "polling_mode", &pdata->polling_mode)) {
+		dev_err(dev, "Failed to get polling_mode property, set to 0\n");
+		pdata->polling_mode = 0;
+	}
+
+	if (of_property_read_u8(np, "multi_touch", &pdata->multi_touch)) {
+		dev_err(dev, "Failed to get multi_touch property, set to 0\n");
+		pdata->multi_touch = 0;
+	}
+
+	pdata->tp_int = of_get_named_gpio_flags(np, "tp_int", 0, NULL);
+	if (gpio_is_valid(pdata->tp_int)) {	
+		//printk("tp int gpio=%d\n", pdata->tp_int);
+		if (gpio_request(pdata->tp_int, "touch irq")) {
+			printk("request touch gpio[%d] err\n", pdata->tp_int);
+			pdata->tp_int = -1;
+		} else {
+			pdata->irq = gpio_to_irq(pdata->tp_int);
+			//printk("touch tp_int irq=%d\n", pdata->irq);
+		}
+	}
+	
+	pdata->tp_resetn = of_get_named_gpio_flags(np, "tp_resetn", 0, NULL);
+	printk("tp reset gpio=%d\n", pdata->tp_resetn);
+
+	TS_DEBUG("ft5x0x detected, polling_mode: %d, multi_touch: %d\n",
+			pdata->polling_mode, pdata->multi_touch);
+
+	dev_dbg(dev, "ft5x0x detected, polling_mode: %d, multi_touch: %d\n",
+			pdata->polling_mode, pdata->multi_touch);
+
+	return pdata;
+}
+#else
+static struct ft5x0x_ts_platform_data *ft5x0x_parse_dt(struct device *dev)
+{
+	return NULL;
+}
+#endif
+
+static int 
+ft5x0x_ts_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts;
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+    struct input_dev *input_dev;
+    int err = 0;
+    
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        err = -ENODEV;
+        goto exit_check_functionality_failed;
+    }
+
+	/*
+	 * Add by JBO
+	 * Use platform data to initialize ft5x0x
+	 */
+	this_client = client;
+	ts_plat_data = dev_get_platdata(&client->dev);
+	if (np) {
+		ts_plat_data = ft5x0x_parse_dt(dev);
+		if (IS_ERR(ts_plat_data))
+			goto exit_get_platdata_failed;
+
+		if (client->irq && !ts_plat_data->irq) {
+			ts_plat_data->irq = client->irq;
+		} else {
+			client->irq = ts_plat_data->irq;
+		}
+	} else if (!ts_plat_data)
+		goto exit_get_platdata_failed;
+
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		err = gpio_request(ts_plat_data->tp_resetn, "tp_resetn");
+		if (!err) {
+			gpio_direction_output(ts_plat_data->tp_resetn, 1);
+			gpio_export(ts_plat_data->tp_resetn, 0);
+			// may be you need some delay here
+		} else {
+			printk("request tp_resetn[gpio %d] err:%d\n", 
+					ts_plat_data->tp_resetn, err);
+		}
+	}
+	//  Read device ID
+    err = 0xa1;
+    if (ft5x0x_i2c_rxdata((char *)&err, 2) < 0) {
+    	printk(KERN_ERR"ft5x0x read ID error!\n");
+		goto exit_check_functionality_failed;
+    }
+    printk(KERN_ERR "ft5x0x id: 0x%04X\n", err);
+    err = 0;
+
+    TS_DEBUG("==kzalloc=\n");
+    ft5x0x_ts = kzalloc(sizeof(*ft5x0x_ts), GFP_KERNEL);
+    if (!ft5x0x_ts)    {
+        err = -ENOMEM;
+        goto exit_alloc_data_failed;
+    }
+ 
+    TS_DEBUG("==i2c_set_clientdata=\n");
+	//    this_client = client;
+    i2c_set_clientdata(client, ft5x0x_ts);
+	//    i2c_jz_setclk(client, 100*1000);
+ 
+    TS_DEBUG("==INIT_WORK=\n");
+
+	if (ts_plat_data->polling_mode) {
+		/* Added by Kevin, test only */
+		TS_DEBUG("poll mode\n");	
+		INIT_DELAYED_WORK(&ft5x0x_ts->poll_work, ft5x0x_poll_work);
+		ft5x0x_ts->stop_poll_flag = 0;
+	} else {
+		INIT_WORK(&ft5x0x_ts->pen_event_work, ft5x0x_ts_pen_irq_work);
+	}
+
+    TS_DEBUG("==create_singlethread_workqueue=\n");
+    ft5x0x_ts->ts_workqueue = create_singlethread_workqueue(dev_name(&client->dev));
+    if (!ft5x0x_ts->ts_workqueue) {
+        err = -ESRCH;
+        goto exit_create_singlethread;
+    }
+
+	if (!ts_plat_data->polling_mode) {
+		err = request_irq(ts_plat_data->irq, ft5x0x_ts_interrupt, 
+				 IRQF_TRIGGER_FALLING, "ft5x0x_ts", ft5x0x_ts);
+		if (err < 0) {
+			dev_err(&client->dev, "ft5x0x_probe: request irq failed\n");
+			goto exit_irq_request_failed;
+		}
+	}
+
+    TS_DEBUG("==input_allocate_device=\n");
+    input_dev = input_allocate_device();
+    if (!input_dev) {
+        err = -ENOMEM;
+        dev_err(&client->dev, "failed to allocate input device\n");
+        goto exit_input_dev_alloc_failed;
+    }
+    
+    ft5x0x_ts->input_dev = input_dev;
+
+	if (ts_plat_data->multi_touch) {
+		set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+		set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+		set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+		set_bit(ABS_MT_WIDTH_MAJOR, input_dev->absbit);
+ 
+		input_set_abs_params(input_dev,
+							 ABS_MT_POSITION_X, 0, SCREEN_MAX_X, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_POSITION_Y, 0, SCREEN_MAX_Y, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_TOUCH_MAJOR, 0, PRESS_MAX, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_MT_WIDTH_MAJOR, 0, 200, 0, 0);
+	} else {
+		set_bit(ABS_X, input_dev->absbit);
+		set_bit(ABS_Y, input_dev->absbit);
+		set_bit(ABS_PRESSURE, input_dev->absbit);
+		set_bit(BTN_TOUCH, input_dev->keybit);
+ 
+		input_set_abs_params(input_dev, ABS_X, 0, SCREEN_MAX_X, 0, 0);
+		input_set_abs_params(input_dev, ABS_Y, 0, SCREEN_MAX_Y, 0, 0);
+		input_set_abs_params(input_dev,
+							 ABS_PRESSURE, 0, PRESS_MAX, 0 , 0);
+	}
+ 
+    set_bit(EV_ABS, input_dev->evbit);
+    set_bit(EV_KEY, input_dev->evbit);
+ 
+    input_dev->name        = FT5X0X_NAME;        //dev_name(&client->dev)
+    err = input_register_device(input_dev);
+    if (err) {
+        dev_err(&client->dev,
+				"ft5x0x_ts_probe: failed to register input device: %s\n",
+				dev_name(&client->dev));
+        goto exit_input_register_device_failed;
+    }
+ 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    TS_DEBUG("==register_early_suspend =\n");
+    ft5x0x_ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
+    ft5x0x_ts->early_suspend.suspend = ft5x0x_ts_suspend;
+    ft5x0x_ts->early_suspend.resume    = ft5x0x_ts_resume;
+    register_early_suspend(&ft5x0x_ts->early_suspend);
+#endif
+	//wake the CTPM
+	//    __gpio_as_output(GPIO_FT5X0X_WAKE);        
+	//    __gpio_clear_pin(GPIO_FT5X0X_WAKE);        //set wake = 0,base on system
+	//     msleep(100);
+	//    __gpio_set_pin(GPIO_FT5X0X_WAKE);            //set wake = 1,base on system
+	//    msleep(100);
+	//    ft5x0x_set_reg(0x88, 0x05); //5, 6,7,8
+	//    ft5x0x_set_reg(0x80, 30);
+	//    msleep(50);
+
+	if (!ts_plat_data->polling_mode) {
+		//   enable_irq(this_client->irq);
+		//    enable_irq(IRQ_EINT(6));
+
+	} else {
+		/* Added by Kevin, test only */
+		TS_DEBUG("queue delay work\n");	
+		queue_delayed_work(ft5x0x_ts->ts_workqueue, &ft5x0x_ts->poll_work, 2); 
+	}
+
+    TS_DEBUG("==probe over =, this_client->irq=%d\n\n\n", ts_plat_data->irq);
+    return 0;
+ 
+ exit_input_register_device_failed:
+    input_free_device(input_dev);
+ exit_input_dev_alloc_failed:
+	if (!ts_plat_data->polling_mode)
+		free_irq(ts_plat_data->irq, ft5x0x_ts);
+	//    free_irq(IRQ_EINT(6), ft5x0x_ts);
+ exit_irq_request_failed:
+
+	//exit_platform_data_null:
+	if (!ts_plat_data->polling_mode)
+		cancel_delayed_work_sync(&ft5x0x_ts->poll_work);
+	else
+		cancel_work_sync(&ft5x0x_ts->pen_event_work);
+
+    destroy_workqueue(ft5x0x_ts->ts_workqueue);
+ exit_create_singlethread:
+    TS_DEBUG("==singlethread error =\n\n\n");
+    i2c_set_clientdata(client, NULL);
+    kfree(ft5x0x_ts);
+ exit_alloc_data_failed:
+ exit_get_platdata_failed:
+ 	if (gpio_is_valid(ts_plat_data->tp_int)) {
+ 		gpio_free(ts_plat_data->tp_int);
+ 	}
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		gpio_free(ts_plat_data->tp_resetn);
+	}
+ exit_check_functionality_failed:
+    return err;
+}
+ 
+static int ft5x0x_ts_remove(struct i2c_client *client)
+{
+    struct ft5x0x_ts_data *ft5x0x_ts = i2c_get_clientdata(client);
+    TS_DEBUG("==ft5x0x_ts_remove=\n");
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    unregister_early_suspend(&ft5x0x_ts->early_suspend);
+#endif
+
+	if (!ts_plat_data->polling_mode) {
+		printk("free irq %d\n", client->irq);
+		free_irq(client->irq, ft5x0x_ts);
+		cancel_work_sync(&ft5x0x_ts->pen_event_work);
+	} else {
+		/* Added by Kevin, test only */
+		ft5x0x_ts->stop_poll_flag = 1;
+		cancel_delayed_work_sync(&ft5x0x_ts->poll_work);
+	}
+    destroy_workqueue(ft5x0x_ts->ts_workqueue);
+    i2c_set_clientdata(client, NULL);
+
+    input_unregister_device(ft5x0x_ts->input_dev);
+    kfree(ft5x0x_ts);
+	
+	if (gpio_is_valid(ts_plat_data->tp_resetn)) {
+		printk("gpio free %d\n", ts_plat_data->tp_resetn);
+		gpio_free(ts_plat_data->tp_resetn);
+	}
+
+    if (gpio_is_valid(ts_plat_data->tp_int)) {
+    	printk("gpio free %d\n", ts_plat_data->tp_int);
+    	gpio_free(ts_plat_data->tp_int);
+    }
+    return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id ft5x0x_ts_match[] = {
+	{ .compatible = FT5X0X_NAME, },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ft5x0x_ts_match);
+#endif
+
+static const struct i2c_device_id ft5x0x_ts_id[] = {
+    { FT5X0X_NAME, 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ft5x0x_ts_id);
+
+static struct i2c_driver ft5x0x_ts_driver = {
+    .probe        = ft5x0x_ts_probe,
+    .remove        = ft5x0x_ts_remove,
+    .id_table    = ft5x0x_ts_id,
+    .driver    = {
+        .name    = FT5X0X_NAME,
+		.owner    = THIS_MODULE,
+		.of_match_table = of_match_ptr(ft5x0x_ts_match),
+    },
+};
+
+static int __init ft5x0x_ts_init(void)
+{
+	int err = 0;
+	
+	if (i2c_add_driver(&ft5x0x_ts_driver) != 0) {
+		printk("i2c_add_driver: can't add i2c driver\n");
+		err = -ENODEV;
+		goto err_driver;
+	}
+
+	printk("ft5x0x_ts_init successful\n");
+	
+	return 0;
+
+ err_driver:
+	printk("ft5x0x_ts_init fail\n");
+	return err;
+}
+
+static void __exit ft5x0x_ts_exit(void)
+{
+	i2c_del_driver(&ft5x0x_ts_driver);
+	this_client = NULL;
+}
+
+ 
+module_init(ft5x0x_ts_init);
+module_exit(ft5x0x_ts_exit);
+ 
+MODULE_AUTHOR("Kevin Su<kevin.su@myirtech.com>");
+MODULE_DESCRIPTION("FocalTech ft5x0x TouchScreen driver");
+MODULE_LICENSE("GPL");
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -1155,4 +1155,15 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called bu21023_ts.
 
+config TOUCHSCREEN_FT5X0X
+	tristate "FT5X0X touchscreens"
+	depends on I2C
+	help
+	  Say Y here if you have a touchscreen using the ft5x0x chip
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called zforce_ts.	  
+
 endif
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -93,5 +93,6 @@
 obj-$(CONFIG_TOUCHSCREEN_SX8654)	+= sx8654.o
 obj-$(CONFIG_TOUCHSCREEN_TPS6507X)	+= tps6507x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ZFORCE)	+= zforce_ts.o
+obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x.o
 obj-$(CONFIG_TOUCHSCREEN_COLIBRI_VF50)	+= colibri-vf50-ts.o
 obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+= rohm_bu21023.o
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -816,6 +816,13 @@
 
 	  If unsure, say N
 
+config MYIR_STLM75X
+	tristate "MYIR stlm75x temperature sensor"
+	depends on ARCH_ZYNQ
+	    default y
+	help
+	  This option enables support for the stlm75x temperature driver.
+
 source "drivers/misc/jesd204b/Kconfig"
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -56,6 +56,7 @@
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
 obj-$(CONFIG_ECHO)		+= echo/
+obj-$(CONFIG_MYIR_STLM75X)<--->+= myir_stlm75x.o /
 obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
 obj-$(CONFIG_CXL_BASE)		+= cxl/
 obj-$(CONFIG_PANEL)             += panel.o
--- /dev/null
+++ b/drivers/misc/myir_stlm75x.c
@@ -0,0 +1,249 @@
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+//#include <linux/sysdev.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/kdev_t.h>
+#include <linux/i2c.h>
+
+#define DEV_NAME		"myir-stlm75x"
+
+/*********************
+ *	Register define  *
+ *********************/
+#define REG_TEMP	0x0
+#define REG_CON		0x1
+#define REG_TOS		0x2
+#define REG_THYS	0x3
+
+#define MAX_CONV_MS	150
+#define SIGN_MASK	(0x1 << 15)
+#define TEMP_SHIFT	7
+#define TEMP_MASK	(0xFF << TEMP_SHIFT)
+#define DEGREE_PER_CNT	0.5
+
+struct myir_stlm75x_data {
+	struct i2c_client *client;
+	struct class class;
+	struct mutex mutex;
+	u16 temp_tos;
+	u16 temp_thys;
+	u16 temp_value;
+};
+
+inline int to_readable_value(u16 _value)
+{
+	int value;
+	if (_value & SIGN_MASK) {
+		value = -(~((_value & TEMP_MASK) >> TEMP_SHIFT) + 1);
+	} else {
+		value = ((_value & TEMP_MASK) >> TEMP_SHIFT);
+	}
+//	printk(KERN_ERR "value to read: %d\n", value);
+	return value;
+}
+
+#if 0
+inline u16 to_register_value(int/*float*/ degreex2)
+{
+	u16 ret;
+	if (degreex2 > 255) {
+		degreex2 = 255;
+	} else if (degreex2 < -255) {
+		degreex2 = -255;
+	}
+	ret = (u16)degreex2;
+	if (degreex2 >= 0) {
+		ret = (ret << TEMP_SHIFT) & TEMP_MASK;
+	} else {
+		ret = (ret << TEMP_SHIFT) & 0xFFFF;
+	}
+	printk(KERN_ERR "value to write: %#X\n", ret);
+	return ret;
+}
+#endif
+
+static int myir_stlm75x_readwrite(struct i2c_client *client,
+                   u16 wr_len, u8 *wr_buf,
+                   u16 rd_len, u8 *rd_buf)
+{
+    struct i2c_msg wrmsg[2];
+    int i = 0;
+    int ret;
+
+    if (wr_len) {
+        wrmsg[i].addr  = client->addr;
+        wrmsg[i].flags = 0;
+        wrmsg[i].len = wr_len;
+        wrmsg[i].buf = wr_buf;
+        i++;
+    }
+    if (rd_len) {
+        wrmsg[i].addr  = client->addr;
+        wrmsg[i].flags = I2C_M_RD;
+        wrmsg[i].len = rd_len;
+        wrmsg[i].buf = rd_buf;
+        i++;
+    }
+
+    ret = i2c_transfer(client->adapter, wrmsg, i);
+    if (ret < 0)
+        return ret;
+    if (ret != i)
+        return -EIO;
+
+    return 0;
+}
+
+static int myir_stlm75x_write_word(struct myir_stlm75x_data *pdata,
+                     u8 addr, u16 value)
+{
+    u8 wrbuf[3]={0};
+
+    wrbuf[0] = addr;
+    wrbuf[1] = (value>>8)&0xFF;
+    wrbuf[2] = value&0xFF;
+
+    return myir_stlm75x_readwrite(pdata->client, 3, wrbuf, 0, NULL);
+}
+
+static int myir_stlm75x_write_byte(struct myir_stlm75x_data *pdata,
+                     u8 addr, u8 value)
+{
+    u8 wrbuf[2]={0};
+
+    wrbuf[0] = addr;
+    wrbuf[1] = value;
+
+    return myir_stlm75x_readwrite(pdata->client, 2, wrbuf, 0, NULL);
+}
+
+static int myir_stlm75x_read_word(struct myir_stlm75x_data *pdata,
+                    u8 addr)
+{
+    u8 wrbuf[2], rdbuf[2]={0};
+    int error;
+
+    wrbuf[0] = addr;
+
+    error = myir_stlm75x_readwrite(pdata->client, 1, wrbuf, 2, rdbuf);
+    if (error)
+        return error;
+
+    return rdbuf[0]<<8|rdbuf[1];
+}
+
+static int myir_stlm75x_read_byte(struct myir_stlm75x_data *pdata,
+                    u8 addr)
+{
+    u8 wrbuf[2], rdbuf[2]={0};
+    int error;
+
+    wrbuf[0] = addr;
+
+    error = myir_stlm75x_readwrite(pdata->client, 1, wrbuf, 1, rdbuf);
+    if (error)
+        return error;
+
+    return rdbuf[0];
+}
+
+/* class attribute show function. */
+static ssize_t myir_stlm75x_show(struct class *cls, struct class_attribute *attr, char *buf)
+{
+	struct myir_stlm75x_data *pdata = (struct myir_stlm75x_data *)container_of(cls, struct myir_stlm75x_data, class);
+	int ret;
+	int value;
+	unsigned long start_time;
+	
+	mutex_lock(&pdata->mutex);
+	
+	start_time = jiffies;
+	pdata->temp_value = myir_stlm75x_read_word(pdata, REG_TEMP);
+//	printk(KERN_ERR "pdata->temp_value: %#X", pdata->temp_value);
+	value = to_readable_value(pdata->temp_value);
+	ret = sprintf(buf, "%d.%s\n", value/2, value%2?"5":"0");
+
+	while (time_before(jiffies, start_time + msecs_to_jiffies(MAX_CONV_MS))) schedule();
+	
+	mutex_unlock(&pdata->mutex);
+	
+	return ret;
+}
+
+/* Attributes declaration: Here I have declared only one attribute attr1 */
+static struct class_attribute myir_stlm75x_class_attrs[] = {
+	__ATTR(value_degree, S_IRUGO | S_IWUSR , myir_stlm75x_show, NULL), //use macro for permission
+	__ATTR_NULL
+};
+
+static int myir_stlm75x_probe(struct i2c_client *client,
+                     const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct myir_stlm75x_data *pdata = NULL;
+	
+	printk(KERN_ALERT "%s()\n", __func__);
+	
+	pdata = kmalloc(sizeof(struct myir_stlm75x_data), GFP_KERNEL);
+	if(!pdata) {
+		printk(KERN_ERR "No memory!\n");
+		return -ENOMEM;
+	}
+	memset(pdata, 0, sizeof(struct myir_stlm75x_data));
+
+	pdata->client = client;
+	
+	/* Init class */
+	mutex_init(&pdata->mutex);
+	pdata->class.name = DEV_NAME;
+	pdata->class.owner = THIS_MODULE;
+	pdata->class.class_attrs = myir_stlm75x_class_attrs;
+	ret = class_register(&pdata->class);
+	if(ret) {
+		printk(KERN_ERR "class_register failed!\n");
+		goto class_register_fail;
+	}
+	i2c_set_clientdata(client, pdata);
+	
+	printk(KERN_ALERT "%s driver initialized successfully!\n", DEV_NAME);
+	return 0;
+
+class_register_fail:
+	
+	return ret;
+}
+
+static int myir_stlm75x_remove(struct i2c_client *client)
+{
+    struct myir_stlm75x_data *pdata = i2c_get_clientdata(client);
+	
+	class_unregister(&pdata->class);
+	kfree(pdata);
+	i2c_set_clientdata(client, NULL);
+    return 0;
+}
+
+static const struct i2c_device_id myir_stlm75x_id[] = {
+    { DEV_NAME, 0 },
+    { }
+};
+
+static struct i2c_driver myir_stlm75x_driver = {
+    .driver = {
+        .owner	= THIS_MODULE,
+        .name	= DEV_NAME,
+    },
+    .id_table	= myir_stlm75x_id,
+    .probe		= myir_stlm75x_probe,
+    .remove		= myir_stlm75x_remove,
+};
+
+module_i2c_driver(myir_stlm75x_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Su <kevin.su@myirtech.com>");
+MODULE_DESCRIPTION("MYIR stlm75x temperature driver.");
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -30,6 +30,10 @@
 
 source "drivers/video/backlight/Kconfig"
 
+# Added by MYRI 
+source "drivers/video/xylon/Kconfig"
+source "drivers/video/sii902x/Kconfig"
+
 config VGASTATE
        tristate
        default n
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -7,6 +7,9 @@
 
 obj-y				  += fbdev/
 
+obj-$(CONFIG_FB_XYLON)	+= xylon/
+obj-$(CONFIG_MYIR_SII902X)		+= sii902x/
+
 obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
 ifeq ($(CONFIG_OF),y)
 obj-$(CONFIG_VIDEOMODE_HELPERS) += of_display_timing.o of_videomode.o
--- /dev/null
+++ b/drivers/video/sii902x/edid.h
@@ -0,0 +1,138 @@
+/* 
+ * edid.h - EDID/DDC Header
+ *
+ * Based on:
+ *   1. XFree86 4.3.0, edid.h
+ *      Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ * 
+ *   2. John Fremlin <vii@users.sourceforge.net> and 
+ *      Ani Joshi <ajoshi@unixbox.com>
+ *
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+*/
+
+#ifndef __EDID_H__
+#define __EDID_H__
+
+#define EDID_LENGTH				0x80
+#define EDID_HEADER				0x00
+#define EDID_HEADER_END				0x07
+
+#define ID_MANUFACTURER_NAME			0x08
+#define ID_MANUFACTURER_NAME_END		0x09
+#define ID_MODEL				0x0a
+
+#define ID_SERIAL_NUMBER			0x0c
+
+#define MANUFACTURE_WEEK			0x10
+#define MANUFACTURE_YEAR			0x11
+
+#define EDID_STRUCT_VERSION			0x12
+#define EDID_STRUCT_REVISION			0x13
+
+#define EDID_STRUCT_DISPLAY                     0x14
+
+#define DPMS_FLAGS				0x18
+#define ESTABLISHED_TIMING_1			0x23
+#define ESTABLISHED_TIMING_2			0x24
+#define MANUFACTURERS_TIMINGS			0x25
+
+/* standard timings supported */
+#define STD_TIMING                              8
+#define STD_TIMING_DESCRIPTION_SIZE             2
+#define STD_TIMING_DESCRIPTIONS_START           0x26
+
+#define DETAILED_TIMING_DESCRIPTIONS_START	0x36
+#define DETAILED_TIMING_DESCRIPTION_SIZE	18
+#define NO_DETAILED_TIMING_DESCRIPTIONS		4
+
+#define DETAILED_TIMING_DESCRIPTION_1		0x36
+#define DETAILED_TIMING_DESCRIPTION_2		0x48
+#define DETAILED_TIMING_DESCRIPTION_3		0x5a
+#define DETAILED_TIMING_DESCRIPTION_4		0x6c
+
+#define DESCRIPTOR_DATA				5
+
+#define UPPER_NIBBLE( x ) \
+        (((128|64|32|16) & (x)) >> 4)
+
+#define LOWER_NIBBLE( x ) \
+        ((1|2|4|8) & (x))
+
+#define COMBINE_HI_8LO( hi, lo ) \
+        ( (((unsigned)hi) << 8) | (unsigned)lo )
+
+#define COMBINE_HI_4LO( hi, lo ) \
+        ( (((unsigned)hi) << 4) | (unsigned)lo )
+
+#define PIXEL_CLOCK_LO     (unsigned)block[ 0 ]
+#define PIXEL_CLOCK_HI     (unsigned)block[ 1 ]
+#define PIXEL_CLOCK	   (COMBINE_HI_8LO( PIXEL_CLOCK_HI,PIXEL_CLOCK_LO )*10000)
+#define H_ACTIVE_LO        (unsigned)block[ 2 ]
+#define H_BLANKING_LO      (unsigned)block[ 3 ]
+#define H_ACTIVE_HI        UPPER_NIBBLE( (unsigned)block[ 4 ] )
+#define H_ACTIVE           COMBINE_HI_8LO( H_ACTIVE_HI, H_ACTIVE_LO )
+#define H_BLANKING_HI      LOWER_NIBBLE( (unsigned)block[ 4 ] )
+#define H_BLANKING         COMBINE_HI_8LO( H_BLANKING_HI, H_BLANKING_LO )
+
+#define V_ACTIVE_LO        (unsigned)block[ 5 ]
+#define V_BLANKING_LO      (unsigned)block[ 6 ]
+#define V_ACTIVE_HI        UPPER_NIBBLE( (unsigned)block[ 7 ] )
+#define V_ACTIVE           COMBINE_HI_8LO( V_ACTIVE_HI, V_ACTIVE_LO )
+#define V_BLANKING_HI      LOWER_NIBBLE( (unsigned)block[ 7 ] )
+#define V_BLANKING         COMBINE_HI_8LO( V_BLANKING_HI, V_BLANKING_LO )
+
+#define H_SYNC_OFFSET_LO   (unsigned)block[ 8 ]
+#define H_SYNC_WIDTH_LO    (unsigned)block[ 9 ]
+
+#define V_SYNC_OFFSET_LO   UPPER_NIBBLE( (unsigned)block[ 10 ] )
+#define V_SYNC_WIDTH_LO    LOWER_NIBBLE( (unsigned)block[ 10 ] )
+
+#define V_SYNC_WIDTH_HI    ((unsigned)block[ 11 ] & (1|2))
+#define V_SYNC_OFFSET_HI   (((unsigned)block[ 11 ] & (4|8)) >> 2)
+
+#define H_SYNC_WIDTH_HI    (((unsigned)block[ 11 ] & (16|32)) >> 4)
+#define H_SYNC_OFFSET_HI   (((unsigned)block[ 11 ] & (64|128)) >> 6)
+
+#define V_SYNC_WIDTH       COMBINE_HI_4LO( V_SYNC_WIDTH_HI, V_SYNC_WIDTH_LO )
+#define V_SYNC_OFFSET      COMBINE_HI_4LO( V_SYNC_OFFSET_HI, V_SYNC_OFFSET_LO )
+
+#define H_SYNC_WIDTH       COMBINE_HI_8LO( H_SYNC_WIDTH_HI, H_SYNC_WIDTH_LO )
+#define H_SYNC_OFFSET      COMBINE_HI_8LO( H_SYNC_OFFSET_HI, H_SYNC_OFFSET_LO )
+
+#define H_SIZE_LO          (unsigned)block[ 12 ]
+#define V_SIZE_LO          (unsigned)block[ 13 ]
+
+#define H_SIZE_HI          UPPER_NIBBLE( (unsigned)block[ 14 ] )
+#define V_SIZE_HI          LOWER_NIBBLE( (unsigned)block[ 14 ] )
+
+#define H_SIZE             COMBINE_HI_8LO( H_SIZE_HI, H_SIZE_LO )
+#define V_SIZE             COMBINE_HI_8LO( V_SIZE_HI, V_SIZE_LO )
+
+#define H_BORDER           (unsigned)block[ 15 ]
+#define V_BORDER           (unsigned)block[ 16 ]
+
+#define FLAGS              (unsigned)block[ 17 ]
+
+#define INTERLACED         (FLAGS&128)
+#define SYNC_TYPE          (FLAGS&3<<3)	/* bits 4,3 */
+#define SYNC_SEPARATE      (3<<3)
+#define HSYNC_POSITIVE     (FLAGS & 4)
+#define VSYNC_POSITIVE     (FLAGS & 2)
+
+#define V_MIN_RATE              block[ 5 ]
+#define V_MAX_RATE              block[ 6 ]
+#define H_MIN_RATE              block[ 7 ]
+#define H_MAX_RATE              block[ 8 ]
+#define MAX_PIXEL_CLOCK         (((int)block[ 9 ]) * 10)
+#define GTF_SUPPORT		block[10]
+
+#define DPMS_ACTIVE_OFF		(1 << 5)
+#define DPMS_SUSPEND		(1 << 6)
+#define DPMS_STANDBY		(1 << 7)
+
+#endif /* __EDID_H__ */
--- /dev/null
+++ b/drivers/video/sii902x/Kconfig
@@ -0,0 +1,15 @@
+menuconfig MYIR_SII902X
+	bool "MYIR sii902x HDMI driver support"
+	depends on FB
+	default y
+	help
+	  Choose this option if you want to use the MYIR sii902x hdmi
+	  for video output.
+	  
+config SII902X_EDID_READING
+	bool "Auto set videomode by reading monitor EDID (untested)"
+	depends on MYIR_SII902X
+	default n
+	help
+	  Choose this to enable videomode auto set by reading
+	  monitor EDID. Use system default videomode if unchecked.
--- /dev/null
+++ b/drivers/video/sii902x/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_SII902X_EDID_READING)	+= myir_edid.o
+obj-$(CONFIG_MYIR_SII902X) += myir_sii902x.o
--- /dev/null
+++ b/drivers/video/sii902x/myir_edid.c
@@ -0,0 +1,768 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file myir_edid.c
+ *
+ * @brief MYIR EDID driver
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/i2c.h>
+#include <linux/fb.h>
+#include "myir_edid.h"
+#include "edid.h"
+
+#define DEBUG	1  /* define this for verbose EDID parsing output */
+#ifdef DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_INFO fmt, ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+const struct fb_videomode myir_cea_mode[64] = {
+	/* #1: 640x480p@59.94/60Hz 4:3 */
+	[1] = {
+		NULL, 60, 640, 480, 39722, 48, 16, 33, 10, 96, 2, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #2: 720x480p@59.94/60Hz 4:3 */
+	[2] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #3: 720x480p@59.94/60Hz 16:9 */
+	[3] = {
+		NULL, 60, 720, 480, 37037, 60, 16, 30, 9, 62, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #4: 1280x720p@59.94/60Hz 16:9 */
+	[4] = {
+		NULL, 60, 1280, 720, 13468, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #5: 1920x1080i@59.94/60Hz 16:9 */
+	[5] = {
+		NULL, 60, 1920, 1080, 13763, 148, 88, 15, 2, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #6: 720(1440)x480iH@59.94/60Hz 4:3 */
+	[6] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #7: 720(1440)x480iH@59.94/60Hz 16:9 */
+	[7] = {
+		NULL, 60, 1440, 480, 18554/*37108*/, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #8: 720(1440)x240pH@59.94/60Hz 4:3 */
+	[8] = {
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #9: 720(1440)x240pH@59.94/60Hz 16:9 */
+	[9] = {
+		NULL, 60, 1440, 240, 37108, 114, 38, 15, 4, 124, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #14: 1440x480p@59.94/60Hz 4:3 */
+	[14] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #15: 1440x480p@59.94/60Hz 16:9 */
+	[15] = {
+		NULL, 60, 1440, 480, 18500, 120, 32, 30, 9, 124, 6, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #16: 1920x1080p@60Hz 16:9 */
+	[16] = {
+		NULL, 60, 1920, 1080, 6734, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #17: 720x576pH@50Hz 4:3 */
+	[17] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #18: 720x576pH@50Hz 16:9 */
+	[18] = {
+		NULL, 50, 720, 576, 37037, 68, 12, 39, 5, 64, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #19: 1280x720p@50Hz */
+	[19] = {
+		NULL, 50, 1280, 720, 13468, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #20: 1920x1080i@50Hz */
+	[20] = {
+		NULL, 50, 1920, 1080, 13480, 148, 528, 15, 5, 528, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_INTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #23: 720(1440)x288pH@50Hz 4:3 */
+	[23] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #24: 720(1440)x288pH@50Hz 16:9 */
+	[24] = {
+		NULL, 50, 1440, 288, 37037, 138, 24, 19, 2, 126, 3, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #29: 720(1440)x576pH@50Hz 4:3 */
+	[29] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_4_3, 0,
+	},
+	/* #30: 720(1440)x576pH@50Hz 16:9 */
+	[30] = {
+		NULL, 50, 1440, 576, 18518, 136, 24, 39, 5, 128, 5, 0,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #31: 1920x1080p@50Hz */
+	[31] = {
+		NULL, 50, 1920, 1080, 6734, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #32: 1920x1080p@23.98/24Hz */
+	[32] = {
+		NULL, 24, 1920, 1080, 13468, 148, 638, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #33: 1920x1080p@25Hz */
+	[33] = {
+		NULL, 25, 1920, 1080, 13468, 148, 528, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #34: 1920x1080p@30Hz */
+	[34] = {
+		NULL, 30, 1920, 1080, 13468, 148, 88, 36, 4, 44, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0,
+	},
+	/* #41: 1280x720p@100Hz 16:9 */
+	[41] = {
+		NULL, 100, 1280, 720, 6734, 220, 440, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+	/* #47: 1280x720p@119.88/120Hz 16:9 */
+	[47] = {
+		NULL, 120, 1280, 720, 6734, 220, 110, 20, 5, 40, 5,
+		FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+		FB_VMODE_NONINTERLACED | FB_VMODE_ASPECT_16_9, 0
+	},
+};
+
+/*
+ * We have a special version of fb_mode_is_equal that ignores
+ * pixclock, since for many CEA modes, 2 frequencies are supported
+ * e.g. 640x480 @ 60Hz or 59.94Hz
+ */
+int myir_edid_fb_mode_is_equal(bool use_aspect,
+			const struct fb_videomode *mode1,
+			const struct fb_videomode *mode2)
+{
+	u32 mask;
+
+	if (use_aspect)
+		mask = ~0;
+	else
+		mask = ~FB_VMODE_ASPECT_MASK;
+
+	return (mode1->xres         == mode2->xres &&
+		mode1->yres         == mode2->yres &&
+		mode1->hsync_len    == mode2->hsync_len &&
+		mode1->vsync_len    == mode2->vsync_len &&
+		mode1->left_margin  == mode2->left_margin &&
+		mode1->right_margin == mode2->right_margin &&
+		mode1->upper_margin == mode2->upper_margin &&
+		mode1->lower_margin == mode2->lower_margin &&
+		mode1->sync         == mode2->sync &&
+		/* refresh check, 59.94Hz and 60Hz have the same parameter
+		 * in struct of myir_cea_mode */
+		abs(mode1->refresh - mode2->refresh) <= 1 &&
+		(mode1->vmode & mask) == (mode2->vmode & mask));
+}
+
+static void get_detailed_timing(unsigned char *block,
+				struct fb_videomode *mode)
+{
+	mode->xres = H_ACTIVE;
+	mode->yres = V_ACTIVE;
+	mode->pixclock = PIXEL_CLOCK;
+	mode->pixclock /= 1000;
+	mode->pixclock = KHZ2PICOS(mode->pixclock);
+	mode->right_margin = H_SYNC_OFFSET;
+	mode->left_margin = (H_ACTIVE + H_BLANKING) -
+		(H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH);
+	mode->upper_margin = V_BLANKING - V_SYNC_OFFSET -
+		V_SYNC_WIDTH;
+	mode->lower_margin = V_SYNC_OFFSET;
+	mode->hsync_len = H_SYNC_WIDTH;
+	mode->vsync_len = V_SYNC_WIDTH;
+	if (HSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_HOR_HIGH_ACT;
+	if (VSYNC_POSITIVE)
+		mode->sync |= FB_SYNC_VERT_HIGH_ACT;
+	mode->refresh = PIXEL_CLOCK/((H_ACTIVE + H_BLANKING) *
+				     (V_ACTIVE + V_BLANKING));
+	if (INTERLACED) {
+		mode->yres *= 2;
+		mode->upper_margin *= 2;
+		mode->lower_margin *= 2;
+		mode->vsync_len *= 2;
+		mode->vmode |= FB_VMODE_INTERLACED;
+	}
+	mode->flag = FB_MODE_IS_DETAILED;
+
+	if ((H_SIZE / 16) == (V_SIZE / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((H_SIZE / 4) == (V_SIZE / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+	else if ((mode->xres / 16) == (mode->yres / 9))
+		mode->vmode |= FB_VMODE_ASPECT_16_9;
+	else if ((mode->xres / 4) == (mode->yres / 3))
+		mode->vmode |= FB_VMODE_ASPECT_4_3;
+
+	if (mode->vmode & FB_VMODE_ASPECT_16_9)
+		DPRINTK("Aspect ratio: 16:9\n");
+	if (mode->vmode & FB_VMODE_ASPECT_4_3)
+		DPRINTK("Aspect ratio: 4:3\n");
+	DPRINTK("      %d MHz ",  PIXEL_CLOCK/1000000);
+	DPRINTK("%d %d %d %d ", H_ACTIVE, H_ACTIVE + H_SYNC_OFFSET,
+	       H_ACTIVE + H_SYNC_OFFSET + H_SYNC_WIDTH, H_ACTIVE + H_BLANKING);
+	DPRINTK("%d %d %d %d ", V_ACTIVE, V_ACTIVE + V_SYNC_OFFSET,
+	       V_ACTIVE + V_SYNC_OFFSET + V_SYNC_WIDTH, V_ACTIVE + V_BLANKING);
+	DPRINTK("%sHSync %sVSync\n\n", (HSYNC_POSITIVE) ? "+" : "-",
+	       (VSYNC_POSITIVE) ? "+" : "-");
+}
+
+int myir_edid_parse_ext_blk(unsigned char *edid,
+		struct myir_edid_cfg *cfg,
+		struct fb_monspecs *specs)
+{
+	char detail_timing_desc_offset;
+	struct fb_videomode *mode, *m;
+	unsigned char index = 0x0;
+	unsigned char *block;
+	int i, num = 0, revision;
+
+	if (edid[index++] != 0x2) /* only support cea ext block now */
+		return -1;
+	revision = edid[index++];
+	DPRINTK("cea extent revision %d\n", revision);
+	mode = kzalloc(50 * sizeof(struct fb_videomode), GFP_KERNEL);
+	if (mode == NULL)
+		return -1;
+
+	detail_timing_desc_offset = edid[index++];
+
+	if (revision >= 2) {
+		cfg->cea_underscan = (edid[index] >> 7) & 0x1;
+		cfg->cea_basicaudio = (edid[index] >> 6) & 0x1;
+		cfg->cea_ycbcr444 = (edid[index] >> 5) & 0x1;
+		cfg->cea_ycbcr422 = (edid[index] >> 4) & 0x1;
+
+		DPRINTK("CEA underscan %d\n", cfg->cea_underscan);
+		DPRINTK("CEA basicaudio %d\n", cfg->cea_basicaudio);
+		DPRINTK("CEA ycbcr444 %d\n", cfg->cea_ycbcr444);
+		DPRINTK("CEA ycbcr422 %d\n", cfg->cea_ycbcr422);
+	}
+
+	if (revision >= 3) {
+		/* short desc */
+		DPRINTK("CEA Short desc timmings\n");
+		index++;
+		while (index < detail_timing_desc_offset) {
+			unsigned char tagcode, blklen;
+
+			tagcode = (edid[index] >> 5) & 0x7;
+			blklen = (edid[index]) & 0x1f;
+
+			DPRINTK("Tagcode %x Len %d\n", tagcode, blklen);
+
+			switch (tagcode) {
+			case 0x2: /*Video data block*/
+				{
+					int cea_idx;
+					i = 0;
+					while (i < blklen) {
+						index++;
+						cea_idx = edid[index] & 0x7f;
+						if (cea_idx < ARRAY_SIZE(myir_cea_mode) &&
+								(myir_cea_mode[cea_idx].xres)) {
+							DPRINTK("Support CEA Format #%d\n", cea_idx);
+							mode[num] = myir_cea_mode[cea_idx];
+							mode[num].flag |= FB_MODE_IS_STANDARD;
+							num++;
+						}
+						i++;
+					}
+					break;
+				}
+			case 0x3: /*Vendor specific data*/
+				{
+					unsigned char IEEE_reg_iden[3];
+					unsigned char deep_color;
+					unsigned char latency_present;
+					unsigned char I_latency_present;
+					unsigned char hdmi_video_present;
+					unsigned char hdmi_3d_present;
+					unsigned char hdmi_3d_multi_present;
+					unsigned char hdmi_vic_len;
+					unsigned char hdmi_3d_len;
+					unsigned char index_inc = 0;
+					unsigned char vsd_end;
+
+					vsd_end = index + blklen;
+
+					IEEE_reg_iden[0] = edid[index+1];
+					IEEE_reg_iden[1] = edid[index+2];
+					IEEE_reg_iden[2] = edid[index+3];
+					cfg->physical_address[0] = (edid[index+4] & 0xf0) >> 4;
+					cfg->physical_address[1] = (edid[index+4] & 0x0f);
+					cfg->physical_address[2] = (edid[index+5] & 0xf0) >> 4;
+					cfg->physical_address[3] = (edid[index+5] & 0x0f);
+
+					if ((IEEE_reg_iden[0] == 0x03) &&
+							(IEEE_reg_iden[1] == 0x0c) &&
+							(IEEE_reg_iden[2] == 0x00))
+						cfg->hdmi_cap = 1;
+
+					if (blklen > 5) {
+						deep_color = edid[index+6];
+						if (deep_color & 0x80)
+							cfg->vsd_support_ai = true;
+						if (deep_color & 0x40)
+							cfg->vsd_dc_48bit = true;
+						if (deep_color & 0x20)
+							cfg->vsd_dc_36bit = true;
+						if (deep_color & 0x10)
+							cfg->vsd_dc_30bit = true;
+						if (deep_color & 0x08)
+							cfg->vsd_dc_y444 = true;
+						if (deep_color & 0x01)
+							cfg->vsd_dvi_dual = true;
+					}
+
+					DPRINTK("VSD hdmi capability %d\n", cfg->hdmi_cap);
+					DPRINTK("VSD support ai %d\n", cfg->vsd_support_ai);
+					DPRINTK("VSD support deep color 48bit %d\n", cfg->vsd_dc_48bit);
+					DPRINTK("VSD support deep color 36bit %d\n", cfg->vsd_dc_36bit);
+					DPRINTK("VSD support deep color 30bit %d\n", cfg->vsd_dc_30bit);
+					DPRINTK("VSD support deep color y444 %d\n", cfg->vsd_dc_y444);
+					DPRINTK("VSD support dvi dual %d\n", cfg->vsd_dvi_dual);
+
+					if (blklen > 6)
+						cfg->vsd_max_tmdsclk_rate = edid[index+7] * 5;
+					DPRINTK("VSD MAX TMDS CLOCK RATE %d\n", cfg->vsd_max_tmdsclk_rate);
+
+					if (blklen > 7) {
+						latency_present = edid[index+8] >> 7;
+						I_latency_present =  (edid[index+8] & 0x40) >> 6;
+						hdmi_video_present = (edid[index+8] & 0x20) >> 5;
+						cfg->vsd_cnc3 = (edid[index+8] & 0x8) >> 3;
+						cfg->vsd_cnc2 = (edid[index+8] & 0x4) >> 2;
+						cfg->vsd_cnc1 = (edid[index+8] & 0x2) >> 1;
+						cfg->vsd_cnc0 = edid[index+8] & 0x1;
+
+						DPRINTK("VSD cnc0 %d\n", cfg->vsd_cnc0);
+						DPRINTK("VSD cnc1 %d\n", cfg->vsd_cnc1);
+						DPRINTK("VSD cnc2 %d\n", cfg->vsd_cnc2);
+						DPRINTK("VSD cnc3 %d\n", cfg->vsd_cnc3);
+						DPRINTK("latency_present %d\n", latency_present);
+						DPRINTK("I_latency_present %d\n", I_latency_present);
+						DPRINTK("hdmi_video_present %d\n", hdmi_video_present);
+
+					} else {
+						index += blklen;
+						break;
+					}
+
+					index += 9;
+
+					/*latency present */
+					if (latency_present) {
+						cfg->vsd_video_latency = edid[index++];
+						cfg->vsd_audio_latency = edid[index++];
+
+						if (I_latency_present) {
+							cfg->vsd_I_video_latency = edid[index++];
+							cfg->vsd_I_audio_latency = edid[index++];
+						} else {
+							cfg->vsd_I_video_latency = cfg->vsd_video_latency;
+							cfg->vsd_I_audio_latency = cfg->vsd_audio_latency;
+						}
+
+						DPRINTK("VSD latency video_latency  %d\n", cfg->vsd_video_latency);
+						DPRINTK("VSD latency audio_latency  %d\n", cfg->vsd_audio_latency);
+						DPRINTK("VSD latency I_video_latency  %d\n", cfg->vsd_I_video_latency);
+						DPRINTK("VSD latency I_audio_latency  %d\n", cfg->vsd_I_audio_latency);
+					}
+
+					if (hdmi_video_present) {
+						hdmi_3d_present = edid[index] >> 7;
+						hdmi_3d_multi_present = (edid[index] & 0x60) >> 5;
+						index++;
+						hdmi_vic_len = (edid[index] & 0xe0) >> 5;
+						hdmi_3d_len = edid[index] & 0x1f;
+						index++;
+
+						DPRINTK("hdmi_3d_present %d\n", hdmi_3d_present);
+						DPRINTK("hdmi_3d_multi_present %d\n", hdmi_3d_multi_present);
+						DPRINTK("hdmi_vic_len %d\n", hdmi_vic_len);
+						DPRINTK("hdmi_3d_len %d\n", hdmi_3d_len);
+
+						if (hdmi_vic_len > 0) {
+							for (i = 0; i < hdmi_vic_len; i++) {
+								cfg->hdmi_vic[i] = edid[index++];
+								DPRINTK("HDMI_vic=%d\n", cfg->hdmi_vic[i]);
+							}
+						}
+
+						if (hdmi_3d_len > 0) {
+							if (hdmi_3d_present) {
+								if (hdmi_3d_multi_present == 0x1) {
+									cfg->hdmi_3d_struct_all = (edid[index] << 8) | edid[index+1];
+									index_inc = 2;
+								} else if (hdmi_3d_multi_present == 0x2) {
+									cfg->hdmi_3d_struct_all = (edid[index] << 8) | edid[index+1];
+									cfg->hdmi_3d_mask_all = (edid[index+2] << 8) | edid[index+3];
+									index_inc = 4;
+								} else
+									index_inc = 0;
+							}
+
+							DPRINTK("HDMI 3d struct all =0x%x\n", cfg->hdmi_3d_struct_all);
+							DPRINTK("HDMI 3d mask all =0x%x\n", cfg->hdmi_3d_mask_all);
+
+							/* Read 2D vic 3D_struct */
+							if ((hdmi_3d_len - index_inc) > 0) {
+								DPRINTK("Support 3D video format\n");
+								i = 0;
+								while ((hdmi_3d_len - index_inc) > 0) {
+
+									cfg->hdmi_3d_format[i].vic_order_2d = edid[index+index_inc] >> 4;
+									cfg->hdmi_3d_format[i].struct_3d = edid[index+index_inc] & 0x0f;
+									index_inc++;
+
+									if (cfg->hdmi_3d_format[i].struct_3d ==  8) {
+										cfg->hdmi_3d_format[i].detail_3d = edid[index+index_inc] >> 4;
+										index_inc++;
+									} else if (cfg->hdmi_3d_format[i].struct_3d > 8) {
+										cfg->hdmi_3d_format[i].detail_3d = 0;
+										index_inc++;
+									}
+
+									DPRINTK("vic_order_2d=%d, 3d_struct=%d, 3d_detail=0x%x\n",
+											cfg->hdmi_3d_format[i].vic_order_2d,
+											cfg->hdmi_3d_format[i].struct_3d,
+											cfg->hdmi_3d_format[i].detail_3d);
+									i++;
+								}
+							}
+							index += index_inc;
+						}
+					}
+
+					index = vsd_end;
+
+					break;
+				}
+			case 0x1: /*Audio data block*/
+				{
+					u8 audio_format, max_ch, byte1, byte2, byte3;
+
+					i = 0;
+					cfg->max_channels = 0;
+					cfg->sample_rates = 0;
+					cfg->sample_sizes = 0;
+
+					while (i < blklen) {
+						byte1 = edid[index + 1];
+						byte2 = edid[index + 2];
+						byte3 = edid[index + 3];
+						index += 3;
+						i += 3;
+
+						audio_format = byte1 >> 3;
+						max_ch = (byte1 & 0x07) + 1;
+
+						DPRINTK("Audio Format Descriptor : %2d\n", audio_format);
+						DPRINTK("Max Number of Channels  : %2d\n", max_ch);
+						DPRINTK("Sample Rates            : %02x\n", byte2);
+
+						/* ALSA can't specify specific compressed
+						 * formats, so only care about PCM for now. */
+						if (audio_format == AUDIO_CODING_TYPE_LPCM) {
+							if (max_ch > cfg->max_channels)
+								cfg->max_channels = max_ch;
+
+							cfg->sample_rates |= byte2;
+							cfg->sample_sizes |= byte3 & 0x7;
+							DPRINTK("Sample Sizes            : %02x\n",
+								byte3 & 0x7);
+						}
+					}
+					break;
+				}
+			case 0x4: /*Speaker allocation block*/
+				{
+					i = 0;
+					while (i < blklen) {
+						cfg->speaker_alloc = edid[index + 1];
+						index += 3;
+						i += 3;
+						DPRINTK("Speaker Alloc           : %02x\n", cfg->speaker_alloc);
+					}
+					break;
+				}
+			case 0x7: /*User extended block*/
+			default:
+				/* skip */
+				DPRINTK("Not handle block, tagcode = 0x%x\n", tagcode);
+				index += blklen;
+				break;
+			}
+
+			index++;
+		}
+	}
+
+	/* long desc */
+	DPRINTK("CEA long desc timmings\n");
+	index = detail_timing_desc_offset;
+	block = edid + index;
+	while (index < (EDID_LENGTH - DETAILED_TIMING_DESCRIPTION_SIZE)) {
+		if (!(block[0] == 0x00 && block[1] == 0x00)) {
+			get_detailed_timing(block, &mode[num]);
+			num++;
+		}
+		block += DETAILED_TIMING_DESCRIPTION_SIZE;
+		index += DETAILED_TIMING_DESCRIPTION_SIZE;
+	}
+
+	if (!num) {
+		kfree(mode);
+		return 0;
+	}
+
+	m = kmalloc((num + specs->modedb_len) *
+			sizeof(struct fb_videomode), GFP_KERNEL);
+	if (!m)
+		return 0;
+
+	if (specs->modedb_len) {
+		memmove(m, specs->modedb,
+			specs->modedb_len * sizeof(struct fb_videomode));
+		kfree(specs->modedb);
+	}
+	memmove(m+specs->modedb_len, mode,
+		num * sizeof(struct fb_videomode));
+	kfree(mode);
+
+	specs->modedb_len += num;
+	specs->modedb = m;
+
+	return 0;
+}
+EXPORT_SYMBOL(myir_edid_parse_ext_blk);
+
+static int myir_edid_readblk(struct i2c_adapter *adp,
+		unsigned short addr, unsigned char *edid)
+{
+	int ret = 0, extblknum = 0;
+	unsigned char regaddr = 0x0;
+	struct i2c_msg msg[2] = {
+		{
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block, ret=%d(expected:%d)\n", ret, ARRAY_SIZE(msg));
+		return -EIO;
+	}
+
+	if (edid[1] == 0x00)
+		return -ENOENT;
+
+	extblknum = edid[0x7E];
+	
+	if (extblknum) {
+		regaddr = 128;
+		msg[1].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID ext block, ret=%d(expected:%d)\n", ret, ARRAY_SIZE(msg));
+			return -EIO;
+		}
+	}
+
+	return extblknum;
+}
+
+static int myir_edid_readsegblk(struct i2c_adapter *adp, unsigned short addr,
+			unsigned char *edid, int seg_num)
+{
+	int ret = 0;
+	unsigned char segment = 0x1, regaddr = 0;
+	struct i2c_msg msg[3] = {
+		{
+		.addr	= 0x30,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &segment,
+		}, {
+		.addr	= addr,
+		.flags	= 0,
+		.len	= 1,
+		.buf	= &regaddr,
+		}, {
+		.addr	= addr,
+		.flags	= I2C_M_RD,
+		.len	= EDID_LENGTH,
+		.buf	= edid,
+		},
+	};
+
+	ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+	if (ret != ARRAY_SIZE(msg)) {
+		DPRINTK("unable to read EDID block\n");
+		return -EIO;
+	}
+
+	if (seg_num == 2) {
+		regaddr = 128;
+		msg[2].buf = edid + EDID_LENGTH;
+
+		ret = i2c_transfer(adp, msg, ARRAY_SIZE(msg));
+		if (ret != ARRAY_SIZE(msg)) {
+			DPRINTK("unable to read EDID block\n");
+			return -EIO;
+		}
+	}
+
+	return ret;
+}
+
+int myir_edid_var_to_vic(struct fb_var_screeninfo *var)
+{
+	int i;
+	struct fb_videomode m;
+
+	for (i = 0; i < ARRAY_SIZE(myir_cea_mode); i++) {
+		fb_var_to_videomode(&m, var);
+		if (myir_edid_fb_mode_is_equal(false, &m, &myir_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(myir_cea_mode))
+		return 0;
+
+	return i;
+}
+EXPORT_SYMBOL(myir_edid_var_to_vic);
+
+int myir_edid_mode_to_vic(const struct fb_videomode *mode)
+{
+	int i;
+	bool use_aspect = (mode->vmode & FB_VMODE_ASPECT_MASK);
+
+	for (i = 0; i < ARRAY_SIZE(myir_cea_mode); i++) {
+		if (myir_edid_fb_mode_is_equal(use_aspect, mode, &myir_cea_mode[i]))
+			break;
+	}
+
+	if (i == ARRAY_SIZE(myir_cea_mode))
+		return 0;
+
+	return i;
+}
+EXPORT_SYMBOL(myir_edid_mode_to_vic);
+
+/* make sure edid has 512 bytes*/
+int myir_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct myir_edid_cfg *cfg, struct fb_info *fbi)
+{
+	int ret = 0, extblknum;
+
+	if (!adp || !edid || !cfg || !fbi)
+		return -EINVAL;
+
+	memset(edid, 0, EDID_LENGTH*4);
+	memset(cfg, 0, sizeof(struct myir_edid_cfg));
+
+	extblknum = myir_edid_readblk(adp, addr, edid);
+
+	printk(KERN_ERR"extblknum1: %d\n", extblknum);
+	printk(KERN_ERR"extblknum2: %d\n", extblknum);
+	printk(KERN_ERR"extblknum3: %d\n", extblknum);
+	
+	if (extblknum < 0)
+		return extblknum;
+
+	/* edid first block parsing */
+	memset(&fbi->monspecs, 0, sizeof(fbi->monspecs));
+	fb_edid_to_monspecs(edid, &fbi->monspecs);
+
+	if (extblknum) {
+		int i;
+
+		/* need read segment block? */
+		if (extblknum > 1) {
+			ret = myir_edid_readsegblk(adp, addr,
+				edid + EDID_LENGTH*2, extblknum - 1);
+			if (ret < 0) {
+				return ret;
+			}
+		}
+
+		for (i = 1; i <= extblknum; i++)
+			/* edid ext block parsing */
+			myir_edid_parse_ext_blk(edid + i*EDID_LENGTH,
+					cfg, &fbi->monspecs);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(myir_edid_read);
--- /dev/null
+++ b/drivers/video/sii902x/myir_edid.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file myir_edid.h
+ *
+ * @brief MYIR EDID tools
+ *
+ * @ingroup Framebuffer
+ */
+
+#ifndef MYIR_EDID_H
+#define MYIR_EDID_H
+
+#include <linux/fb.h>
+
+#define FB_VMODE_ASPECT_4_3	0x10
+#define FB_VMODE_ASPECT_16_9	0x20
+#define FB_VMODE_ASPECT_MASK	(FB_VMODE_ASPECT_4_3 | FB_VMODE_ASPECT_16_9)
+
+enum cea_audio_coding_types {
+	AUDIO_CODING_TYPE_REF_STREAM_HEADER	=  0,
+	AUDIO_CODING_TYPE_LPCM			=  1,
+	AUDIO_CODING_TYPE_AC3			=  2,
+	AUDIO_CODING_TYPE_MPEG1			=  3,
+	AUDIO_CODING_TYPE_MP3			=  4,
+	AUDIO_CODING_TYPE_MPEG2			=  5,
+	AUDIO_CODING_TYPE_AACLC			=  6,
+	AUDIO_CODING_TYPE_DTS			=  7,
+	AUDIO_CODING_TYPE_ATRAC			=  8,
+	AUDIO_CODING_TYPE_SACD			=  9,
+	AUDIO_CODING_TYPE_EAC3			= 10,
+	AUDIO_CODING_TYPE_DTS_HD		= 11,
+	AUDIO_CODING_TYPE_MLP			= 12,
+	AUDIO_CODING_TYPE_DST			= 13,
+	AUDIO_CODING_TYPE_WMAPRO		= 14,
+	AUDIO_CODING_TYPE_RESERVED		= 15,
+};
+
+struct myir_hdmi_3d_format {
+	unsigned char vic_order_2d;
+	unsigned char struct_3d;
+	unsigned char detail_3d;
+	unsigned char reserved;
+};
+
+struct myir_edid_cfg {
+	bool cea_underscan;
+	bool cea_basicaudio;
+	bool cea_ycbcr444;
+	bool cea_ycbcr422;
+	bool hdmi_cap;
+
+	/*VSD*/
+	bool vsd_support_ai;
+	bool vsd_dc_48bit;
+	bool vsd_dc_36bit;
+	bool vsd_dc_30bit;
+	bool vsd_dc_y444;
+	bool vsd_dvi_dual;
+
+	bool vsd_cnc0;
+	bool vsd_cnc1;
+	bool vsd_cnc2;
+	bool vsd_cnc3;
+
+	u8 vsd_video_latency;
+	u8 vsd_audio_latency;
+	u8 vsd_I_video_latency;
+	u8 vsd_I_audio_latency;
+
+	u8 physical_address[4];
+	u8 hdmi_vic[64];
+	struct myir_hdmi_3d_format hdmi_3d_format[64];
+	u16 hdmi_3d_mask_all;
+	u16 hdmi_3d_struct_all;
+	u32 vsd_max_tmdsclk_rate;
+
+	u8 max_channels;
+	u8 sample_sizes;
+	u8 sample_rates;
+	u8 speaker_alloc;
+};
+
+int myir_edid_var_to_vic(struct fb_var_screeninfo *var);
+int myir_edid_mode_to_vic(const struct fb_videomode *mode);
+int myir_edid_read(struct i2c_adapter *adp, unsigned short addr,
+	unsigned char *edid, struct myir_edid_cfg *cfg, struct fb_info *fbi);
+int myir_edid_parse_ext_blk(unsigned char *edid, struct myir_edid_cfg *cfg,
+	struct fb_monspecs *specs);
+#endif
--- /dev/null
+++ b/drivers/video/sii902x/myir_sii902x.c
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2014-2018 MYIR Tech, Inc. All Rights Reserved.
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for Sii902x.
+ */
+
+/*!
+ * @file myir_sii902x.c
+ *
+ * @brief  Frame buffer driver for SII902X
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#define DEBUG	1
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/i2c.h>
+#include <linux/fsl_devices.h>
+#include <linux/interrupt.h>
+#include <linux/reset.h>
+#include <asm/mach-types.h>
+#include "myir_edid.h"
+
+#define SII_EDID_LEN	512
+#define DRV_NAME 		"sii902x"
+#define DET_RETRY_CNT	2
+
+struct sii902x_data {
+	struct i2c_client *client;
+	struct delayed_work det_work;
+	struct fb_info *fbi;
+	struct myir_edid_cfg edid_cfg;
+	u8 cable_plugin;
+	u8 edid[SII_EDID_LEN];
+	bool waiting_for_fb;
+	bool dft_mode_set;
+	const char *mode_str;
+	int bits_per_pixel;
+	int retries;
+} sii902x;
+
+static void sii902x_poweron(void);
+static void sii902x_poweroff(void);
+
+#if defined(DEBUG) && defined(CONFIG_SII902X_EDID_READING)
+static void dump_fb_videomode(struct fb_videomode *m)
+{
+	pr_debug("fb_videomode = %d %d %d %d %d %d %d %d %d %d %d %d %d\n",
+		m->refresh, m->xres, m->yres, m->pixclock, m->left_margin,
+		m->right_margin, m->upper_margin, m->lower_margin,
+		m->hsync_len, m->vsync_len, m->sync, m->vmode, m->flag);
+}
+#endif
+
+static __attribute__ ((unused)) void dump_regs(u8 reg, int len)
+{
+	u8 buf[50];
+	int i;
+
+	i2c_smbus_read_i2c_block_data(sii902x.client, reg, len, buf);
+	for (i = 0; i < len; i++)
+		dev_dbg(&sii902x.client->dev, "reg[0x%02X]: 0x%02X\n",
+				i+reg, buf[i]);
+}
+
+static ssize_t sii902x_show_name(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+
+	strcpy(buf, sii902x.fbi->fix.id);
+	sprintf(buf+strlen(buf), "\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(fb_name, S_IRUGO, sii902x_show_name, NULL);
+
+static ssize_t sii902x_show_state(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	if (sii902x.cable_plugin == 0)
+		strcpy(buf, "plugout\n");
+	else
+		strcpy(buf, "plugin\n");
+
+	return strlen(buf);
+}
+
+static DEVICE_ATTR(cable_state, S_IRUGO, sii902x_show_state, NULL);
+
+static ssize_t sii902x_show_edid(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	int len = 0;
+#ifdef CONFIG_SII902X_EDID_READING
+	int i, j;
+	for (j = 0; j < SII_EDID_LEN/16; j++) {
+		for (i = 0; i < 16; i++)
+			len += sprintf(buf+len, "0x%02X ",
+					sii902x.edid[j*16 + i]);
+		len += sprintf(buf+len, "\n");
+	}
+#else
+	len = sprintf(buf, "EDID reading is not supported.\n");
+#endif
+	return len;
+}
+
+static DEVICE_ATTR(edid, S_IRUGO, sii902x_show_edid, NULL);
+
+static void sii902x_setup(struct fb_info *fbi)
+{
+	u16 data[4];
+	u32 refresh;
+	u8 *tmp;
+	int i;
+
+	dev_dbg(&sii902x.client->dev, "Sii902x: setup..\n");
+
+	/* Power up */
+	i2c_smbus_write_byte_data(sii902x.client, 0x1E, 0x00);
+
+	/* set TPI video mode */
+	data[0] = PICOS2KHZ(fbi->var.pixclock) / 10;
+	data[2] = fbi->var.hsync_len + fbi->var.left_margin +
+		  fbi->var.xres + fbi->var.right_margin;
+	data[3] = fbi->var.vsync_len + fbi->var.upper_margin +
+		  fbi->var.yres + fbi->var.lower_margin;
+	refresh = data[2] * data[3];
+	refresh = (PICOS2KHZ(fbi->var.pixclock) * 1000) / refresh;
+	data[1] = refresh * 100;
+	tmp = (u8 *)data;
+	for (i = 0; i < 8; i++)
+		i2c_smbus_write_byte_data(sii902x.client, i, tmp[i]);
+
+	/* input bus/pixel: full pixel wide (24bit), rising edge */
+	i2c_smbus_write_byte_data(sii902x.client, 0x08, 0x70);
+	/* Set input format to RGB */
+	i2c_smbus_write_byte_data(sii902x.client, 0x09, 0x00);
+	/* set output format to RGB */
+	i2c_smbus_write_byte_data(sii902x.client, 0x0A, 0x00);
+	/* audio setup */
+	i2c_smbus_write_byte_data(sii902x.client, 0x25, 0x00);
+	i2c_smbus_write_byte_data(sii902x.client, 0x26, 0x40);
+	i2c_smbus_write_byte_data(sii902x.client, 0x27, 0x00);
+}
+
+#ifdef CONFIG_SII902X_EDID_READING
+static int sii902x_read_edid(struct fb_info *fbi)
+{
+	int old, dat, ret, cnt = 100;
+	unsigned short addr = 0x50;
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);
+
+	old = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old | 0x4);
+	do {
+		cnt--;
+		msleep(10);
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+	} while ((!(dat & 0x2)) && cnt);
+
+	if (!cnt) {
+		ret = -1;
+		goto done;
+	}
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old | 0x06);
+
+	/* edid reading */
+	ret = myir_edid_read(sii902x.client->adapter, addr,
+				sii902x.edid, &sii902x.edid_cfg, fbi);
+
+	printk(KERN_ERR"myir_edid_read: ret=%d", ret);
+
+	cnt = 100;
+	do {
+		cnt--;
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, old & ~0x6);
+		msleep(10);
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1A);
+	} while ((dat & 0x6) && cnt);
+
+	if (!cnt) {
+		ret = -1;
+	}
+
+done:
+
+	i2c_smbus_write_byte_data(sii902x.client, 0x1A, old);
+	return ret;
+}
+
+static int sii902x_cable_connected(void)
+{
+	int i;
+	const struct fb_videomode *mode;
+	struct fb_videomode m;
+	int ret;
+
+	ret = sii902x_read_edid(sii902x.fbi);
+	if (ret < 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: read edid fail\n");
+		/* Power on sii902x */
+		sii902x_poweron();
+	} else {
+		if (sii902x.fbi->monspecs.modedb_len > 0) {
+
+			fb_destroy_modelist(&sii902x.fbi->modelist);
+
+			for (i = 0; i < sii902x.fbi->monspecs.modedb_len; i++) {
+
+				mode = &sii902x.fbi->monspecs.modedb[i];
+
+				if (!(mode->vmode & FB_VMODE_INTERLACED)) {
+
+					dev_dbg(&sii902x.client->dev, "Added mode %d:", i);
+					dev_dbg(&sii902x.client->dev,
+						"xres = %d, yres = %d, freq = %d, vmode = %d, flag = %d\n",
+						mode->xres, mode->yres, mode->refresh,
+						mode->vmode, mode->flag);
+
+					fb_add_videomode(mode, &sii902x.fbi->modelist);
+				}
+			}
+
+			/* Set the default mode only once. */
+			if (!sii902x.dft_mode_set &&
+					sii902x.mode_str && sii902x.bits_per_pixel) {
+
+				dev_dbg(&sii902x.client->dev, "%s: setting to default=%s bpp=%d\n",
+						__func__, sii902x.mode_str, sii902x.bits_per_pixel);
+
+				fb_find_mode(&sii902x.fbi->var, sii902x.fbi,
+						sii902x.mode_str, NULL, 0, NULL,
+						sii902x.bits_per_pixel);
+
+				sii902x.dft_mode_set = true;
+			}
+
+			fb_var_to_videomode(&m, &sii902x.fbi->var);
+			dump_fb_videomode(&m);
+
+			mode = fb_find_nearest_mode(&m,
+					&sii902x.fbi->modelist);
+
+			/* update fbi mode  */
+			sii902x.fbi->mode = (struct fb_videomode *)mode;
+
+			fb_videomode_to_var(&sii902x.fbi->var, mode);
+
+			sii902x.fbi->var.activate |= FB_ACTIVATE_FORCE;
+			console_lock();
+			sii902x.fbi->flags |= FBINFO_MISC_USEREVENT;
+			fb_set_var(sii902x.fbi, &sii902x.fbi->var);
+			sii902x.fbi->flags &= ~FBINFO_MISC_USEREVENT;
+			console_unlock();
+		}
+		/* Power on sii902x */
+		sii902x_poweron();
+	}
+	return ret;
+}
+#else
+static int sii902x_cable_connected(void)
+{
+	/* Power on sii902x */
+	sii902x_poweron();
+	
+	return 0;
+}
+#endif /* CONFIG_SII902X_EDID_READING */
+
+static void det_worker(struct work_struct *work)
+{
+	int dat;
+	char event_string[16];
+	char *envp[] = { event_string, NULL };
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);
+
+	dat = i2c_smbus_read_byte_data(sii902x.client, 0x3D);
+
+	printk(KERN_ERR"status: %#X, sii902x.retries: %d\n", dat, sii902x.retries);
+//	if ((dat & 0x1) || sii902x.retries > 0) {
+	if (dat >= 0) {
+		/* cable connection changes */
+		if (dat & 0x4) {
+			sii902x.cable_plugin = 1;
+			dev_dbg(&sii902x.client->dev, "EVENT=plugin\n");
+			sprintf(event_string, "EVENT=plugin");
+			if (sii902x_cable_connected() < 0 && sii902x.retries > 0) {
+				sii902x.retries --;
+				schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(500));
+			} else {
+				sii902x.retries = 0;
+			}
+		} else {
+			sii902x.retries = 0;
+			sii902x.cable_plugin = 0;
+			dev_dbg(&sii902x.client->dev, "EVENT=plugout\n");
+			sprintf(event_string, "EVENT=plugout");
+			/* Power off sii902x */
+			sii902x_poweroff();
+		}
+		kobject_uevent_env(&sii902x.client->dev.kobj, KOBJ_CHANGE, envp);
+	} else {
+		dev_err(&sii902x.client->dev, "i2c bus error!!!\n");
+		sii902x.retries = 0;
+	}
+	i2c_smbus_write_byte_data(sii902x.client, 0x3D, dat);
+
+	dev_dbg(&sii902x.client->dev, "exit %s\n", __func__);
+}
+
+static irqreturn_t sii902x_detect_handler(int irq, void *data)
+{
+	if (sii902x.fbi) {
+		if (sii902x.retries == 0) {/* no need to schedule workqueue if retries > 0 */
+			sii902x.retries = DET_RETRY_CNT;
+			schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(100/*20*/));
+		}
+	} else {
+		sii902x.waiting_for_fb = true;
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int sii902x_fb_event(struct notifier_block *nb, unsigned long val, void *v)
+{
+	struct fb_event *event = v;
+	struct fb_info *fbi = event->info;
+	
+	dev_dbg(&sii902x.client->dev, "%s event=0x%lx, \n", __func__, val);
+		
+	switch (val) {
+	case FB_EVENT_FB_REGISTERED:
+	if (sii902x.fbi == NULL) {
+			sii902x.fbi = fbi;
+			if (sii902x.waiting_for_fb) {
+				sii902x.retries = DET_RETRY_CNT;
+				sii902x.waiting_for_fb = false;
+				sii902x_setup(fbi);
+				schedule_delayed_work(&(sii902x.det_work), msecs_to_jiffies(20));
+			}
+		}
+		fb_show_logo(fbi, 0);
+		break;
+	case FB_EVENT_MODE_CHANGE:
+		printk(KERN_DEBUG"%s event=[%s]\n", __func__, "FB_EVENT_MODE_CHANGE");
+		sii902x_setup(fbi);
+		break;
+	case FB_EVENT_BLANK:
+		if (*((int *)event->data) == FB_BLANK_UNBLANK) {
+			dev_dbg(&sii902x.client->dev, "FB_BLANK_UNBLANK\n");
+			sii902x_poweron();
+		} else {
+			dev_dbg(&sii902x.client->dev, "FB_BLANK_BLANK\n");
+			sii902x_poweroff();
+		}
+		break;
+	}
+	return 0;
+}
+
+static struct notifier_block nb = {
+	.notifier_call = sii902x_fb_event,
+};
+
+static int myir_get_of_property(void)
+{
+	struct device_node *np = sii902x.client->dev.of_node;
+	const char *mode_str;
+	int bits_per_pixel, ret;
+
+	ret = of_property_read_string(np, "mode_str", &mode_str);
+	if (ret < 0) {
+		dev_warn(&sii902x.client->dev, "get of property mode_str fail\n");
+		return ret;
+	}
+	ret = of_property_read_u32(np, "bits-per-pixel", &bits_per_pixel);
+	if (ret) {
+		dev_warn(&sii902x.client->dev, "get of property bpp fail\n");
+		return ret;
+	}
+
+	sii902x.mode_str = mode_str;
+	sii902x.bits_per_pixel = bits_per_pixel;
+
+	return ret;
+}
+
+static int sii902x_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	int i, dat, ret;
+#ifdef CONFIG_SII902X_EDID_READING
+	struct fb_info edid_fbi;
+#endif
+	memset(&sii902x, 0, sizeof(sii902x));
+
+	sii902x.client = client;
+
+	dev_dbg(&sii902x.client->dev, "%s\n", __func__);;
+
+	/* Recommend to reset sii902x here, not yet implemented */
+	
+	/* Set 902x in hardware TPI mode on and jump out of D3 state */
+	if (i2c_smbus_write_byte_data(sii902x.client, 0xc7, 0x00) < 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: cound not find device\n");
+		return -ENODEV;
+	}
+
+	/* read device ID */
+	for (i = 10; i > 0; i--) {
+		dat = i2c_smbus_read_byte_data(sii902x.client, 0x1B);
+		printk(KERN_DEBUG "Sii902x: read id = 0x%02X", dat);
+		if (dat == 0xb0) {
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x1C);
+			printk(KERN_DEBUG "-0x%02X", dat);
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x1D);
+			printk(KERN_DEBUG "-0x%02X", dat);
+			dat = i2c_smbus_read_byte_data(sii902x.client, 0x30);
+			printk(KERN_DEBUG "-0x%02X\n", dat);
+			break;
+		}
+	}
+	if (i == 0) {
+		dev_err(&sii902x.client->dev,
+			"Sii902x: cound not find device\n");
+		return -ENODEV;
+	}
+
+#ifdef CONFIG_SII902X_EDID_READING
+	/* try to read edid */
+	ret = sii902x_read_edid(&edid_fbi);
+	if (ret < 0)
+		dev_warn(&sii902x.client->dev, "Can not read edid\n");
+#else
+	sii902x.edid_cfg.hdmi_cap = 1;
+#endif
+		
+	if (sii902x.client->irq) {
+		ret = request_irq(sii902x.client->irq, sii902x_detect_handler,
+				/*IRQF_TRIGGER_FALLING*/IRQF_TRIGGER_RISING,
+				"SII902x_det", &sii902x);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not request det irq %d\n",
+				sii902x.client->irq);
+		else {
+			/*enable cable hot plug irq*/
+			i2c_smbus_write_byte_data(sii902x.client, 0x3c, 0x01);
+			INIT_DELAYED_WORK(&(sii902x.det_work), det_worker);
+		}
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_fb_name);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for fb name\n");
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_cable_state);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for cable state\n");
+		ret = device_create_file(&sii902x.client->dev, &dev_attr_edid);
+		if (ret < 0)
+			dev_warn(&sii902x.client->dev,
+				"Sii902x: cound not create sys node for edid\n");
+
+	}
+
+	myir_get_of_property();
+	sii902x.waiting_for_fb = true;
+	fb_register_client(&nb);
+
+	return 0;
+}
+
+static int sii902x_remove(struct i2c_client *client)
+{
+	fb_unregister_client(&nb);
+	sii902x_poweroff();
+	
+	device_remove_file(&client->dev, &dev_attr_fb_name);
+	device_remove_file(&client->dev, &dev_attr_cable_state);
+	device_remove_file(&client->dev, &dev_attr_edid);
+	
+	return 0;
+}
+
+static void sii902x_poweron(void)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	/* Turn on DVI or HDMI */
+	if (sii902x.edid_cfg.hdmi_cap)
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x01);
+	else
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x00);
+	return;
+}
+
+static void sii902x_poweroff(void)
+{
+	printk(KERN_INFO "%s\n", __func__);
+	/* disable tmds before changing resolution */
+	if (sii902x.edid_cfg.hdmi_cap)
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x11);
+	else
+		i2c_smbus_write_byte_data(sii902x.client, 0x1A, 0x10);
+
+	return;
+}
+
+static const struct i2c_device_id sii902x_id[] = {
+	{ DRV_NAME, 0},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, sii902x_id);
+
+static const struct of_device_id sii902x_dt_ids[] = {
+	{ .compatible = DRV_NAME, },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, sii902x_dt_ids);
+
+static struct i2c_driver sii902x_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = sii902x_dt_ids,
+	},
+	.probe		= sii902x_probe,
+	.remove		= sii902x_remove,
+	.id_table	= sii902x_id,
+};
+
+module_i2c_driver(sii902x_driver);
+
+MODULE_AUTHOR("MYIR Tech, Inc.");
+MODULE_DESCRIPTION("SII902x DVI/HDMI driver");
+MODULE_LICENSE("GPL");
--- /dev/null
+++ b/drivers/video/xylon/Kconfig
@@ -0,0 +1 @@
+source "drivers/video/xylon/xylonfb/Kconfig"
--- /dev/null
+++ b/drivers/video/xylon/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FB_XYLON) += xylonfb/
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/logiclk.c
@@ -0,0 +1,494 @@
+/*
+ * Xylon logiCVC frame buffer driver:
+ *   pixel clock generation using logiCLK IP core
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: goran.pantar@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/math64.h>
+#include "logiclk.h"
+
+
+#define FRAC_PRECISION              10
+
+#define FVCO_MIN                    800
+#define FVCO_MAX                    1600
+
+#define NUM_OF_MULT_STEPS           64
+#define NUM_OF_DIV_INPUT_STEPS      56
+#define NUM_OF_DIV_OUTPUT_STEPS     128
+
+#define CLK_FB_OUT_DUTY             50000
+#define DIV_CLK_PHASE               0
+
+
+static inline u32 get_bits(u64 input, u32 msb, u32 lsb)
+{
+	return (input >> lsb) & ((1 << (msb-lsb+1)) - 1);
+}
+
+static u32 round_frac(u32 decimal, u32 precision)
+{
+	u32 ret;
+
+	if (decimal & (1 << (FRAC_PRECISION-precision-1)))
+		ret = decimal + (1 << (FRAC_PRECISION-precision-1));
+	else
+		ret = decimal;
+
+	return ret;
+}
+
+static u32 pll_divider(u32 divide, u32 duty_cycle)
+{
+	u32 duty_cycle_fix;
+	u32 high_time;
+	u32 low_time;
+	u32 w_edge;
+	u32 no_count;
+	u32 temp;
+
+	if (duty_cycle <= 0 || duty_cycle >= 100000) {
+		pr_err("%s: invalid duty_cycle %d", __func__, duty_cycle);
+		return -1;
+	}
+	duty_cycle_fix = (duty_cycle << FRAC_PRECISION) / 100000;
+
+	if (divide == 1) {
+		high_time = 1;
+		w_edge = 0;
+		low_time = 1;
+		no_count = 1;
+	} else {
+		temp = round_frac(duty_cycle_fix * divide, 1);
+		high_time = get_bits(temp, FRAC_PRECISION+6, FRAC_PRECISION);
+		w_edge = get_bits(temp, FRAC_PRECISION-1, FRAC_PRECISION-1);
+
+		if (high_time == 0) {
+			high_time = 1;
+			w_edge = 0;
+		}
+		if (high_time == divide) {
+			high_time = divide - 1;
+			w_edge = 1;
+		}
+		low_time = divide - high_time;
+		no_count = 0;
+	}
+
+	return (((low_time  & 0x3F) <<  0) |
+			((high_time & 0x3F) <<  6) |
+			((no_count  & 0x01) << 12) |
+			((w_edge    & 0x01) << 13));
+}
+
+static u32 pll_phase(u32 divide, s32 phase)
+{
+	u32 phase_in_cycles;
+	u32 phase_fixed;
+	u32 mx;
+	u32 delay_time;
+	u32 phase_mux;
+	u32 temp;
+
+	if ((phase < -360000) || (phase > 360000))
+		return -1;
+
+	if (phase < 0)
+		phase_fixed = ((phase + 360000) << FRAC_PRECISION) / 1000;
+	else
+		phase_fixed = (phase << FRAC_PRECISION) / 1000;
+
+	phase_in_cycles = (phase_fixed * divide) / 360;
+
+	temp = round_frac(phase_in_cycles, 3);
+
+	mx = 0;
+	phase_mux = get_bits(temp, FRAC_PRECISION-1, FRAC_PRECISION-3);
+	delay_time = get_bits(temp, FRAC_PRECISION+5, FRAC_PRECISION);
+
+	return ((delay_time & 0x3F) << 0) |
+			((phase_mux & 0x07) << 6) |
+			((mx        & 0x03) << 9);
+}
+
+static u64 pll_lock_lookup(u32 divide)
+{
+	u64 lookup[] = {
+		0x31BE8FA401,
+		0x31BE8FA401,
+		0x423E8FA401,
+		0x5AFE8FA401,
+		0x73BE8FA401,
+		0x8C7E8FA401,
+		0x9CFE8FA401,
+		0xB5BE8FA401,
+		0xCE7E8FA401,
+		0xE73E8FA401,
+		0xFFF84FA401,
+		0xFFF39FA401,
+		0xFFEEEFA401,
+		0xFFEBCFA401,
+		0xFFE8AFA401,
+		0xFFE71FA401,
+		0xFFE3FFA401,
+		0xFFE26FA401,
+		0xFFE0DFA401,
+		0xFFDF4FA401,
+		0xFFDDBFA401,
+		0xFFDC2FA401,
+		0xFFDA9FA401,
+		0xFFD90FA401,
+		0xFFD90FA401,
+		0xFFD77FA401,
+		0xFFD5EFA401,
+		0xFFD5EFA401,
+		0xFFD45FA401,
+		0xFFD45FA401,
+		0xFFD2CFA401,
+		0xFFD2CFA401,
+		0xFFD2CFA401,
+		0xFFD13FA401,
+		0xFFD13FA401,
+		0xFFD13FA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401,
+		0xFFCFAFA401
+	};
+	return lookup[divide-1];
+}
+
+static u32 pll_filter_lookup(u32 divide, bool bw_low)
+{
+	u32 lookup_entry;
+	u32 lookup_low[] = {
+		0x5F,
+		0x57,
+		0x7B,
+		0x5B,
+		0x6B,
+		0x73,
+		0x73,
+		0x73,
+		0x73,
+		0x4B,
+		0x4B,
+		0x4B,
+		0xB3,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x53,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x63,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0x93,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3,
+		0xA3
+	};
+	u32 lookup_high[] = {
+		0x17C,
+		0x3FC,
+		0x3F4,
+		0x3E4,
+		0x3F8,
+		0x3C4,
+		0x3C4,
+		0x3D8,
+		0x3E8,
+		0x3E8,
+		0x3E8,
+		0x3B0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3F0,
+		0x3B0,
+		0x3B0,
+		0x3B0,
+		0x3E8,
+		0x370,
+		0x308,
+		0x370,
+		0x370,
+		0x3E8,
+		0x3E8,
+		0x3E8,
+		0x1C8,
+		0x330,
+		0x330,
+		0x3A8,
+		0x188,
+		0x188,
+		0x188,
+		0x1F0,
+		0x188,
+		0x110,
+		0x110,
+		0x110,
+		0x110,
+		0x110,
+		0x110,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0,
+		0x0E0
+	};
+
+	if (bw_low)
+		lookup_entry = lookup_low[divide-1];
+	else
+		lookup_entry = lookup_high[divide-1];
+
+	return lookup_entry;
+}
+
+static u32 calc_pll_count(u32 divide, s32 phase, u32 duty_cycle)
+{
+	u32 div_calc;
+	u32 phase_calc;
+	u32 ret;
+
+	div_calc = pll_divider(divide, duty_cycle);
+	phase_calc = pll_phase(divide, phase);
+
+	ret = ((get_bits(div_calc,   11,  0) << 0)  |
+		   (get_bits(phase_calc,  8,  6) << 13) |
+		   (get_bits(phase_calc,  5,  0) << 16) |
+		   (get_bits(div_calc,   13, 12) << 22) |
+		   (get_bits(phase_calc, 10,  9) << 24));
+
+	return ret;
+}
+
+static void calc_pll_mult(u32 osc_clk_freq, u32 out_clk_freq,
+	u32 *p_mult, u32 *p_div_in)
+{
+	u32 freq_err = 0xFFFFFFFF;
+	u32 din;
+	u32 dout;
+	u32 mult;
+	u32 fvco;
+	u64 freq_err_new;
+	u64 freq_hz;
+	u32 remainder;
+
+	*p_mult = 0;
+	*p_div_in = 0;
+
+	for (din = 1; din <= NUM_OF_DIV_INPUT_STEPS; din++) {
+		for (mult = 2; mult <= NUM_OF_MULT_STEPS; mult++) {
+			for (dout = 1; dout <= NUM_OF_DIV_OUTPUT_STEPS; dout++) {
+				freq_hz = osc_clk_freq;
+				freq_hz *= mult;
+				freq_hz = div_u64_rem(freq_hz, din, &remainder);
+				fvco = (u32)(div_u64_rem(freq_hz, 1000000, &remainder));
+				if ((fvco >= FVCO_MIN) && (fvco <= FVCO_MAX)) {
+					freq_hz = div_u64_rem(freq_hz, dout, &remainder);
+					if (((u64)out_clk_freq) >= freq_hz)
+						freq_err_new = ((u64)out_clk_freq) - freq_hz;
+					else
+						freq_err_new = freq_hz - ((u64)out_clk_freq);
+					if (freq_err_new < freq_err) {
+						freq_err = (u32)freq_err_new;
+						*p_mult = mult;
+						*p_div_in = din;
+					}
+				}
+			}
+		}
+	}
+}
+
+static u32 calc_pll_div(u32 osc_clk_freq, u32 out_clk_freq,
+	u32 mult, u32 div_in)
+{
+	u32 div_out = 0;
+	u32 freq_err = 0xFFFFFFFF;
+	u32 dout;
+	u32 khz;
+	u32 freq_err_new;
+
+	for (dout = 1; dout <= NUM_OF_DIV_OUTPUT_STEPS; dout++) {
+		khz = (osc_clk_freq / 1000 * mult) / (dout * div_in);
+		freq_err_new = abs((int)(out_clk_freq - (1000 * khz)));
+		if (freq_err_new < freq_err) {
+			freq_err = freq_err_new;
+			div_out = dout;
+		}
+	}
+
+	return div_out;
+}
+
+int logiclk_calc_regs(struct logiclk_freq_out *freq_out,
+	u32 c_osc_clk_freq_hz, u32 *regs_out)
+{
+	u32 clkout_phase = 0;
+	u32 clkfbout_phase = 0;
+	u32 clkout_duty = 50000;
+	u32 bandwith = 0;
+	u32 divclk_divide = 1;
+	u64 lock;
+	u32 clkout_divide[LOGICLK_OUTPUTS];
+	u32 clkfbout_mult;
+	u32 clkout[LOGICLK_OUTPUTS];
+	u32 divclk;
+	u32 clkfbout;
+	u32 digital_filt;
+	int i;
+
+	calc_pll_mult(c_osc_clk_freq_hz, (u32)freq_out->freq_out_hz[0],
+		&clkfbout_mult, &divclk_divide);
+	if ((clkfbout_mult == 0) || (divclk_divide == 0))
+		return -EINVAL;
+
+	for (i = 0; i < LOGICLK_OUTPUTS; i++)
+		clkout_divide[i] = calc_pll_div(c_osc_clk_freq_hz,
+			freq_out->freq_out_hz[i], clkfbout_mult, divclk_divide);
+
+	for (i = 0; i < LOGICLK_OUTPUTS; i++)
+		clkout[i] = calc_pll_count(
+			clkout_divide[i], clkout_phase, clkout_duty);
+
+	divclk = calc_pll_count(divclk_divide, DIV_CLK_PHASE, CLK_FB_OUT_DUTY);
+	clkfbout = calc_pll_count(clkfbout_mult, clkfbout_phase, clkout_duty);
+
+	digital_filt = pll_filter_lookup(clkfbout_mult-1, bandwith);
+	lock = pll_lock_lookup(clkfbout_mult-1);
+
+	regs_out[0] = 0xFFFF;
+	for (i = 0; i < LOGICLK_OUTPUTS; i++) {
+		regs_out[1 + i*2 + 0] = get_bits(clkout[i], 15, 0);
+		regs_out[1 + i*2 + 1] = get_bits(clkout[i], 31, 16);
+	}
+
+	/* DIVCLK[23:22] & DIVCLK[11:0] */
+	regs_out[13] = (get_bits(divclk, 23, 22) << 12) |
+					(get_bits(divclk, 11, 0) << 0);
+	/* CLKFBOUT[15:0] */
+	regs_out[14] = get_bits(clkfbout, 15, 0);
+	/* CLKFBOUT[31:16] */
+	regs_out[15] = get_bits(clkfbout, 31, 16);
+	/* LOCK[29:20] */
+	regs_out[16] = get_bits(lock, 29, 20);
+	/* LOCK[34:30] & LOCK[9:0] */
+	regs_out[17] = (get_bits(lock, 34, 30) << 10) |
+					get_bits(lock, 9, 0);
+	/* LOCK[39:35] & S10_LOCK[19:10] */
+	regs_out[18] = (get_bits(lock, 39, 35) << 10) |
+					get_bits(lock, 19, 10);
+	/* DIGITAL_FILT[9] & 00 & DIGITAL_FILT[8:7] & 00 &
+	   DIGITAL_FILT[6] & 0000000 */
+	regs_out[19] = (get_bits(digital_filt, 6, 6) << 8)  |
+				   (get_bits(digital_filt, 8, 7) << 11) |
+				   (get_bits(digital_filt, 9, 9) << 15);
+	/* DIGITAL_FILT[5] & 00 & DIGITAL_FILT[4:3] & 00 &
+	   DIGITAL_FILT[2:1] & 00 & DIGITAL_FILT[0] & 0000  */
+	regs_out[20] = (get_bits(digital_filt, 0, 0) << 4)  |
+				   (get_bits(digital_filt, 2, 1) << 7)  |
+				   (get_bits(digital_filt, 4, 3) << 11) |
+				   (get_bits(digital_filt, 5, 5) << 15);
+
+#ifdef LOGICLK_DUMP_REGS
+	for (i = 0; i < LOGICLK_REGS; i++)
+		pr_info("reg[%d]=0x%lx\n", i, regs_out[i]);
+#endif
+
+	return 0;
+}
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/logiclk.h
@@ -0,0 +1,38 @@
+/*
+ * Xylon logiCVC pixel clock generation logiCLK IP core interface
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: goran.pantar@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/types.h>
+
+
+#define LOGICLK_REGS                21
+#define LOGICLK_OUTPUTS             6
+#define LOGICLK_RST_REG_OFF         0
+#define LOGICLK_PLL_REG_OFF         1
+#define LOGICLK_PLL_MANUAL_REG_OFF  3
+#define LOGICLK_PLL_RDY             0x01
+#define LOGICLK_PLL_EN              0x01
+#define LOGICLK_PLL_REG_EN          0x02
+
+
+struct logiclk_freq_out {
+	u32 freq_out_hz[LOGICLK_OUTPUTS];
+};
+
+/*
+	Calculates the output register valuess depending on the
+	"freq_out" and "c_osc_clk_freq_hz" inputs.
+	Writes them to array of LOGICLK_REGS over "regs_out" pointer.
+*/
+int logiclk_calc_regs(struct logiclk_freq_out *freq_out,
+	u32 c_osc_clk_freq_hz, u32 *regs_out);
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/logicvc.h
@@ -0,0 +1,211 @@
+/*
+ * Xylon logiCVC IP core v2.05c definitions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __LOGICVC_H__
+#define __LOGICVC_H__
+
+/* All logiCVC registers are 32 bit registers */
+/* All logiCVC registers are at 8 byte distance */
+#define LOGICVC_REG_DIST_USED      8
+/* R_HSY_FP */
+#define LOGICVC_SHSY_FP_ROFF      (0  * LOGICVC_REG_DIST_USED)
+/* R_HSY */
+#define LOGICVC_SHSY_ROFF         (1  * LOGICVC_REG_DIST_USED)
+/* R_HSY_BP */
+#define LOGICVC_SHSY_BP_ROFF      (2  * LOGICVC_REG_DIST_USED)
+/* R_HSY_RES */
+#define LOGICVC_SHSY_RES_ROFF     (3  * LOGICVC_REG_DIST_USED)
+/* R_VSY_FP */
+#define LOGICVC_SVSY_FP_ROFF      (4  * LOGICVC_REG_DIST_USED)
+/* R_VSY */
+#define LOGICVC_SVSY_ROFF         (5  * LOGICVC_REG_DIST_USED)
+/* R_VSY_BP */
+#define LOGICVC_SVSY_BP_ROFF      (6  * LOGICVC_REG_DIST_USED)
+/* R_VSY_RES */
+#define LOGICVC_SVSY_RES_ROFF     (7  * LOGICVC_REG_DIST_USED)
+/* R_CTRL */
+#define LOGICVC_SCTRL_ROFF        (8  * LOGICVC_REG_DIST_USED)
+/* R_DTYPE */
+#define LOGICVC_SDTYPE_ROFF       (9  * LOGICVC_REG_DIST_USED)
+/* R_BACKGROUND */
+#define LOGICVC_BACKCOL_ROFF      (10 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_VBUFF */
+#define LOGICVC_DOUBLE_VBUFF_ROFF (11 * LOGICVC_REG_DIST_USED)
+/* R_DOUBLE_CLUT */
+#define LOGICVC_DOUBLE_CLUT_ROFF  (12 * LOGICVC_REG_DIST_USED)
+/* R_INT_STAT */
+#define LOGICVC_INT_STAT_ROFF     (13 * LOGICVC_REG_DIST_USED)
+/* R_INT_MASK */
+#define LOGICVC_INT_MASK_ROFF     (14 * LOGICVC_REG_DIST_USED)
+/* R_PWRCTRL */
+#define LOGICVC_SPWRCTRL_ROFF     (15 * LOGICVC_REG_DIST_USED)
+/* R_IPVER */
+#define LOGICVC_IPVER_ROFF        (18 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC layer registers base and distance between the layers */
+/* distance between groups of layer registers */
+#define LOGICVC_LAYER_DISTANCE   (16  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 0 registers */
+#define LOGICVC_LAYER0_BASE_ROFF (32  * LOGICVC_REG_DIST_USED)
+/* offset to the beginning of layer 1 registers */
+#define LOGICVC_LAYER1_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 1)
+/* offset to the beginning of layer 2 registers */
+#define LOGICVC_LAYER2_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 2)
+/* offset to the beginning of layer 3 registers */
+#define LOGICVC_LAYER3_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 3)
+/* offset to the beginning of layer 4 registers */
+#define LOGICVC_LAYER4_BASE_ROFF \
+	(LOGICVC_LAYER0_BASE_ROFF + LOGICVC_LAYER_DISTANCE * 4)
+
+/* logiCVC layer registers offsets (common for each layer) */
+/*  LH_OFFSET */
+#define LOGICVC_LAYER_HOR_OFF_ROFF (0 * LOGICVC_REG_DIST_USED)
+/*  LV_OFFSET */
+#define LOGICVC_LAYER_VER_OFF_ROFF (1 * LOGICVC_REG_DIST_USED)
+/*  LH_POSITION */
+#define LOGICVC_LAYER_HOR_POS_ROFF (2 * LOGICVC_REG_DIST_USED)
+/*  LV_POSITION */
+#define LOGICVC_LAYER_VER_POS_ROFF (3 * LOGICVC_REG_DIST_USED)
+/*  LH_WIDTH */
+#define LOGICVC_LAYER_WIDTH_ROFF   (4 * LOGICVC_REG_DIST_USED)
+/*  LV_HEIGHT */
+#define LOGICVC_LAYER_HEIGHT_ROFF  (5 * LOGICVC_REG_DIST_USED)
+/*  ALPHA */
+#define LOGICVC_LAYER_ALPHA_ROFF   (6 * LOGICVC_REG_DIST_USED)
+/*  CTRL */
+#define LOGICVC_LAYER_CTRL_ROFF    (7 * LOGICVC_REG_DIST_USED)
+/*  TRANSPARENT */
+#define LOGICVC_LAYER_TRANSP_ROFF  (8 * LOGICVC_REG_DIST_USED)
+
+/* logiCVC interrupt bits */
+#define LOGICVC_L0_VBUFF_SW_INT   0x01
+#define LOGICVC_L1_VBUFF_SW_INT   0x02
+#define LOGICVC_L2_VBUFF_SW_INT   0x04
+#define LOGICVC_L3_VBUFF_SW_INT   0x08
+#define LOGICVC_L4_VBUFF_SW_INT   0x10
+#define LOGICVC_V_SYNC_INT        0x20
+#define LOGICVC_E_VIDEO_VALID_INT 0x40
+#define LOGICVC_L0_CLUT_SW_INT    0x100
+#define LOGICVC_L1_CLUT_SW_INT    0x200
+#define LOGICVC_L2_CLUT_SW_INT    0x400
+#define LOGICVC_L3_CLUT_SW_INT    0x800
+#define LOGICVC_L4_CLUT_SW_INT    0x1000
+
+/* logiCVC layer base offsets */
+#define LOGICVC_LAYER_OFFSET      0x80
+#define LOGICVC_LAYER_BASE_OFFSET 0x100
+#define LOGICVC_LAYER_0_OFFSET    0
+#define LOGICVC_LAYER_1_OFFSET \
+	(LOGICVC_LAYER_0_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_2_OFFSET \
+	(LOGICVC_LAYER_1_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_3_OFFSET \
+	(LOGICVC_LAYER_2_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_4_OFFSET \
+	(LOGICVC_LAYER_3_OFFSET + LOGICVC_LAYER_OFFSET)
+#define LOGICVC_LAYER_BASE_END    0x338
+
+/* logiCVC layer CLUT base offsets */
+#define LOGICVC_CLUT_OFFSET           0x800
+#define LOGICVC_CLUT_BASE_OFFSET      0x1000
+#define LOGICVC_CLUT_L0_CLUT_0_OFFSET 0
+#define LOGICVC_CLUT_L0_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L0_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L1_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L0_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L1_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L1_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L2_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L1_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L2_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L2_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L3_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L2_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L3_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L3_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L4_CLUT_0_OFFSET \
+	(LOGICVC_CLUT_L3_CLUT_1_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_L4_CLUT_1_OFFSET \
+	(LOGICVC_CLUT_L4_CLUT_0_OFFSET + LOGICVC_CLUT_OFFSET)
+#define LOGICVC_CLUT_REGISTER_SIZE    8
+#define LOGICVC_CLUT_0_INDEX_OFFSET   2
+#define LOGICVC_CLUT_1_INDEX_OFFSET   1
+
+/* logiCVC register and CLUT base offsets */
+#define LOGICVC_GENERAL_REGISTERS_RANGE 0x100
+#define LOGICVC_REGISTERS_RANGE         0x6000
+
+/* logiCVC register initial values */
+#define CTRL_REG_INIT 0x001F
+#define SD_REG_INIT   0
+
+/* logiCVC display power signals */
+#define LOGICVC_EN_BLIGHT_MSK 0x01
+#define LOGICVC_EN_VDD_MSK    0x02
+#define LOGICVC_EN_VEE_MSK    0x04
+#define LOGICVC_V_EN_MSK      0x08
+
+/* logiCVC various definitions */
+#define LOGICVC_PIX_DATA_INVERT        0x80
+#define LOGICVC_PIX_ACT_HIGH           0x100
+#define LOGICVC_LAYER_ON               0x01
+#define LOGICVC_SWAP_RB                0x10
+#define LOGICVC_MAX_LAYERS             5
+#define LOGICVC_MAX_LAYER_BUFFERS      3
+#define LOGICVC_MIN_XRES               64
+#define LOGICVC_MAX_XRES               2048
+#define LOGICVC_MIN_VRES               1
+#define LOGICVC_MAX_VRES               2048
+#define LOGICVC_MAX_LINES              4096
+#define LOGICVC_CLUT_SIZE              256
+#define TRANSPARENT_COLOR_8BPP         0x25       /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_16 0xF813     /* dummy */
+#define TRANSPARENT_COLOR_8BPP_CLUT_24 0x00FF009C /* dummy */
+#define TRANSPARENT_COLOR_16BPP        0xF813     /* dummy */
+#define TRANSPARENT_COLOR_24BPP        0x00FF009C /* dummy */
+#define BACKGROUND_COLOR               0x00000000
+
+#define LOGICVC_READABLE_REGS 0x01
+
+enum xylonfb_layer_type {
+	LOGICVC_RGB_LAYER = 0,
+	LOGICVC_YCBCR_LAYER,
+	LOGICVC_ALPHA_LAYER
+};
+
+enum xylonfb_alpha_format {
+	LOGICVC_LAYER_ALPHA = 0,
+	LOGICVC_PIXEL_ALPHA,
+	LOGICVC_CLUT_16BPP_ALPHA,
+	LOGICVC_CLUT_32BPP_ALPHA
+};
+
+enum xylonfb_display_interface {
+	LOGICVC_DI_PARALLEL = 0,
+	LOGICVC_DI_ITU656,
+	LOGICVC_DI_LVDS_4bit,
+	LOGICVC_DI_CAMERA_LINK_4bit,
+	LOGICVC_DI_LVDS_3bit,
+	LOGICVC_DI_DVI
+};
+
+enum xylonfb_display_color_space {
+	LOGICVC_DCS_RGB = 0,
+	LOGICVC_DCS_YUV422,
+	LOGICVC_DCS_YUV444
+};
+
+#endif /* __LOGICVC_H__ */
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/Makefile
@@ -0,0 +1,7 @@
+xylonfb_core-y := xylonfb.o xylonfb-ioctl.o xylonfb-pixclk.o
+xylonfb_core-$(CONFIG_FB_XYLON_PIXCLK_LOGICLK) += logiclk.o
+
+xylonfb_core-$(CONFIG_FB_XYLON_MISC) += ../misc/xylonfb-misc.o
+xylonfb_core-$(CONFIG_FB_XYLON_MISC_ADV7511) += ../misc/xylonfb-adv7511.o
+
+obj-y += xylonfb_core.o
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb.c
@@ -0,0 +1,1962 @@
+/*
+ * Xylon logiCVC frame buffer driver core functions
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was based on skeletonfb.c and other framebuffer video drivers.
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/console.h>
+#include <linux/videodev2.h>
+#include "xylonfb.h"
+#if defined(CONFIG_FB_XYLON_MISC)
+#include "../misc/xylonfb-misc.h"
+#endif
+
+
+#define XYLONFB_PSEUDO_PALETTE_SZ 256
+
+#define LOGICVC_PIX_FMT_AYUV  v4l2_fourcc('A', 'Y', 'U', 'V')
+#define LOGICVC_PIX_FMT_AVUY  v4l2_fourcc('A', 'V', 'U', 'Y')
+#define LOGICVC_PIX_FMT_ALPHA v4l2_fourcc('A', '8', ' ', ' ')
+
+
+static struct xylonfb_vmode_data xylonfb_vmode = {
+	.fb_vmode = {
+		.refresh = 60,
+		.xres = 1024,
+		.yres = 768,
+		.pixclock = KHZ2PICOS(65000),
+		.left_margin = 160,
+		.right_margin = 24,
+		.upper_margin = 29,
+		.lower_margin = 3,
+		.hsync_len = 136,
+		.vsync_len = 6,
+		.vmode = FB_VMODE_NONINTERLACED
+	},
+	.fb_vmode_name = "1024x768"
+};
+
+static unsigned short logicvc_layer_reg_offset[] = {
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_0_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_1_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_2_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_3_OFFSET),
+	(LOGICVC_LAYER_BASE_OFFSET + LOGICVC_LAYER_4_OFFSET)
+};
+
+static unsigned short logicvc_clut_reg_offset[] = {
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L0_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L1_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L2_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L3_CLUT_1_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_0_OFFSET),
+	(LOGICVC_CLUT_BASE_OFFSET + LOGICVC_CLUT_L4_CLUT_1_OFFSET)
+};
+
+static char *xylonfb_mode_option;
+
+/* Function declarations */
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp);
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable);
+static void xylonfb_enable_logicvc_output(struct fb_info *fbi);
+static void xylonfb_disable_logicvc_output(struct fb_info *fbi);
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi);
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi);
+static void xylonfb_fbi_update(struct fb_info *fbi);
+
+/******************************************************************************/
+
+static u32 xylonfb_get_reg(void *base_virt, unsigned long offset,
+	struct xylonfb_layer_data *ld)
+{
+	return readl(base_virt + offset);
+}
+
+static void xylonfb_set_reg(u32 value,
+	void *base_virt, unsigned long offset,
+	struct xylonfb_layer_data *ld)
+{
+	writel(value, (base_virt + offset));
+}
+
+static unsigned long xylonfb_get_reg_mem_addr(
+	void *base_virt, unsigned long offset,
+	struct xylonfb_layer_data *ld)
+{
+	unsigned long ordinal = offset >> 3;
+
+	if ((unsigned long)base_virt - (unsigned long)ld->reg_base_virt) {
+		return (unsigned long)(&ld->layer_reg_list->hpos_reg) +
+			(ordinal * sizeof(unsigned long));
+	} else {
+		return (unsigned long)(&ld->xylonfb_cd->reg_list->dtype_reg) +
+			(ordinal * sizeof(unsigned long));
+	}
+}
+
+static u32 xylonfb_get_reg_mem(
+	void *base_virt, unsigned long offset,
+	struct xylonfb_layer_data *ld)
+{
+	return *((unsigned long *)xylonfb_get_reg_mem_addr(
+		base_virt, offset, ld));
+}
+
+static void xylonfb_set_reg_mem(u32 value,
+	void *base_virt, unsigned long offset,
+	struct xylonfb_layer_data *ld)
+{
+	unsigned long *reg_mem_addr =
+		(unsigned long *)xylonfb_get_reg_mem_addr(
+			base_virt, offset, ld);
+	*reg_mem_addr = value;
+	writel((*reg_mem_addr), (base_virt + offset));
+}
+
+/******************************************************************************/
+
+static irqreturn_t xylonfb_isr(int irq, void *dev_id)
+{
+	struct fb_info **afbi = dev_get_drvdata(dev_id);
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 isr;
+
+	driver_devel("%s IRQ %d\n", __func__, irq);
+
+	isr = readl(ld->reg_base_virt + LOGICVC_INT_STAT_ROFF);
+	if (isr & LOGICVC_V_SYNC_INT) {
+		writel(LOGICVC_V_SYNC_INT,
+			ld->reg_base_virt + LOGICVC_INT_STAT_ROFF);
+		cd->vsync.cnt++;
+		wake_up_interruptible(&cd->vsync.wait);
+		return IRQ_HANDLED;
+	} else {
+		return IRQ_NONE;
+	}
+}
+
+/******************************************************************************/
+
+static int xylonfb_open(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	if (ld->layer_use_ref == 0) {
+		/* turn on layer */
+		xylonfb_enable_logicvc_layer(fbi);
+	}
+	ld->layer_use_ref++;
+	ld->xylonfb_cd->xylonfb_use_ref++;
+
+	return 0;
+}
+
+static int xylonfb_release(struct fb_info *fbi, int user)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	ld->layer_use_ref--;
+	if (ld->layer_use_ref == 0) {
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(fbi);
+	}
+	ld->xylonfb_cd->xylonfb_use_ref--;
+
+	return 0;
+}
+
+/******************************************************************************/
+
+static int xylonfb_check_var(struct fb_var_screeninfo *var,
+	struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_layer_fix_data *lfdata = &ld->layer_fix;
+
+	driver_devel("%s\n", __func__);
+
+	if (var->xres < LOGICVC_MIN_XRES)
+		var->xres = LOGICVC_MIN_XRES;
+	if (var->xres > LOGICVC_MAX_XRES)
+		var->xres = LOGICVC_MAX_XRES;
+	if (var->yres < LOGICVC_MIN_VRES)
+		var->yres = LOGICVC_MIN_VRES;
+	if (var->yres > LOGICVC_MAX_VRES)
+		var->yres = LOGICVC_MAX_VRES;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->xres_virtual > lfdata->width)
+		var->xres_virtual = lfdata->width;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+	if (var->yres_virtual > lfdata->height)
+		var->yres_virtual = lfdata->height;
+
+	if ((var->xoffset + var->xres) >= var->xres_virtual)
+		var->xoffset = var->xres_virtual - var->xres - 1;
+	if ((var->yoffset + var->yres) >= var->yres_virtual)
+		var->yoffset = var->yres_virtual - var->yres - 1;
+
+	if (var->bits_per_pixel != fbi->var.bits_per_pixel) {
+		if (var->bits_per_pixel == 24)
+			var->bits_per_pixel = 32;
+		else
+			var->bits_per_pixel = fbi->var.bits_per_pixel;
+	}
+
+	var->grayscale = fbi->var.grayscale;
+
+	var->transp.offset = fbi->var.transp.offset;
+	var->transp.length = fbi->var.transp.length;
+	var->transp.msb_right = fbi->var.transp.msb_right;
+	var->red.offset = fbi->var.red.offset;
+	var->red.length = fbi->var.red.length;
+	var->red.msb_right = fbi->var.red.msb_right;
+	var->green.offset = fbi->var.green.offset;
+	var->green.length = fbi->var.green.length;
+	var->green.msb_right = fbi->var.green.msb_right;
+	var->blue.offset = fbi->var.blue.offset;
+	var->blue.length = fbi->var.blue.length;
+	var->blue.msb_right = fbi->var.blue.msb_right;
+	var->height = fbi->var.height;
+	var->width = fbi->var.width;
+	var->sync = fbi->var.sync;
+	var->rotate = fbi->var.rotate;
+
+	return 0;
+}
+
+static int xylonfb_set_par(struct fb_info *fbi)
+{
+	struct fb_info **afbi = NULL;
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	int rc = 0;
+	int i;
+	char vmode_opt[VMODE_NAME_SZ];
+	bool resolution_change, layer_on[LOGICVC_MAX_LAYERS];
+
+	driver_devel("%s\n", __func__);
+
+	if (cd->xylonfb_flags & XYLONFB_FLAG_VMODE_SET)
+		return 0;
+
+	if (!(cd->xylonfb_flags & XYLONFB_FLAG_EDID_VMODE) &&
+		((fbi->var.xres ==
+			cd->vmode_data_current.fb_vmode.xres) ||
+		(fbi->var.yres ==
+			cd->vmode_data_current.fb_vmode.yres))) {
+		resolution_change = false;
+	} else {
+		resolution_change = true;
+	}
+
+	if (resolution_change ||
+		(cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT)) {
+
+		if (!(cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT)) {
+			struct xylonfb_layer_data *ld;
+			/* store id's of enabled layers */
+			afbi = dev_get_drvdata(fbi->device);
+			for (i = 0; i < cd->xylonfb_layers; i++) {
+				ld = afbi[i]->par;
+				if (ld->layer_ctrl_flags & LOGICVC_LAYER_ON)
+					layer_on[i] = true;
+				else
+					layer_on[i] = false;
+			}
+		}
+
+		xylonfb_disable_logicvc_output(fbi);
+		xylonfb_logicvc_disp_ctrl(fbi, false);
+
+		if (!(cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT)) {
+			/* we want 60Hz refresh rate */
+			cd->vmode_data_current.fb_vmode.refresh = 60;
+			sprintf(vmode_opt, "%dx%d%s-%d@%d%s",
+				fbi->var.xres, fbi->var.yres,
+				cd->vmode_data_current.fb_vmode_opts_cvt,
+				fbi->var.bits_per_pixel,
+				cd->vmode_data_current.fb_vmode.refresh,
+				cd->vmode_data_current.fb_vmode_opts_ext);
+			if (!strcmp(cd->vmode_data.fb_vmode_name, vmode_opt)) {
+				cd->vmode_data_current = cd->vmode_data;
+			} else {
+				xylonfb_mode_option = vmode_opt;
+				rc = xylonfb_set_timings(
+					fbi, fbi->var.bits_per_pixel);
+				xylonfb_mode_option = NULL;
+			}
+		}
+		if (!rc) {
+			if (cd->xylonfb_flags & XYLONFB_FLAG_PIXCLK_VALID) {
+				rc = xylonfb_hw_pixclk_set(
+					cd->xylonfb_pixclk_src_id,
+					PICOS2KHZ(cd->vmode_data_current.fb_vmode.pixclock));
+				if (rc)
+					pr_err("Error xylonfb changing pixel clock\n");
+			}
+			xylonfb_fbi_update(fbi);
+			pr_info("xylonfb video mode: %dx%d%s-%d@%d%s\n",
+				fbi->var.xres, fbi->var.yres,
+				cd->vmode_data_current.fb_vmode_opts_cvt,
+				fbi->var.bits_per_pixel,
+				cd->vmode_data_current.fb_vmode.refresh,
+				cd->vmode_data_current.fb_vmode_opts_ext);
+		}
+
+		xylonfb_enable_logicvc_output(fbi);
+		xylonfb_logicvc_disp_ctrl(fbi, true);
+
+		/* set flag used for finding video mode only once */
+		if (cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT)
+			cd->xylonfb_flags |= XYLONFB_FLAG_VMODE_SET;
+		/* used only when resolution is changed */
+		if (!(cd->xylonfb_flags & XYLONFB_FLAG_VMODE_SET)) {
+			if (afbi) {
+				for (i = 0; i < cd->xylonfb_layers; i++)
+					if (layer_on[i])
+						xylonfb_enable_logicvc_layer(afbi[i]);
+			} else {
+				xylonfb_enable_logicvc_layer(fbi);
+			}
+		}
+	}
+
+	return rc;
+}
+
+static int xylonfb_set_color_hw_rgb_to_yuv(
+	u16 *transp, u16 *red, u16 *green, u16 *blue, int len, int idx,
+	struct xylonfb_layer_data *ld)
+{
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 yuv_pixel;
+	u32 y, cb, cr;
+	u32 ykr, ykg, ykb, yk;
+	u32 crkr, crkg, crkb;
+	u32 cbkr, cbkg, cbkb;
+
+	driver_devel("%s\n", __func__);
+
+	if (idx > (LOGICVC_CLUT_SIZE-1) || len > LOGICVC_CLUT_SIZE)
+		return -EINVAL;
+
+	if ((cd->xylonfb_display_interface_type >> 4) == LOGICVC_DI_ITU656) {
+		ykr  = 29900;
+		ykg  = 58700;
+		ykb  = 11400;
+		yk   = 1600000;
+		crkr = 51138;
+		crkg = 42820;
+		crkb = 8316;
+		cbkr = 17258;
+		cbkg = 33881;
+		cbkb = 51140;
+	} else {
+		ykr  = 29900;
+		ykg  = 58700;
+		ykb  = 11400;
+		yk   = 0;
+		crkr = 49980;
+		crkg = 41850;
+		crkb = 8128;
+		cbkr = 16868;
+		cbkg = 33107;
+		cbkb = 49970;
+	}
+
+	while (len > 0) {
+		y = (
+				(ykr * (red[idx] & 0xFF))
+					+
+				(ykg * (green[idx] & 0xFF))
+					+
+				(ykb * (blue[idx] & 0xFF))
+					+
+				 yk
+			)
+				/
+			100000;
+		cr = (
+				(crkr * (red[idx] & 0xFF))
+					-
+				(crkg * (green[idx] & 0xFF))
+					-
+				(crkb * (blue[idx] & 0xFF))
+					+
+				 12800000
+			 )
+				/
+			100000;
+		cb = (
+				(-cbkr * (red[idx] & 0xFF))
+					-
+				(cbkg * (green[idx] & 0xFF))
+					+
+				(cbkb * (blue[idx] & 0xFF))
+					+
+				12800000
+			 )
+				/
+			100000;
+		if (transp) {
+			yuv_pixel = (((u32)transp[idx] & 0xFF) << 24) |
+				(y << 16) | (cb << 8) | cr;
+		} else {
+			yuv_pixel =
+				(0xFF << 24) | (y << 16) | (cb << 8) | cr;
+		}
+		writel(yuv_pixel, ld->layer_clut_base_virt +
+			(idx*LOGICVC_CLUT_REGISTER_SIZE));
+		len--;
+		idx++;
+	}
+
+	return 0;
+}
+
+static int xylonfb_set_color_hw(u16 *transp, u16 *red, u16 *green, u16 *blue,
+	int len, int idx, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_layer_fix_data *lfdata = &ld->layer_fix;
+	u32 pixel;
+	int bpp_virt, toff, roff, goff, boff;
+
+	driver_devel("%s\n", __func__);
+
+	if ((fbi->fix.visual == FB_VISUAL_FOURCC) &&
+		(fbi->var.grayscale == LOGICVC_PIX_FMT_AYUV)) {
+		return xylonfb_set_color_hw_rgb_to_yuv(
+			transp, red, green, blue, len, idx, ld);
+	}
+
+	bpp_virt = lfdata->bpp_virt;
+
+	toff = fbi->var.transp.offset;
+	roff = fbi->var.red.offset;
+	goff = fbi->var.green.offset;
+	boff = fbi->var.blue.offset;
+
+	if (fbi->fix.visual == FB_VISUAL_PSEUDOCOLOR) {
+		u32 clut_value;
+
+		if (idx > (LOGICVC_CLUT_SIZE-1) || len > LOGICVC_CLUT_SIZE)
+			return -EINVAL;
+
+		if (lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						((((transp[idx] & 0xFC) >> 2) << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value,
+						ld->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0x3F << toff) |
+						(((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					writel(clut_value,
+						ld->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		} else if (lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA) {
+			if (transp) {
+				while (len > 0) {
+					clut_value =
+						(((transp[idx] & 0xFF) << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value,
+						ld->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			} else {
+				while (len > 0) {
+					clut_value =
+						((0xFF << toff) |
+						((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					writel(clut_value,
+						ld->layer_clut_base_virt +
+						(idx*LOGICVC_CLUT_REGISTER_SIZE));
+					len--;
+					idx++;
+				}
+			}
+		}
+	} else if (fbi->fix.visual == FB_VISUAL_TRUECOLOR) {
+		if (bpp_virt == 8) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xE0) >> 5) << roff) |
+						(((green[idx] & 0xE0) >> 5) << goff) |
+						(((blue[idx] & 0xC0) >> 6) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 24) | (pixel << 16) | (pixel << 8) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						pixel = ((((transp[idx] & 0xE0) >> 5) << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						pixel = ((0x07 << toff) |
+							(((red[idx] & 0xE0) >> 5) << roff) |
+							(((green[idx] & 0xE0) >> 5) << goff) |
+							(((blue[idx] & 0xC0) >> 6) << boff));
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(pixel << 16) | pixel;
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 16) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					pixel = ((((red[idx] & 0xF8) >> 3) << roff) |
+						(((green[idx] & 0xFC) >> 2) << goff) |
+						(((blue[idx] & 0xF8) >> 3) << boff));
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(pixel << 16) | pixel;
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((((transp[idx] & 0xFC) >> 2) << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0x3F << toff) |
+							(((red[idx] & 0xF8) >> 3) << roff) |
+							(((green[idx] & 0xFC) >> 2) << goff) |
+							(((blue[idx] & 0xF8) >> 3) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		} else if (bpp_virt == 32) {
+			if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+				while (len > 0) {
+					((u32 *)(fbi->pseudo_palette))[idx] =
+						(((red[idx] & 0xFF) << roff) |
+						((green[idx] & 0xFF) << goff) |
+						((blue[idx] & 0xFF) << boff));
+					len--;
+					idx++;
+				}
+			} else if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA) {
+				if (transp) {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							(((transp[idx] & 0xFF) << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				} else {
+					while (len > 0) {
+						((u32 *)(fbi->pseudo_palette))[idx] =
+							((0xFF << toff) |
+							((red[idx] & 0xFF) << roff) |
+							((green[idx] & 0xFF) << goff) |
+							((blue[idx] & 0xFF) << boff));
+						len--;
+						idx++;
+					}
+				}
+			}
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_set_color_reg(unsigned regno, unsigned red, unsigned green,
+	unsigned blue, unsigned transp, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_set_color_hw(
+		(u16 *)&transp, (u16 *)&red, (u16 *)&green, (u16 *)&blue,
+		1, regno, fbi);
+}
+
+static int xylonfb_set_cmap(struct fb_cmap *cmap, struct fb_info *fbi)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_set_color_hw(
+		cmap->transp, cmap->red, cmap->green, cmap->blue,
+		cmap->len, cmap->start, fbi);
+}
+
+static void xylonfb_set_pixels(struct fb_info *fbi,
+	struct xylonfb_layer_data *ld, int bpp, unsigned int pix)
+{
+	u32 *vmem;
+	u8 *vmem8;
+	u16 *vmem16;
+	u32 *vmem32;
+	int x, y, pix_off;
+
+	driver_devel("%s\n", __func__);
+
+	vmem = ld->fb_virt +
+		(fbi->var.xoffset * (fbi->var.bits_per_pixel/4)) +
+		(fbi->var.yoffset * fbi->var.xres_virtual *
+		(fbi->var.bits_per_pixel/4));
+
+	switch (bpp) {
+	case 8:
+		vmem8 = (u8 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem8[pix_off+x] = pix;
+		}
+		break;
+	case 16:
+		vmem16 = (u16 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem16[pix_off+x] = pix;
+		}
+		break;
+	case 32:
+		vmem32 = (u32 *)vmem;
+		for (y = fbi->var.yoffset; y < fbi->var.yres; y++) {
+			pix_off = (y * fbi->var.xres_virtual);
+			for (x = fbi->var.xoffset; x < fbi->var.xres; x++)
+				vmem32[pix_off+x] = pix;
+		}
+		break;
+	}
+}
+
+static int xylonfb_blank(int blank_mode, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_layer_fix_data *lfdata = &ld->layer_fix;
+	u32 reg;
+
+	driver_devel("%s\n", __func__);
+
+	switch (blank_mode) {
+	case FB_BLANK_UNBLANK:
+		driver_devel("FB_BLANK_UNBLANK\n");
+		reg = readl(ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg |= LOGICVC_V_EN_MSK;
+		writel(reg, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_NORMAL:
+		driver_devel("FB_BLANK_NORMAL\n");
+		switch (lfdata->bpp_virt) {
+		case 8:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, ld, 8, 0x00);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, ld, 16, 0xFF00);
+				break;
+			case LOGICVC_CLUT_16BPP_ALPHA:
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				xylonfb_set_color_reg(0, 0, 0, 0, 0xFF, fbi);
+				xylonfb_set_pixels(fbi, ld, 8, 0);
+				break;
+			}
+			break;
+		case 16:
+			switch (lfdata->alpha_mode) {
+			case LOGICVC_LAYER_ALPHA:
+				xylonfb_set_pixels(fbi, ld, 16, 0x0000);
+				break;
+			case LOGICVC_PIXEL_ALPHA:
+				xylonfb_set_pixels(fbi, ld, 32, 0xFF000000);
+				break;
+			}
+			break;
+		case 32:
+			xylonfb_set_pixels(fbi, ld, 32, 0xFF000000);
+			break;
+		}
+		break;
+
+	case FB_BLANK_POWERDOWN:
+		driver_devel("FB_BLANK_POWERDOWN\n");
+		reg = readl(ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		reg &= ~LOGICVC_V_EN_MSK;
+		writel(reg, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(50);
+		break;
+
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	default:
+		driver_devel("FB_BLANK_ not supported!\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int xylonfb_pan_display(struct fb_var_screeninfo *var,
+	struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+
+	driver_devel("%s\n", __func__);
+
+	if (fbi->var.xoffset == var->xoffset &&
+		fbi->var.yoffset == var->yoffset)
+		return 0;
+
+	if (fbi->var.vmode & FB_VMODE_YWRAP) {
+		return -EINVAL;
+	} else {
+		if (var->xoffset + fbi->var.xres > fbi->var.xres_virtual ||
+			var->yoffset + fbi->var.yres > fbi->var.yres_virtual) {
+			/* if smaller then physical layer video memory
+			   allow panning */
+			if ((var->xoffset + fbi->var.xres > ld->layer_fix.width)
+					||
+				(var->yoffset + fbi->var.yres > ld->layer_fix.height)) {
+				return -EINVAL;
+			}
+		}
+	}
+	/* YCbCr 4:2:2 layer type can only have even layer xoffset */
+	if (ld->layer_fix.layer_type == LOGICVC_YCBCR_LAYER &&
+		ld->layer_fix.bpp_virt == 16) {
+		var->xoffset &= ~1;
+	}
+
+	fbi->var.xoffset = var->xoffset;
+	fbi->var.yoffset = var->yoffset;
+	/* set layer memory X offset */
+	cd->reg_access.xylonfb_set_reg_val(var->xoffset,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_HOR_OFF_ROFF,
+		ld);
+	/* set layer memory Y offset */
+	cd->reg_access.xylonfb_set_reg_val(var->yoffset,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_VER_OFF_ROFF,
+		ld);
+	cd->reg_access.xylonfb_set_reg_val((fbi->var.xres-1),
+		ld->layer_reg_base_virt, LOGICVC_LAYER_HOR_POS_ROFF,
+		ld);
+	/* apply changes in logiCVC */
+	cd->reg_access.xylonfb_set_reg_val((fbi->var.yres-1),
+		ld->layer_reg_base_virt, LOGICVC_LAYER_VER_POS_ROFF,
+		ld);
+
+	return 0;
+}
+
+
+static struct fb_ops xylonfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = xylonfb_open,
+	.fb_release = xylonfb_release,
+	.fb_check_var = xylonfb_check_var,
+	.fb_set_par = xylonfb_set_par,
+	.fb_setcolreg = xylonfb_set_color_reg,
+	.fb_setcmap = xylonfb_set_cmap,
+	.fb_blank = xylonfb_blank,
+	.fb_pan_display = xylonfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = NULL,
+	.fb_sync = NULL,
+	.fb_ioctl = xylonfb_ioctl,
+	.fb_mmap = NULL,
+	.fb_get_caps = NULL,
+	.fb_destroy = NULL,
+};
+
+/******************************************************************************/
+
+static int xylonfb_find_next_layer(struct xylonfb_layer_fix_data *lfdata,
+	int layers, int curr)
+{
+	unsigned long address, temp_address, loop_address;
+	int i, next;
+
+	driver_devel("%s\n", __func__);
+
+	address = lfdata[curr].offset * lfdata[curr].width * lfdata[curr].bpp;
+	temp_address = ~0;
+	next = -1;
+
+	for (i = 0; i < layers; i++) {
+		loop_address =
+			lfdata[i].offset * lfdata[i].width * lfdata[i].bpp;
+		if (address < loop_address
+				&&
+			loop_address < temp_address) {
+			next = i;
+			temp_address = loop_address;
+		}
+	}
+
+	return next;
+}
+
+static void xylonfb_set_yvirt(struct xylonfb_init_data *init_data,
+	int layers, int curr)
+{
+	struct xylonfb_layer_fix_data *lfdata;
+	unsigned long vmem_base_addr, vmem_high_addr;
+	int next;
+
+	driver_devel("%s\n", __func__);
+
+	lfdata = init_data->lfdata;
+	vmem_base_addr = init_data->vmem_base_addr;
+	vmem_high_addr = init_data->vmem_high_addr;
+
+	next = xylonfb_find_next_layer(lfdata, layers, curr);
+
+	if (next != -1) {
+		lfdata[curr].height =
+			((lfdata[next].width * (lfdata[next].bpp/8) *
+			lfdata[next].offset)
+				-
+			(lfdata[curr].width * (lfdata[curr].bpp/8) *
+			lfdata[curr].offset))
+				/
+			(lfdata[curr].width * (lfdata[curr].bpp/8));
+	} else { /* last physical logiCVC layer */
+		lfdata[curr].height = LOGICVC_MAX_LINES + 1;
+		while (1) {
+			if (((lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].height)
+					+
+				(lfdata[curr].width * (lfdata[curr].bpp/8) *
+				lfdata[curr].offset))
+					<=
+				(vmem_high_addr - vmem_base_addr))
+				break;
+			/* FIXME - magic decrease step */
+			lfdata[curr].height -= 64;
+		}
+	}
+
+	if (lfdata[curr].height >
+		(lfdata[curr].buffer_offset * LOGICVC_MAX_LAYER_BUFFERS)) {
+		lfdata[curr].height =
+			lfdata[curr].buffer_offset * LOGICVC_MAX_LAYER_BUFFERS;
+	}
+
+	lfdata[curr].layer_fix_info |=
+		((lfdata[curr].height / lfdata[curr].buffer_offset) << 4);
+}
+
+static int xylonfb_map(int id, int layers, struct device *dev,
+	struct xylonfb_layer_data *ld,
+	unsigned long vmem_base_addr,
+	unsigned long reg_base_phys, void *reg_base_virt,
+	int memmap)
+{
+	struct xylonfb_layer_fix_data *lfdata = &ld->layer_fix;
+
+	driver_devel("%s\n", __func__);
+
+	/* logiCVC register mapping */
+	ld->reg_base_phys = reg_base_phys;
+	ld->reg_base_virt = reg_base_virt;
+	/* check register mappings */
+	if (!ld->reg_base_virt) {
+		pr_err("Error xylonfb registers mapping\n");
+		return -ENOMEM;
+	}
+	/* Video memory mapping */
+	ld->fb_phys = vmem_base_addr +
+		(lfdata->width * (lfdata->bpp/8) * lfdata->offset);
+	ld->fb_size =
+		lfdata->width * (lfdata->bpp/8) * lfdata->height;
+
+	if (memmap) {
+		if (ld->xylonfb_cd->xylonfb_flags & XYLONFB_FLAG_DMA_BUFFER) {
+			/* NOT USED FOR NOW! */
+			ld->fb_virt = dma_alloc_coherent(NULL,
+				PAGE_ALIGN(ld->fb_size),
+				&ld->fb_phys, GFP_KERNEL);
+		} else {
+			ld->fb_virt =
+				ioremap_wc(ld->fb_phys, ld->fb_size);
+		}
+		/* check memory mappings */
+		if (!ld->fb_virt) {
+			pr_err("Error xylonfb vmem mapping\n");
+			return -ENOMEM;
+		}
+	}
+	ld->layer_reg_base_virt = ld->reg_base_virt +
+		logicvc_layer_reg_offset[id];
+	ld->layer_clut_base_virt = ld->reg_base_virt +
+		logicvc_clut_reg_offset[id*LOGICVC_CLUT_0_INDEX_OFFSET];
+	ld->layer_use_ref = 0;
+	ld->layer_ctrl_flags = 0;
+
+	return 0;
+}
+
+static void xylonfb_set_fbi_var_screeninfo(struct fb_var_screeninfo *var,
+	struct xylonfb_common_data *cd)
+{
+	driver_devel("%s\n", __func__);
+
+	var->xres = cd->vmode_data_current.fb_vmode.xres;
+	var->yres = cd->vmode_data_current.fb_vmode.yres;
+	var->pixclock = cd->vmode_data_current.fb_vmode.pixclock;
+	var->left_margin = cd->vmode_data_current.fb_vmode.left_margin;
+	var->right_margin = cd->vmode_data_current.fb_vmode.right_margin;
+	var->upper_margin = cd->vmode_data_current.fb_vmode.upper_margin;
+	var->lower_margin = cd->vmode_data_current.fb_vmode.lower_margin;
+	var->hsync_len = cd->vmode_data_current.fb_vmode.hsync_len;
+	var->vsync_len = cd->vmode_data_current.fb_vmode.vsync_len;
+	var->sync = cd->vmode_data_current.fb_vmode.sync;
+	var->vmode = cd->vmode_data_current.fb_vmode.vmode;
+}
+
+static void xylonfb_fbi_update(struct fb_info *fbi)
+{
+	struct fb_info **afbi = dev_get_drvdata(fbi->device);
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	int i, layers, layer_id;
+
+	driver_devel("%s\n", __func__);
+
+	if (!(cd->xylonfb_flags & XYLONFB_FLAG_EDID_VMODE) ||
+		!(cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY) ||
+		!afbi)
+		return;
+
+	layers = cd->xylonfb_layers;
+	layer_id = ld->layer_fix.layer_fix_info & 0x0F;
+
+	for (i = 0; i < layers; i++) {
+		if (i == layer_id)
+			continue;
+		xylonfb_set_fbi_var_screeninfo(&afbi[i]->var, cd);
+		afbi[i]->monspecs = afbi[layer_id]->monspecs;
+	}
+}
+
+static void xylonfb_set_hw_specifics(struct fb_info *fbi,
+	struct xylonfb_layer_data *ld,
+	struct xylonfb_layer_fix_data *lfdata,
+	unsigned long reg_base_phys)
+{
+	driver_devel("%s\n", __func__);
+
+	fbi->fix.smem_start = ld->fb_phys;
+	fbi->fix.smem_len = ld->fb_size;
+	if (lfdata->layer_type == LOGICVC_RGB_LAYER)
+		fbi->fix.type = FB_TYPE_PACKED_PIXELS;
+	else if (lfdata->layer_type == LOGICVC_YCBCR_LAYER)
+		fbi->fix.type = FB_TYPE_FOURCC;
+	if ((lfdata->layer_type == LOGICVC_YCBCR_LAYER) ||
+		(lfdata->layer_type == LOGICVC_ALPHA_LAYER)) {
+		fbi->fix.visual = FB_VISUAL_FOURCC;
+	} else if ((lfdata->layer_type == LOGICVC_RGB_LAYER) &&
+		(lfdata->bpp == 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		fbi->fix.visual = FB_VISUAL_PSEUDOCOLOR;
+	} else {
+		/*
+			Other logiCVC layer pixel formats:
+			- 8 bpp: LAYER or PIXEL alpha
+			  It is not true color, RGB triplet is stored in 8 bits.
+			- 16 bpp:
+			  LAYER alpha: RGB triplet is stored in 16 bits
+			  PIXEL alpha: ARGB quadriplet is stored in 32 bits
+			- 32 bpp: LAYER or PIXEL alpha
+			  True color, RGB triplet or ARGB quadriplet
+			  is stored in 32 bits.
+		*/
+		fbi->fix.visual = FB_VISUAL_TRUECOLOR;
+	}
+	/* sanity check */
+	if ((lfdata->bpp != 8) &&
+		((lfdata->alpha_mode == LOGICVC_CLUT_16BPP_ALPHA) ||
+		(lfdata->alpha_mode == LOGICVC_CLUT_32BPP_ALPHA))) {
+		pr_warn("xylonfb invalid layer alpha!\n");
+		lfdata->alpha_mode = LOGICVC_LAYER_ALPHA;
+	}
+	fbi->fix.xpanstep = 1;
+	fbi->fix.ypanstep = 1;
+	fbi->fix.ywrapstep = 0;
+	fbi->fix.line_length = lfdata->width * (lfdata->bpp/8);
+	fbi->fix.mmio_start = reg_base_phys;
+	fbi->fix.mmio_len = LOGICVC_REGISTERS_RANGE;
+	fbi->fix.accel = FB_ACCEL_NONE;
+
+	fbi->var.xres_virtual = lfdata->width;
+	if (lfdata->height <= LOGICVC_MAX_LINES)
+		fbi->var.yres_virtual = lfdata->height;
+	else
+		fbi->var.yres_virtual = LOGICVC_MAX_LINES;
+	fbi->var.bits_per_pixel = lfdata->bpp;
+	switch (lfdata->layer_type) {
+	case LOGICVC_RGB_LAYER:
+		fbi->var.grayscale = 0;
+		break;
+	case LOGICVC_YCBCR_LAYER:
+		if (lfdata->bpp == 8) {
+			fbi->var.grayscale = LOGICVC_PIX_FMT_AYUV;
+		} else if (lfdata->bpp == 16) {
+			if (ld->layer_ctrl_flags & LOGICVC_SWAP_RB)
+				fbi->var.grayscale = V4L2_PIX_FMT_YVYU;
+			else
+				fbi->var.grayscale = V4L2_PIX_FMT_VYUY;
+		} else if (lfdata->bpp == 32) {
+			if (ld->layer_ctrl_flags & LOGICVC_SWAP_RB)
+				fbi->var.grayscale = LOGICVC_PIX_FMT_AVUY;
+			else
+				fbi->var.grayscale = LOGICVC_PIX_FMT_AYUV;
+		}
+		break;
+	case LOGICVC_ALPHA_LAYER:
+		/* logiCVC Alpha layer 8bpp */
+		fbi->var.grayscale = LOGICVC_PIX_FMT_ALPHA;
+		break;
+	}
+
+	/*
+		Set values according to logiCVC layer data width configuration:
+		- layer data width can be 1, 2, 4 bytes
+		- layer data width for 16 bpp can be 2 or 4 bytes
+	*/
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA) {
+		fbi->var.transp.offset = 0;
+		fbi->var.transp.length = 0;
+	}
+	switch (lfdata->bpp_virt) {
+	case 8:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 8;
+			fbi->var.transp.length = 3;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 5;
+			fbi->var.red.length = 3;
+			fbi->var.green.offset = 2;
+			fbi->var.green.length = 3;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 2;
+			break;
+
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+			fbi->var.red.offset = 19;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 10;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 3;
+			fbi->var.blue.length = 5;
+			break;
+
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	case 16:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 6;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 11;
+			fbi->var.red.length = 5;
+			fbi->var.green.offset = 5;
+			fbi->var.green.length = 6;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 5;
+			break;
+		}
+		break;
+	case 32:
+		switch (lfdata->alpha_mode) {
+		case LOGICVC_PIXEL_ALPHA:
+			fbi->var.transp.offset = 24;
+			fbi->var.transp.length = 8;
+
+		case LOGICVC_LAYER_ALPHA:
+			fbi->var.red.offset = 16;
+			fbi->var.red.length = 8;
+			fbi->var.green.offset = 8;
+			fbi->var.green.length = 8;
+			fbi->var.blue.offset = 0;
+			fbi->var.blue.length = 8;
+			break;
+		}
+		break;
+	}
+	fbi->var.transp.msb_right = 0;
+	fbi->var.red.msb_right = 0;
+	fbi->var.green.msb_right = 0;
+	fbi->var.blue.msb_right = 0;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	fbi->var.height = 0;
+	fbi->var.width = 0;
+	fbi->var.sync = 0;
+	fbi->var.rotate = 0;
+}
+
+static int xylonfb_set_timings(struct fb_info *fbi, int bpp)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	struct fb_var_screeninfo fb_var;
+	int rc;
+
+	driver_devel("%s\n", __func__);
+
+	if ((cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT) &&
+		(!(cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY)) &&
+		memchr(cd->vmode_data.fb_vmode_name, 'x', 10)) {
+		cd->vmode_data_current = cd->vmode_data;
+		return 0;
+	}
+
+	/* switch-case to default */
+	rc = 255;
+	if ((cd->xylonfb_flags & XYLONFB_FLAG_EDID_VMODE) &&
+		(cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY)) {
+		if (cd->xylonfb_flags & XYLONFB_FLAG_VMODE_INIT) {
+#if defined(CONFIG_FB_XYLON_MISC)
+			fb_var = *(cd->xylonfb_misc->var_screeninfo);
+#endif
+		} else {
+			rc = fb_find_mode(&fb_var, fbi, xylonfb_mode_option,
+				fbi->monspecs.modedb, fbi->monspecs.modedb_len,
+				&xylonfb_vmode.fb_vmode, bpp);
+			if ((rc != 1) && (rc != 2))
+				return -EINVAL;
+#if defined(CONFIG_FB_XYLON_MISC)
+			if (fbi->monspecs.modedb &&
+				cd->xylonfb_misc->monspecs->misc & FB_MISC_1ST_DETAIL)
+				if ((fbi->var.xres == fbi->monspecs.modedb[0].xres) &&
+					(fbi->var.yres == fbi->monspecs.modedb[0].yres)) {
+					fb_videomode_to_var(&fb_var, &fbi->monspecs.modedb[0]);
+				}
+#endif
+		}
+	} else {
+		rc = fb_find_mode(&fb_var, fbi, xylonfb_mode_option, NULL, 0,
+			&xylonfb_vmode.fb_vmode, bpp);
+	}
+#ifdef DEBUG
+	switch (rc) {
+	case 0:
+		pr_err("Error xylonfb video mode\n"
+			"using driver default mode %dx%dM-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres,
+			xylonfb_vmode.fb_vmode.yres,
+			bpp,
+			xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 1:
+		driver_devel("xylonfb video mode %s\n", xylonfb_mode_option);
+		break;
+	case 2:
+		pr_notice("xylonfb video mode %s with ignored refresh rate\n",
+			xylonfb_mode_option);
+		break;
+	case 3:
+		pr_notice("xylonfb default video mode %dx%dM-%d@%d\n",
+			xylonfb_vmode.fb_vmode.xres,
+			xylonfb_vmode.fb_vmode.yres,
+			bpp,
+			xylonfb_vmode.fb_vmode.refresh);
+		break;
+	case 4:
+		pr_notice("xylonfb video mode fallback\n");
+		break;
+	default:
+		break;
+	}
+#endif
+
+	cd->vmode_data_current.ctrl_reg = cd->vmode_data.ctrl_reg;
+	cd->vmode_data_current.fb_vmode.xres = fb_var.xres;
+	cd->vmode_data_current.fb_vmode.yres = fb_var.yres;
+	cd->vmode_data_current.fb_vmode.pixclock = fb_var.pixclock;
+	cd->vmode_data_current.fb_vmode.left_margin = fb_var.left_margin;
+	cd->vmode_data_current.fb_vmode.right_margin = fb_var.right_margin;
+	cd->vmode_data_current.fb_vmode.upper_margin = fb_var.upper_margin;
+	cd->vmode_data_current.fb_vmode.lower_margin = fb_var.lower_margin;
+	cd->vmode_data_current.fb_vmode.hsync_len = fb_var.hsync_len;
+	cd->vmode_data_current.fb_vmode.vsync_len = fb_var.vsync_len;
+	cd->vmode_data_current.fb_vmode.sync = fb_var.sync;
+	cd->vmode_data_current.fb_vmode.vmode = fb_var.vmode;
+	cd->vmode_data_current.fb_vmode.refresh =
+		DIV_ROUND_CLOSEST(
+			(PICOS2KHZ(fb_var.pixclock) * 1000),
+			((fb_var.xres + fb_var.left_margin +
+			fb_var.right_margin + fb_var.hsync_len)
+				*
+			(fb_var.yres + fb_var.upper_margin +
+			fb_var.lower_margin + fb_var.vsync_len)));
+	strcpy(cd->vmode_data_current.fb_vmode_opts_cvt,
+		cd->vmode_data.fb_vmode_opts_cvt);
+	strcpy(cd->vmode_data_current.fb_vmode_opts_ext,
+		cd->vmode_data.fb_vmode_opts_ext);
+	sprintf(cd->vmode_data_current.fb_vmode_name,
+		"%dx%d%s-%d@%d%s",
+		fb_var.xres, fb_var.yres,
+		cd->vmode_data_current.fb_vmode_opts_cvt,
+		fb_var.bits_per_pixel,
+		cd->vmode_data_current.fb_vmode.refresh,
+		cd->vmode_data_current.fb_vmode_opts_ext);
+
+	if ((cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY) ||
+		!memchr(cd->vmode_data.fb_vmode_name, 'x', 10)) {
+		cd->vmode_data = cd->vmode_data_current;
+	}
+
+	return 0;
+}
+
+static int xylonfb_register_fb(struct fb_info *fbi,
+	struct xylonfb_layer_data *ld,
+	unsigned long reg_base_phys, int id, int *regfb)
+{
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	struct xylonfb_layer_fix_data *lfdata = &ld->layer_fix;
+	int alpha;
+
+	driver_devel("%s\n", __func__);
+
+	fbi->flags = FBINFO_DEFAULT;
+	fbi->screen_base = (char __iomem *)ld->fb_virt;
+	fbi->screen_size = ld->fb_size;
+	fbi->pseudo_palette =
+		kzalloc(sizeof(u32) * XYLONFB_PSEUDO_PALETTE_SZ, GFP_KERNEL);
+	fbi->fbops = &xylonfb_ops;
+
+	sprintf(fbi->fix.id, "Xylon FB%d", id);
+	xylonfb_set_hw_specifics(fbi, ld, lfdata, reg_base_phys);
+	if (!(cd->xylonfb_flags & XYLONFB_FLAG_DEFAULT_VMODE_SET)) {
+		xylonfb_set_timings(fbi, fbi->var.bits_per_pixel);
+		cd->xylonfb_flags |= XYLONFB_FLAG_DEFAULT_VMODE_SET;
+	}
+	xylonfb_set_fbi_var_screeninfo(&fbi->var, cd);
+	fbi->mode = &cd->vmode_data_current.fb_vmode;
+	fbi->mode->name = cd->vmode_data_current.fb_vmode_name;
+
+	if (lfdata->alpha_mode == LOGICVC_LAYER_ALPHA)
+		alpha = 0;
+	else
+		alpha = 1;
+	if (fb_alloc_cmap(&fbi->cmap, XYLONFB_PSEUDO_PALETTE_SZ, alpha))
+		return -ENOMEM;
+
+	*regfb = register_framebuffer(fbi);
+	if (*regfb) {
+		pr_err("Error xylonfb registering xylonfb %d\n", id);
+		return -EINVAL;
+	}
+	pr_info("xylonfb %d registered\n", id);
+	/* after fb driver registration, values in struct fb_info
+		must not be changed anywhere else except in xylonfb_set_par */
+
+	return 0;
+}
+
+static void xylonfb_init_layer_regs(struct xylonfb_layer_data *ld)
+{
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 reg_val;
+
+	switch (ld->layer_fix.bpp_virt) {
+	case 8:
+		switch (ld->layer_fix.alpha_mode) {
+		case LOGICVC_CLUT_16BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_16;
+			break;
+		case LOGICVC_CLUT_32BPP_ALPHA:
+			reg_val = TRANSPARENT_COLOR_8BPP_CLUT_24;
+			break;
+		default:
+			reg_val = TRANSPARENT_COLOR_8BPP;
+			break;
+		}
+		break;
+	case 16:
+		reg_val = TRANSPARENT_COLOR_16BPP;
+		break;
+	case 32:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	default:
+		reg_val = TRANSPARENT_COLOR_24BPP;
+		break;
+	}
+	cd->reg_access.xylonfb_set_reg_val(reg_val,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_TRANSP_ROFF,
+		ld);
+
+	if (!(cd->xylonfb_flags & LOGICVC_READABLE_REGS))
+		cd->reg_access.xylonfb_set_reg_val(0xFF,
+			ld->layer_reg_base_virt, LOGICVC_LAYER_ALPHA_ROFF,
+			ld);
+
+	reg_val = ld->layer_ctrl_flags;
+	cd->reg_access.xylonfb_set_reg_val(reg_val,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF,
+		ld);
+}
+
+static void xylonfb_logicvc_disp_ctrl(struct fb_info *fbi, bool enable)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 val;
+
+	driver_devel("%s\n", __func__);
+
+	if (enable) {
+		val = LOGICVC_EN_VDD_MSK;
+		writel(val, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(cd->power_on_delay);
+		val |= LOGICVC_V_EN_MSK;
+		writel(val, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+		mdelay(cd->signal_on_delay);
+		val |= LOGICVC_EN_BLIGHT_MSK;
+		writel(val, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	} else {
+		writel(0, ld->reg_base_virt + LOGICVC_SPWRCTRL_ROFF);
+	}
+}
+
+static void xylonfb_enable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	ld->layer_ctrl_flags |= LOGICVC_LAYER_ON;
+	ld->xylonfb_cd->reg_access.xylonfb_set_reg_val(
+		ld->layer_ctrl_flags,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF,
+		ld);
+}
+
+static void xylonfb_disable_logicvc_layer(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	ld->layer_ctrl_flags &= (~LOGICVC_LAYER_ON);
+	ld->xylonfb_cd->reg_access.xylonfb_set_reg_val(
+		ld->layer_ctrl_flags,
+		ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF,
+		ld);
+}
+
+static void xylonfb_enable_logicvc_output(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+
+	driver_devel("%s\n", __func__);
+
+	writel(cd->vmode_data_current.fb_vmode.right_margin-1,
+		ld->reg_base_virt + LOGICVC_SHSY_FP_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.hsync_len-1,
+		ld->reg_base_virt + LOGICVC_SHSY_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.left_margin-1,
+		ld->reg_base_virt + LOGICVC_SHSY_BP_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.xres-1,
+		ld->reg_base_virt + LOGICVC_SHSY_RES_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.lower_margin-1,
+		ld->reg_base_virt + LOGICVC_SVSY_FP_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.vsync_len-1,
+		ld->reg_base_virt + LOGICVC_SVSY_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.upper_margin-1,
+		ld->reg_base_virt + LOGICVC_SVSY_BP_ROFF);
+	writel(cd->vmode_data_current.fb_vmode.yres-1,
+		ld->reg_base_virt + LOGICVC_SVSY_RES_ROFF);
+	cd->reg_access.xylonfb_set_reg_val(
+		cd->vmode_data_current.ctrl_reg,
+		ld->reg_base_virt,
+		LOGICVC_SCTRL_ROFF,
+		ld);
+	writel(SD_REG_INIT, ld->reg_base_virt + LOGICVC_SDTYPE_ROFF);
+
+	driver_devel("\n" \
+		"logiCVC HW parameters:\n" \
+		"    Horizontal Front Porch: %d pixclks\n" \
+		"    Horizontal Sync:        %d pixclks\n" \
+		"    Horizontal Back Porch:  %d pixclks\n" \
+		"    Vertical Front Porch:   %d pixclks\n" \
+		"    Vertical Sync:          %d pixclks\n" \
+		"    Vertical Back Porch:    %d pixclks\n" \
+		"    Pixel Clock:            %d ps\n" \
+		"    Horizontal Res:         %d\n" \
+		"    Vertical Res:           %d\n" \
+		"\n", \
+		cd->vmode_data_current.fb_vmode.right_margin,
+		cd->vmode_data_current.fb_vmode.hsync_len,
+		cd->vmode_data_current.fb_vmode.left_margin,
+		cd->vmode_data_current.fb_vmode.lower_margin,
+		cd->vmode_data_current.fb_vmode.vsync_len,
+		cd->vmode_data_current.fb_vmode.upper_margin,
+		cd->vmode_data_current.fb_vmode.pixclock,
+		cd->vmode_data_current.fb_vmode.xres,
+		cd->vmode_data_current.fb_vmode.yres);
+}
+
+static void xylonfb_disable_logicvc_output(struct fb_info *fbi)
+{
+	struct fb_info **afbi = dev_get_drvdata(fbi->device);
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	if (afbi) {
+		for (i = 0; i < cd->xylonfb_layers; i++)
+			xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+}
+
+static void xylonfb_start(struct fb_info **afbi, int layers)
+{
+	struct xylonfb_layer_data *ld;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	/* turn OFF all layers except already used ones */
+	for (i = 0; i < layers; i++) {
+		ld = afbi[i]->par;
+		if (ld->layer_ctrl_flags & LOGICVC_LAYER_ON)
+			continue;
+		/* turn off layer */
+		xylonfb_disable_logicvc_layer(afbi[i]);
+	}
+	/* print layer parameters */
+	for (i = 0; i < layers; i++) {
+		ld = afbi[i]->par;
+		driver_devel("logiCVC layer %d\n" \
+			"    Registers Base Address:     0x%lX\n" \
+			"    Layer Video Memory Address: 0x%lX\n" \
+			"    X resolution:               %d\n" \
+			"    Y resolution:               %d\n" \
+			"    X resolution (virtual):     %d\n" \
+			"    Y resolution (virtual):     %d\n" \
+			"    Line length (bytes):        %d\n" \
+			"    Bits per Pixel:             %d\n" \
+			"\n", \
+			i,
+			(unsigned long)ld->reg_base_phys,
+			(unsigned long)ld->fb_phys,
+			afbi[i]->var.xres,
+			afbi[i]->var.yres,
+			afbi[i]->var.xres_virtual,
+			afbi[i]->var.yres_virtual,
+			afbi[i]->fix.line_length,
+			afbi[i]->var.bits_per_pixel);
+	}
+}
+
+/******************************************************************************/
+
+static int xylonfb_event_notify(struct notifier_block *nb,
+	unsigned long event, void *data)
+{
+	struct fb_event *fbe = data;
+	struct fb_info *fbi = fbe->info;
+	int ret = 0;
+
+	driver_devel("%s\n", __func__);
+
+	switch (event) {
+	case XYLONFB_EVENT_FBI_UPDATE:
+		xylonfb_fbi_update(fbi);
+		break;
+	}
+
+	return ret;
+}
+
+/******************************************************************************/
+
+static void xylonfb_get_vmode_opts(
+	struct xylonfb_init_data *init_data,
+	struct xylonfb_common_data *cd)
+{
+	char cvt_opt[VMODE_OPTS_SZ] = "MR";
+	char ext_opt[VMODE_OPTS_SZ] = "im";
+	char *s, *opt, *ext, *c, *pco, *peo;
+
+	if (cd->xylonfb_flags & XYLONFB_FLAG_EDID_VMODE)
+		return;
+
+	s = init_data->vmode_data.fb_vmode_name;
+	opt = cd->vmode_data.fb_vmode_opts_cvt;
+	ext = cd->vmode_data.fb_vmode_opts_ext;
+	pco = cvt_opt;
+	peo = ext_opt;
+
+	while (*pco) {
+		c = strchr(s, (int)(*pco));
+		if (c)
+			*opt++ = *c;
+		pco++;
+	}
+	while (*peo) {
+		c = strchr(s, (int)(*peo));
+		if (c)
+			*ext++ = *c;
+		peo++;
+	}
+}
+
+int xylonfb_init_driver(struct xylonfb_init_data *init_data)
+{
+	struct device *dev;
+	struct fb_info **afbi;
+	struct fb_info *fbi;
+	struct xylonfb_common_data *cd;
+	struct xylonfb_layer_data *ld;
+	struct resource *reg_res, *irq_res;
+	void *reg_base_virt;
+	unsigned long reg_base_phys;
+	int reg_range, layers, active_layer;
+	int i, rc, memmap;
+	int regfb[LOGICVC_MAX_LAYERS];
+
+	driver_devel("%s\n", __func__);
+
+	dev = &init_data->pdev->dev;
+
+	reg_res = platform_get_resource(init_data->pdev, IORESOURCE_MEM, 0);
+	irq_res = platform_get_resource(init_data->pdev, IORESOURCE_IRQ, 0);
+	if ((!reg_res) || (!irq_res)) {
+		pr_err("Error xylonfb resources\n");
+		return -ENODEV;
+	}
+
+	layers = init_data->layers;
+	if (layers == 0) {
+		pr_err("Error xylonfb zero layers\n");
+		return -ENODEV;
+	}
+	active_layer = init_data->active_layer;
+	if (active_layer >= layers) {
+		pr_err("Error xylonfb default layer: set to 0\n");
+		active_layer = 0;
+	}
+
+	afbi = kzalloc(sizeof(struct fb_info *) * layers, GFP_KERNEL);
+	cd = kzalloc(sizeof(struct xylonfb_common_data), GFP_KERNEL);
+	if (!afbi || !cd) {
+		pr_err("Error xylonfb allocating internal data\n");
+		rc = -ENOMEM;
+		goto err_mem;
+	}
+
+	BLOCKING_INIT_NOTIFIER_HEAD(&cd->xylonfb_notifier_list);
+	cd->xylonfb_nb.notifier_call = xylonfb_event_notify;
+	blocking_notifier_chain_register(
+		&cd->xylonfb_notifier_list, &cd->xylonfb_nb);
+
+	cd->xylonfb_display_interface_type =
+		init_data->display_interface_type;
+	cd->xylonfb_layers = layers;
+	cd->xylonfb_flags |= XYLONFB_FLAG_VMODE_INIT;
+	cd->xylonfb_console_layer = active_layer;
+	if (init_data->flags & XYLONFB_FLAG_ADV7511_SKIP) {
+		cd->xylonfb_flags |= XYLONFB_FLAG_ADV7511_SKIP;
+	} else {
+		if (init_data->flags & XYLONFB_FLAG_EDID_VMODE)
+			cd->xylonfb_flags |= XYLONFB_FLAG_EDID_VMODE;
+		if (init_data->flags & XYLONFB_FLAG_EDID_PRINT)
+			cd->xylonfb_flags |= XYLONFB_FLAG_EDID_PRINT;
+	}
+	if (init_data->flags & LOGICVC_READABLE_REGS) {
+		cd->xylonfb_flags |= LOGICVC_READABLE_REGS;
+		cd->reg_access.xylonfb_get_reg_val = xylonfb_get_reg;
+		cd->reg_access.xylonfb_set_reg_val = xylonfb_set_reg;
+	} else {
+		cd->reg_list =
+			kzalloc(sizeof(struct xylonfb_registers), GFP_KERNEL);
+		cd->reg_access.xylonfb_get_reg_val = xylonfb_get_reg_mem;
+		cd->reg_access.xylonfb_set_reg_val = xylonfb_set_reg_mem;
+	}
+
+	sprintf(init_data->vmode_data.fb_vmode_name, "%s-%d@%d",
+		init_data->vmode_data.fb_vmode_name,
+		init_data->lfdata[active_layer].bpp,
+		init_data->vmode_data.fb_vmode.refresh);
+	if (init_data->vmode_params_set) {
+		cd->vmode_data = init_data->vmode_data;
+	} else {
+		xylonfb_mode_option = init_data->vmode_data.fb_vmode_name;
+		cd->vmode_data.ctrl_reg = init_data->vmode_data.ctrl_reg;
+		cd->vmode_data.fb_vmode.refresh =
+			init_data->vmode_data.fb_vmode.refresh;
+	}
+	xylonfb_get_vmode_opts(init_data, cd);
+
+	if (init_data->pixclk_src_id) {
+		if (xylonfb_hw_pixclk_supported(init_data->pixclk_src_id)) {
+			cd->xylonfb_pixclk_src_id = init_data->pixclk_src_id;
+			cd->xylonfb_flags |= XYLONFB_FLAG_PIXCLK_VALID;
+		} else {
+			pr_info("xylonfb pixel clock not supported\n");
+		}
+	} else {
+		pr_info("xylonfb external pixel clock\n");
+	}
+
+	ld = NULL;
+
+	reg_base_phys = reg_res->start;
+	reg_range = resource_size(reg_res);
+	reg_base_virt = ioremap_nocache(reg_base_phys, reg_range);
+
+	/* load layer parameters for all layers */
+	for (i = 0; i < layers; i++)
+		regfb[i] = -1;
+	memmap = 1;
+
+	/* make /dev/fb0 to be default active layer
+	   regardless how logiCVC layers are organized */
+	for (i = active_layer; i < layers; i++) {
+		if (regfb[i] != -1)
+			continue;
+
+		fbi = framebuffer_alloc(sizeof(struct xylonfb_layer_data), dev);
+		if (!fbi) {
+			pr_err("Error xylonfb allocate info\n");
+			rc = -ENOMEM;
+			goto err_fb;
+		}
+		afbi[i] = fbi;
+		ld = fbi->par;
+		ld->xylonfb_cd = cd;
+
+#if defined(CONFIG_FB_XYLON_MISC)
+		if (!cd->xylonfb_misc) {
+			cd->xylonfb_misc = kzalloc(
+				sizeof(struct xylonfb_misc_data), GFP_KERNEL);
+			if (cd->xylonfb_misc) {
+				xylonfb_misc_init(fbi);
+			} else {
+				pr_err("Error xylonfb allocating misc internal data\n");
+				goto err_fb;
+			}
+		}
+#endif
+
+		xylonfb_set_yvirt(init_data, layers, i);
+
+		ld->layer_fix = init_data->lfdata[i];
+		if (!(cd->xylonfb_flags & LOGICVC_READABLE_REGS)) {
+			ld->layer_reg_list =
+				kzalloc(sizeof(struct xylonfb_layer_registers), GFP_KERNEL);
+		}
+
+		rc = xylonfb_map(i, layers, dev, ld, init_data->vmem_base_addr,
+			reg_base_phys, reg_base_virt, memmap);
+		if (rc)
+			goto err_fb;
+		memmap = 0;
+
+		ld->layer_ctrl_flags = init_data->layer_ctrl_flags[i];
+		xylonfb_init_layer_regs(ld);
+
+		rc = xylonfb_register_fb(fbi, ld, reg_base_phys, i, &regfb[i]);
+		if (rc)
+			goto err_fb;
+
+		fbi->monspecs = afbi[cd->xylonfb_console_layer]->monspecs;
+
+		mutex_init(&ld->layer_mutex);
+
+		/* register following layers in HW configuration order */
+		if (active_layer > 0) {
+			i = -1; /* after for loop increment i will be zero */
+			active_layer = -1;
+		}
+
+		driver_devel( \
+			"    Layer ID %d\n" \
+			"    Layer offset %u\n" \
+			"    Layer buffer offset %hd\n" \
+			"    Layer buffers %d\n" \
+			"    Layer width %d pixels\n" \
+			"    Layer height %d lines\n" \
+			"    Layer bits per pixel %d\n" \
+			"    Layer bits per pixel (virtual) %d\n" \
+			"    Layer FB size %ld bytes\n", \
+			(ld->layer_fix.layer_fix_info & 0x0F),
+			ld->layer_fix.offset,
+			ld->layer_fix.buffer_offset,
+			(ld->layer_fix.layer_fix_info >> 4),
+			ld->layer_fix.width,
+			ld->layer_fix.height,
+			ld->layer_fix.bpp,
+			ld->layer_fix.bpp_virt,
+			ld->fb_size);
+	}
+
+	if (ld) {
+		if (!(cd->xylonfb_flags & LOGICVC_READABLE_REGS))
+			cd->reg_access.xylonfb_set_reg_val(0xFFFF,
+				ld->reg_base_virt, LOGICVC_INT_MASK_ROFF,
+				ld);
+	} else {
+		pr_warn("Warning xylonfb initialization not completed\n");
+	}
+
+	cd->xylonfb_bg_layer_bpp = init_data->bg_layer_bpp;
+	cd->xylonfb_bg_layer_alpha_mode = init_data->bg_layer_alpha_mode;
+	driver_devel("BG layer %dbpp\n", init_data->bg_layer_bpp);
+
+	cd->xylonfb_irq = irq_res->start;
+	rc = request_irq(cd->xylonfb_irq, xylonfb_isr,
+		IRQF_TRIGGER_HIGH, DEVICE_NAME, dev);
+	if (rc) {
+		cd->xylonfb_irq = 0;
+		goto err_fb;
+	}
+
+#if defined(__LITTLE_ENDIAN)
+	cd->xylonfb_flags |= XYLONFB_FLAG_MEMORY_LE;
+#endif
+	mutex_init(&cd->irq_mutex);
+	init_waitqueue_head(&cd->vsync.wait);
+	cd->xylonfb_use_ref = 0;
+
+	dev_set_drvdata(dev, (void *)afbi);
+
+	cd->xylonfb_flags &= ~(XYLONFB_FLAG_VMODE_INIT |
+		XYLONFB_FLAG_DEFAULT_VMODE_SET | XYLONFB_FLAG_VMODE_SET);
+	xylonfb_mode_option = NULL;
+
+	/* start HW */
+	xylonfb_start(afbi, layers);
+
+	return 0;
+
+err_fb:
+	if (cd->xylonfb_irq != 0)
+		free_irq(cd->xylonfb_irq, dev);
+	for (i = layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		if (!fbi)
+			continue;
+		ld = fbi->par;
+		if (regfb[i] == 0)
+			unregister_framebuffer(fbi);
+		else
+			regfb[i] = 0;
+		if (fbi->cmap.red)
+			fb_dealloc_cmap(&fbi->cmap);
+		if (ld) {
+			if (cd->xylonfb_flags & XYLONFB_FLAG_DMA_BUFFER) {
+				/* NOT USED FOR NOW! */
+				dma_free_coherent(dev,
+					PAGE_ALIGN(fbi->fix.smem_len),
+					ld->fb_virt, ld->fb_phys);
+			} else {
+				if (ld->fb_virt)
+					iounmap(ld->fb_virt);
+			}
+			kfree(ld->layer_reg_list);
+			kfree(fbi->pseudo_palette);
+			framebuffer_release(fbi);
+		}
+	}
+	if (reg_base_virt)
+		iounmap(reg_base_virt);
+
+err_mem:
+	if (cd) {
+		kfree(cd->reg_list);
+#if defined(CONFIG_FB_XYLON_MISC)
+		kfree(cd->xylonfb_misc);
+#endif
+		kfree(cd);
+	}
+	kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return rc;
+}
+
+int xylonfb_deinit_driver(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fb_info **afbi = dev_get_drvdata(dev);
+	struct fb_info *fbi = afbi[0];
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	void *reg_base_virt = NULL;
+	int i;
+	bool logicvc_unmap = false;
+
+	driver_devel("%s\n", __func__);
+
+	if (cd->xylonfb_use_ref) {
+		pr_err("Error xylonfb in use\n");
+		return -EINVAL;
+	}
+
+	xylonfb_disable_logicvc_output(fbi);
+
+#if defined(CONFIG_FB_XYLON_MISC)
+	xylonfb_misc_deinit(fbi);
+	kfree(cd->xylonfb_misc);
+#endif
+
+	free_irq(cd->xylonfb_irq, dev);
+	for (i = cd->xylonfb_layers-1; i >= 0; i--) {
+		fbi = afbi[i];
+		ld = fbi->par;
+
+		if (!logicvc_unmap) {
+			reg_base_virt = ld->reg_base_virt;
+			logicvc_unmap = true;
+		}
+		unregister_framebuffer(fbi);
+		fb_dealloc_cmap(&fbi->cmap);
+		if (cd->xylonfb_flags & XYLONFB_FLAG_DMA_BUFFER) {
+			dma_free_coherent(dev, PAGE_ALIGN(fbi->fix.smem_len),
+				ld->fb_virt, ld->fb_phys);
+		} else {
+			iounmap(ld->fb_virt);
+		}
+		if (!(cd->xylonfb_flags & LOGICVC_READABLE_REGS))
+			kfree(ld->layer_reg_list);
+		kfree(fbi->pseudo_palette);
+		framebuffer_release(fbi);
+	}
+
+	if (reg_base_virt)
+		iounmap(reg_base_virt);
+
+	if (!(cd->xylonfb_flags & LOGICVC_READABLE_REGS))
+		kfree(cd->reg_list);
+	kfree(cd);
+	kfree(afbi);
+
+	dev_set_drvdata(dev, NULL);
+
+	return 0;
+}
+
+#ifndef MODULE
+int xylonfb_get_params(char *options)
+{
+	char *this_opt;
+
+	driver_devel("%s\n", __func__);
+
+	if (!options || !*options)
+		return 0;
+
+	while ((this_opt = strsep(&options, ",")) != NULL) {
+		if (!*this_opt)
+			continue;
+		xylonfb_mode_option = this_opt;
+	}
+	return 0;
+}
+#endif
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb.h
@@ -0,0 +1,193 @@
+/*
+ * Xylon logiCVC frame buffer driver internal data structures
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __XYLON_FB_DATA_H__
+#define __XYLON_FB_DATA_H__
+
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#include <linux/xylonfb.h>
+#include "logicvc.h"
+
+
+#define DRIVER_NAME "xylonfb"
+#define DEVICE_NAME "logicvc"
+#define DRIVER_DESCRIPTION "Xylon logiCVC frame buffer driver"
+#define DRIVER_VERSION "2.1"
+
+/* XylonFB driver flags */
+#define XYLONFB_FLAG_RESERVED_0x01     LOGICVC_READABLE_REGS
+#define XYLONFB_FLAG_DMA_BUFFER        0x02
+#define XYLONFB_FLAG_MEMORY_LE         0x04
+#define XYLONFB_FLAG_PIXCLK_VALID      0x08
+#define XYLONFB_FLAG_VMODE_INIT        0x10
+#define XYLONFB_FLAG_EDID_VMODE        0x20
+#define XYLONFB_FLAG_EDID_PRINT        0x40
+#define XYLONFB_FLAG_DEFAULT_VMODE_SET 0x80
+#define XYLONFB_FLAG_VMODE_SET         0x100
+/*
+	Following flags must be updated in xylonfb miscellaneous
+	header files for every functionality specifically
+*/
+#define XYLONFB_FLAG_MISC_ADV7511 0x1000
+#define XYLONFB_FLAG_ADV7511_SKIP 0x2000
+#define XYLONFB_FLAG_EDID_RDY     0x4000
+#define XYLONFB_EDID_SIZE         256
+#define XYLONFB_EDID_WAIT_TOUT    60
+
+
+#ifdef DEBUG
+#define driver_devel(format, ...) pr_info(format, ## __VA_ARGS__);
+#else
+#define driver_devel(format, ...)
+#endif
+
+struct xylonfb_layer_data;
+
+#define VMODE_NAME_SZ (20+1)
+#define VMODE_OPTS_SZ (2+1)
+struct xylonfb_vmode_data {
+	u32 ctrl_reg;
+	struct fb_videomode fb_vmode;
+	char fb_vmode_name[VMODE_NAME_SZ];
+	char fb_vmode_opts_cvt[VMODE_OPTS_SZ];
+	char fb_vmode_opts_ext[VMODE_OPTS_SZ];
+};
+
+struct xylonfb_registers {
+	u32 ctrl_reg;
+	u32 dtype_reg;
+	u32 bg_reg;
+	u32 unused_reg[3];
+	u32 int_mask_reg;
+};
+
+struct xylonfb_layer_registers {
+	u32 hoff_reg;
+	u32 voff_reg;
+	u32 hpos_reg;
+	u32 vpos_reg;
+	u32 width_reg;
+	u32 height_reg;
+	u32 alpha_reg;
+	u32 ctrl_reg;
+	u32 trans_reg;
+};
+
+struct xylonfb_register_access {
+	u32 (*xylonfb_get_reg_val)
+		(void *reg_base_virt, unsigned long offset,
+		 struct xylonfb_layer_data *layer_data);
+	void (*xylonfb_set_reg_val)
+		(u32 value, void *reg_base_virt, unsigned long offset,
+		 struct xylonfb_layer_data *layer_data);
+};
+
+struct xylonfb_layer_fix_data {
+	unsigned int offset;
+	unsigned short buffer_offset;
+	unsigned short width;
+	unsigned short height;
+	unsigned char bpp;
+	unsigned char bpp_virt;
+	unsigned char layer_type;
+	unsigned char alpha_mode;
+	/* higher 4 bits: number of layer buffers, lower 4 bits: layer ID */
+	unsigned char layer_fix_info;
+};
+
+struct xylonfb_sync {
+	wait_queue_head_t wait;
+	unsigned int cnt;
+};
+
+struct xylonfb_common_data {
+	struct mutex irq_mutex;
+	struct xylonfb_register_access reg_access;
+	struct xylonfb_registers *reg_list;
+	struct xylonfb_sync vsync;
+	struct xylonfb_vmode_data vmode_data;
+	struct xylonfb_vmode_data vmode_data_current;
+	struct blocking_notifier_head xylonfb_notifier_list;
+	struct notifier_block xylonfb_nb;
+	/* Delay after applying display power and
+		before applying display signals */
+	unsigned int power_on_delay;
+	/* Delay after applying display signal and
+		before applying display backlight power supply */
+	unsigned int signal_on_delay;
+	unsigned long xylonfb_flags;
+	unsigned char xylonfb_pixclk_src_id;
+	unsigned char xylonfb_layers;
+	unsigned char xylonfb_irq;
+	unsigned char xylonfb_use_ref;
+	unsigned char xylonfb_console_layer;
+	unsigned char xylonfb_bg_layer_bpp;
+	unsigned char xylonfb_bg_layer_alpha_mode;
+	/* higher 4 bits: display interface
+	   lower 4 bits: display color space */
+	unsigned char xylonfb_display_interface_type;
+#if defined(CONFIG_FB_XYLON_MISC)
+	struct xylonfb_misc_data *xylonfb_misc;
+#endif
+};
+
+struct xylonfb_layer_data {
+	struct xylonfb_common_data *xylonfb_cd;
+	struct mutex layer_mutex;
+	dma_addr_t reg_base_phys;
+	dma_addr_t fb_phys;
+	void *reg_base_virt;
+	void *fb_virt;
+	unsigned long fb_size;
+	void *layer_reg_base_virt;
+	void *layer_clut_base_virt;
+	struct xylonfb_layer_fix_data layer_fix;
+	struct xylonfb_layer_registers *layer_reg_list;
+	unsigned char layer_ctrl_flags;
+	unsigned char layer_use_ref;
+};
+
+struct xylonfb_init_data {
+	struct platform_device *pdev;
+	struct xylonfb_vmode_data vmode_data;
+	struct xylonfb_layer_fix_data lfdata[LOGICVC_MAX_LAYERS];
+	unsigned long vmem_base_addr;
+	unsigned long vmem_high_addr;
+	unsigned char pixclk_src_id;
+	unsigned char layer_ctrl_flags[LOGICVC_MAX_LAYERS];
+	unsigned char layers;
+	unsigned char active_layer;
+	unsigned char bg_layer_bpp;
+	unsigned char bg_layer_alpha_mode;
+	unsigned char display_interface_type;
+	unsigned short flags;
+	bool vmode_params_set;
+};
+
+
+/* xylonfb core pixel clock interface functions */
+extern bool xylonfb_hw_pixclk_supported(int);
+extern int xylonfb_hw_pixclk_set(int, unsigned long);
+
+/* xylonfb core interface functions */
+extern int xylonfb_get_params(char *options);
+extern int xylonfb_init_driver(struct xylonfb_init_data *init_data);
+extern int xylonfb_deinit_driver(struct platform_device *pdev);
+extern int xylonfb_ioctl(struct fb_info *fbi,
+	unsigned int cmd, unsigned long arg);
+
+#endif /* __XYLON_FB_DATA_H__ */
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb-ioctl.c
@@ -0,0 +1,632 @@
+/*
+ * Xylon logiCVC frame buffer driver IOCTL functionality
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/uaccess.h>
+#include "logicvc.h"
+#include "xylonfb.h"
+#if defined(CONFIG_FB_XYLON_MISC)
+#include "../misc/xylonfb-misc.h"
+#endif
+
+
+static int xylonfb_get_vblank(struct fb_vblank *vblank, struct fb_info *fbi)
+{
+	vblank->flags |= FB_VBLANK_HAVE_VSYNC;
+
+	return 0;
+}
+
+static int xylonfb_wait_for_vsync(u32 crt, struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 imr;
+	int ret, cnt;
+
+	mutex_lock(&cd->irq_mutex);
+
+	cnt = cd->vsync.cnt;
+
+	/* prepare LOGICVC V-sync interrupt */
+	imr = cd->reg_access.xylonfb_get_reg_val(
+		ld->reg_base_virt, LOGICVC_INT_MASK_ROFF, ld);
+	imr &= (~LOGICVC_V_SYNC_INT);
+	/* clear LOGICVC V-sync interrupt */
+	writel(LOGICVC_V_SYNC_INT,
+		ld->reg_base_virt + LOGICVC_INT_STAT_ROFF);
+	/* enable LOGICVC V-sync interrupt */
+	cd->reg_access.xylonfb_set_reg_val(imr,
+		ld->reg_base_virt, LOGICVC_INT_MASK_ROFF, ld);
+
+	ret = wait_event_interruptible_timeout(cd->vsync.wait,
+		(cnt != cd->vsync.cnt), HZ/10);
+
+	/* disable LOGICVC V-sync interrupt */
+	imr |= LOGICVC_V_SYNC_INT;
+	cd->reg_access.xylonfb_set_reg_val(imr,
+		ld->reg_base_virt, LOGICVC_INT_MASK_ROFF, ld);
+
+	mutex_unlock(&cd->irq_mutex);
+
+	if (ret < 0)
+		return ret;
+	else if (ret == 0)
+		return -ETIMEDOUT;
+
+	return 0;
+}
+
+static unsigned int alpha_normalized(unsigned int alpha,
+	unsigned int used_bits, bool get)
+{
+	if (get)
+		return (((255 << 16) / ((1 << used_bits)-1)) * alpha) >> 16;
+	else
+		return alpha / (255 / ((1 << used_bits)-1));
+}
+
+static int xylonfb_layer_alpha(struct xylonfb_layer_data *ld,
+	unsigned int *alpha, bool get)
+{
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	unsigned int used_bits;
+
+	if (ld->layer_fix.alpha_mode != LOGICVC_LAYER_ALPHA)
+		return -EPERM;
+
+	switch (ld->layer_fix.layer_type) {
+	case LOGICVC_YCBCR_LAYER:
+		used_bits = 8;
+		break;
+	case LOGICVC_RGB_LAYER:
+		switch (ld->layer_fix.bpp_virt) {
+		case 8:
+			used_bits = 3;
+			break;
+		case 16:
+			used_bits = 6;
+			break;
+		case 32:
+			used_bits = 8;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (get) {
+		*alpha = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_ALPHA_ROFF, ld);
+		*alpha &= (0xFF >> (8-used_bits));
+	}
+
+	/* get/set normalized alpha value */
+	*alpha = alpha_normalized(*alpha, used_bits, get);
+
+	if (!get)
+		cd->reg_access.xylonfb_set_reg_val(*alpha,
+			ld->layer_reg_base_virt, LOGICVC_LAYER_ALPHA_ROFF, ld);
+
+	return 0;
+}
+
+static int xylonfb_layer_color_rgb(struct xylonfb_layer_data *ld,
+	struct xylonfb_layer_color *layer_color, unsigned int reg_offset,
+	bool get)
+{
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	void *base;
+	u32 raw_rgb, r, g, b;
+	int bpp, alpha_mode;
+
+	if (reg_offset == LOGICVC_LAYER_TRANSP_ROFF) {
+		base = ld->layer_reg_base_virt;
+		bpp = ld->layer_fix.bpp_virt;
+		alpha_mode = ld->layer_fix.alpha_mode;
+	} else /* if (reg_offset == LOGICVC_BACKCOL_ROFF) */ {
+		base = ld->reg_base_virt;
+		bpp = ld->xylonfb_cd->xylonfb_bg_layer_bpp;
+		alpha_mode = ld->xylonfb_cd->xylonfb_bg_layer_alpha_mode;
+	}
+
+	if (get) {
+		raw_rgb = cd->reg_access.xylonfb_get_reg_val(
+			base, reg_offset, ld);
+check_bpp_get:
+		/* convert HW color format to RGB-888 */
+		switch (bpp) {
+		case 8:
+			switch (alpha_mode) {
+			case LOGICVC_CLUT_16BPP_ALPHA:
+				/* RGB-565 */
+				bpp = 16;
+				goto check_bpp_get;
+				break;
+			case LOGICVC_CLUT_32BPP_ALPHA:
+				/* RGB-888 */
+				bpp = 32;
+				goto check_bpp_get;
+				break;
+			default:
+				/* RGB-332 */
+				r = raw_rgb >> 5;
+				r = (((r << 3) | r) << 2) | (r >> 1);
+				g = (raw_rgb >> 2) & 0x07;
+				g = (((g << 3) | g) << 2) | (g >> 1);
+				b = raw_rgb & 0x03;
+				b = (b << 6) | (b << 4) | (b << 2) | b;
+				break;
+			}
+			break;
+		case 16:
+			/* RGB-565 */
+			r = raw_rgb >> 11;
+			r = (r << 3) | (r >> 2);
+			g = (raw_rgb >> 5) & 0x3F;
+			g = (g << 2) | (g >> 4);
+			b = raw_rgb & 0x1F;
+			b = (b << 3) | (b >> 2);
+			break;
+		case 32:
+			/* RGB-888 */
+			r = raw_rgb >> 16;
+			g = (raw_rgb >> 8) & 0xFF;
+			b = raw_rgb & 0xFF;
+			break;
+		default:
+			raw_rgb = r = g = b = 0;
+		}
+		layer_color->raw_rgb = raw_rgb;
+		layer_color->r = (u8)r;
+		layer_color->g = (u8)g;
+		layer_color->b = (u8)b;
+	} else {
+		if (layer_color->use_raw) {
+			raw_rgb = layer_color->raw_rgb;
+		} else {
+			r = layer_color->r;
+			g = layer_color->g;
+			b = layer_color->b;
+check_bpp_set:
+			/* convert RGB-888 to HW color format */
+			switch (bpp) {
+			case 8:
+				switch (alpha_mode) {
+				case LOGICVC_CLUT_16BPP_ALPHA:
+					/* RGB-565 */
+					bpp = 16;
+					goto check_bpp_set;
+					break;
+				case LOGICVC_CLUT_32BPP_ALPHA:
+					/* RGB-888 */
+					bpp = 32;
+					goto check_bpp_set;
+					break;
+				default:
+					raw_rgb =
+						(r & 0xE0) |
+						((g & 0xE0) >> 3) |
+						((b & 0xC0) >> 6);
+					break;
+				}
+				break;
+			case 16:
+				raw_rgb =
+					((r & 0xF8) << 8) |
+					((g & 0xFC) << 3) |
+					((b & 0xF8) >> 3);
+				break;
+			case 32:
+				raw_rgb =
+					(r << 16) |
+					(g << 8) |
+					b;
+				break;
+			default:
+				raw_rgb = 0;
+			}
+		}
+		cd->reg_access.xylonfb_set_reg_val(raw_rgb,
+			base, reg_offset, ld);
+	}
+
+	return 0;
+}
+
+static int xylonfb_layer_pos_sz(struct fb_info *fbi,
+	struct xylonfb_layer_pos_size *layer_pos_sz, bool get)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	u32 x, y, width, height, xres, yres;
+
+	xres = fbi->var.xres;
+	yres = fbi->var.yres;
+
+	if (get) {
+		x = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_HOR_POS_ROFF, ld);
+		layer_pos_sz->x = xres - (x + 1);
+		y = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_VER_POS_ROFF, ld);
+		layer_pos_sz->y = yres - (y + 1);
+		layer_pos_sz->width = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_WIDTH_ROFF, ld);
+		layer_pos_sz->width += 1;
+		layer_pos_sz->height = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_HEIGHT_ROFF, ld);
+		layer_pos_sz->height += 1;
+	} else {
+		x = layer_pos_sz->x;
+		y = layer_pos_sz->y;
+		width = layer_pos_sz->width;
+		height = layer_pos_sz->height;
+
+		if ((x > xres) || (y > yres))
+			return -EINVAL;
+
+		if ((width == 0) || (height == 0))
+			return -EINVAL;
+
+		if ((x + width) > xres) {
+			width = xres - x;
+			layer_pos_sz->width = width;
+		}
+		if ((y + height) > yres) {
+			height = yres - y;
+			layer_pos_sz->height = height;
+		}
+		/* YCbCr 4:2:2 layer type can only have even layer width */
+		if ((width > 2)
+				&&
+			(ld->layer_fix.layer_type == LOGICVC_YCBCR_LAYER)
+				&&
+			(ld->layer_fix.bpp_virt == 16)) {
+			width &= ~1;
+		}
+
+		cd->reg_access.xylonfb_set_reg_val((width - 1),
+			ld->layer_reg_base_virt, LOGICVC_LAYER_WIDTH_ROFF, ld);
+		cd->reg_access.xylonfb_set_reg_val((height - 1),
+			ld->layer_reg_base_virt, LOGICVC_LAYER_HEIGHT_ROFF, ld);
+		cd->reg_access.xylonfb_set_reg_val((xres - (x + 1)),
+			ld->layer_reg_base_virt, LOGICVC_LAYER_HOR_POS_ROFF, ld);
+		cd->reg_access.xylonfb_set_reg_val((yres - (y + 1)),
+			ld->layer_reg_base_virt, LOGICVC_LAYER_VER_POS_ROFF, ld);
+	}
+
+	return 0;
+}
+
+static int xylonfb_layer_reg_access(
+	struct xylonfb_layer_data *ld,
+	struct xylonfb_common_data *cd,
+	struct xylonfb_hw_access *hw_access,
+	bool read)
+{
+	u32 rel_offset;
+
+	if ((hw_access->offset < LOGICVC_LAYER_BASE_OFFSET) ||
+		(hw_access->offset > LOGICVC_LAYER_BASE_END))
+		return -EPERM;
+
+	rel_offset = hw_access->offset -
+		((ld->layer_fix.layer_fix_info & 0x0F) * 0x80) -
+		LOGICVC_LAYER_BASE_OFFSET;
+
+	if (read) {
+		hw_access->value = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, rel_offset, ld);
+	} else {
+		cd->reg_access.xylonfb_set_reg_val(hw_access->value,
+			ld->layer_reg_base_virt, rel_offset, ld);
+	}
+
+	return 0;
+}
+
+int xylonfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	union {
+		struct fb_vblank vblank;
+		struct xylonfb_layer_color layer_color;
+		struct xylonfb_layer_pos_size layer_pos_sz;
+		struct xylonfb_hw_access hw_access;
+	} ioctl;
+	void __user *argp = (void __user *)arg;
+	u32 var32;
+	unsigned long val, layer_buffs, layer_id;
+	int ret = 0;
+
+	switch (cmd) {
+	case FBIOGET_VBLANK:
+		driver_devel("FBIOGET_VBLANK\n");
+		if (copy_from_user(&ioctl.vblank, argp, sizeof(ioctl.vblank)))
+			return -EFAULT;
+		ret = xylonfb_get_vblank(&ioctl.vblank, fbi);
+		if (!ret && copy_to_user(argp, &ioctl.vblank, sizeof(ioctl.vblank)))
+			ret = -EFAULT;
+		break;
+
+	case FBIO_WAITFORVSYNC:
+		driver_devel("FBIO_WAITFORVSYNC\n");
+		if (get_user(var32, (u32 __user *)arg))
+			return -EFAULT;
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		break;
+
+	case XYLONFB_GET_LAYER_IDX:
+		driver_devel("XYLONFB_GET_LAYER_IDX\n");
+		val = ld->layer_fix.layer_fix_info & 0x0F;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_ALPHA:
+		driver_devel("XYLONFB_GET_LAYER_ALPHA\n");
+		ret = xylonfb_layer_alpha(ld, (unsigned int *)&val, true);
+		if (!ret)
+			put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_ALPHA:
+		driver_devel("XYLONFB_SET_LAYER_ALPHA\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		ret = xylonfb_layer_alpha(ld, (unsigned int *)&val, false);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_LAYER_COLOR_TRANSP\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		var32 = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF, ld);
+		if (val)
+			var32 |= (1 << 1); /* transparency disabled */
+		else
+			var32 &= ~(1 << 1); /* transparency enabled */
+		cd->reg_access.xylonfb_set_reg_val(var32,
+			ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF, ld);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_GET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(ld, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_COLOR_TRANSP:
+		driver_devel("XYLONFB_SET_LAYER_COLOR_TRANSP\n");
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		ret = xylonfb_layer_color_rgb(ld, &ioctl.layer_color,
+			LOGICVC_LAYER_TRANSP_ROFF, false);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_GET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_LAYER_SIZE_POS:
+		driver_devel("XYLONFB_SET_LAYER_SIZE_POS\n");
+		if (copy_from_user(&ioctl.layer_pos_sz, argp,
+			sizeof(ioctl.layer_pos_sz)))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		ret = xylonfb_layer_pos_sz(fbi, &ioctl.layer_pos_sz, false);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_pos_sz,
+				sizeof(ioctl.layer_pos_sz)))
+				ret = -EFAULT;
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER\n");
+		layer_id = ld->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(ld->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		val = var32 & 0x03;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_SET_LAYER_BUFFER:
+		driver_devel("XYLONFB_SET_LAYER_BUFFER\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		layer_buffs = ld->layer_fix.layer_fix_info >> 4;
+		if (val >= layer_buffs)
+			return -EINVAL;
+		layer_id = ld->layer_fix.layer_fix_info & 0x0F;
+		mutex_lock(&ld->layer_mutex);
+		var32 = readl(ld->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 |= (1 << (10 + layer_id)); /* set layer */
+		var32 &= ~(0x03 << (layer_id << 1)); /* clear previous buffer */
+		var32 |= (val << (layer_id << 1)); /* set buffer */
+		writel(var32, ld->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		ret = xylonfb_wait_for_vsync(var32, fbi);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFER_OFFSET:
+		driver_devel("XYLONFB_GET_LAYER_BUFFER_OFFSET\n");
+		layer_id = ld->layer_fix.layer_fix_info & 0x0F;
+		var32 = readl(ld->reg_base_virt + LOGICVC_DOUBLE_VBUFF_ROFF);
+		var32 >>= ((layer_id << 1)); /* get buffer */
+		var32 &= 0x03;
+		val = ld->layer_fix.buffer_offset;
+		val *= var32;
+		put_user(val, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_LAYER_BUFFERS_NUM:
+		driver_devel("XYLONFB_GET_LAYER_BUFFERS_NUM\n");
+		layer_buffs = ld->layer_fix.layer_fix_info >> 4;
+		put_user(layer_buffs, (unsigned long __user *)arg);
+		break;
+
+	case XYLONFB_GET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_GET_BACKGROUND_COLOR\n");
+		if (ld->xylonfb_cd->xylonfb_bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		ret = xylonfb_layer_color_rgb(ld, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, true);
+		if (!ret)
+			if (copy_to_user(argp, &ioctl.layer_color,
+				sizeof(ioctl.layer_color)))
+				ret = -EFAULT;
+		break;
+
+	case XYLONFB_SET_BACKGROUND_COLOR:
+		driver_devel("XYLONFB_SET_BACKGROUND_COLOR\n");
+		if (ld->xylonfb_cd->xylonfb_bg_layer_bpp == 0)
+			return -EPERM;
+		if (copy_from_user(&ioctl.layer_color, argp,
+			sizeof(ioctl.layer_color)))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		ret = xylonfb_layer_color_rgb(ld, &ioctl.layer_color,
+			LOGICVC_BACKCOL_ROFF, false);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_LAYER_EXT_BUFF_SWITCH:
+		driver_devel("XYLONFB_LAYER_EXT_BUFF_SWITCH\n");
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		mutex_lock(&ld->layer_mutex);
+		var32 = cd->reg_access.xylonfb_get_reg_val(
+			ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF, ld);
+		if (val)
+			var32 |= (1 << 2);
+		else
+			var32 &= ~(1 << 2);
+		cd->reg_access.xylonfb_set_reg_val(var32,
+			ld->layer_reg_base_virt, LOGICVC_LAYER_CTRL_ROFF, ld);
+		mutex_unlock(&ld->layer_mutex);
+		break;
+
+	case XYLONFB_READ_HW_REG:
+		driver_devel("XYLONFB_READ_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		if (cd->xylonfb_flags & LOGICVC_READABLE_REGS) {
+			ioctl.hw_access.value =
+				cd->reg_access.xylonfb_get_reg_val(
+					ld->reg_base_virt, ioctl.hw_access.offset, ld);
+		} else {
+			ret = xylonfb_layer_reg_access(ld, cd, &ioctl.hw_access, true);
+			if (ret)
+				break;
+		}
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	case XYLONFB_WRITE_HW_REG:
+		driver_devel("XYLONFB_WRITE_HW_REG\n");
+		if (copy_from_user(&ioctl.hw_access, argp,
+			sizeof(ioctl.hw_access)))
+			return -EFAULT;
+		if (cd->xylonfb_flags & LOGICVC_READABLE_REGS) {
+			cd->reg_access.xylonfb_set_reg_val(ioctl.hw_access.value,
+				ld->reg_base_virt, ioctl.hw_access.offset, ld);
+		} else {
+			ret = xylonfb_layer_reg_access(ld, cd, &ioctl.hw_access, false);
+			if (ret)
+				break;
+		}
+		if (copy_to_user(argp, &ioctl.hw_access,
+			sizeof(ioctl.hw_access)))
+			ret = -EFAULT;
+		break;
+
+	case XYLONFB_WAIT_EDID:
+		driver_devel("XYLONFB_WAIT_EDID\n");
+#if defined(CONFIG_FB_XYLON_MISC)
+		if (cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY)
+			break;
+		if (get_user(val, (unsigned long __user *)arg))
+			return -EFAULT;
+		if ((val == 0) || (val < 0))
+			val = XYLONFB_EDID_WAIT_TOUT;
+		ret = wait_event_interruptible_timeout(cd->xylonfb_misc->wait,
+			(cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY), (val * HZ));
+		if (ret == 0)
+			return -ETIMEDOUT;
+		else
+			ret = 0;
+#else
+			return -EPERM;
+#endif
+		break;
+
+	case XYLONFB_GET_EDID:
+		driver_devel("XYLONFB_GET_EDID\n");
+#if defined(CONFIG_FB_XYLON_MISC)
+		if (cd->xylonfb_flags & XYLONFB_FLAG_EDID_RDY) {
+			if (cd->xylonfb_misc->edid) {
+				if (copy_to_user(argp, cd->xylonfb_misc->edid,
+					XYLONFB_EDID_SIZE))
+					ret = -EFAULT;
+			} else {
+				return -EPERM;
+			}
+		} else {
+			return -EPERM;
+		}
+#else
+		return -EPERM;
+#endif
+		break;
+
+	default:
+		driver_devel("UNKNOWN_IOCTL\n");
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/core/xylonfb-pixclk.c
@@ -0,0 +1,249 @@
+/*
+ * Xylon logiCVC frame buffer driver pixel clock generation
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+/*
+ * This file implements HW dependent functionality for controlling pixel clock
+ * generation on various HW platforms.
+ */
+
+
+#include <linux/kernel.h>
+
+
+#define XYLONFB_PIXCLK_GEN_DEVS 8
+
+static int (*xylonfb_hw_pixclk_set_fn[XYLONFB_PIXCLK_GEN_DEVS])(unsigned long);
+static bool xylonfb_hw_pixclk_init;
+
+#if defined(CONFIG_FB_XYLON_PIXCLK_ZYNQ_PS)
+
+#define XYLONFB_PIXCLK_ZYNQ_PS 1
+
+#include <linux/io.h>
+#include <linux/errno.h>
+
+int xylonfb_hw_pixclk_set_zynq_ps(unsigned long pixclk_khz)
+{
+	unsigned long pllclk, sysclk;
+	unsigned long div, delta, delta_dec, delta_inc;
+	void *slcr_regs, *clk_regs, *rst_reg;
+
+	/* all clock values are in kHz */
+	pllclk = 1000000;
+	sysclk = 100000;
+
+	slcr_regs = ioremap_nocache(0xF8000004, 8);
+	if (!slcr_regs) {
+		pr_err("Error mapping SLCR\n");
+		return -EBUSY;
+	}
+	clk_regs = ioremap_nocache(0xF8000170, 32);
+	if (!clk_regs) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+	rst_reg = ioremap_nocache(0xF8000240, 4);
+	if (!rst_reg) {
+		pr_err("Error setting xylonfb pixelclock\n");
+		iounmap(clk_regs);
+		iounmap(slcr_regs);
+		return -EBUSY;
+	}
+
+	/* unlock register access */
+	writel(0xDF0D, (slcr_regs+4));
+#if 0
+	/* calculate system clock divisor */
+	div = pllclk / sysclk;
+	/* prepare for register writting */
+	div = (div + 0x1000) << 8;
+	/* set system clock */
+	writel(div, clk_regs);
+	/* calculate video clock divisor */
+#endif
+	div = pllclk / pixclk_khz;
+	delta = (pllclk / div) - pixclk_khz;
+	if (delta != 0) {
+		delta_inc = pixclk_khz - (pllclk / (div+1));
+		delta_dec = (pllclk / (div-1)) - pixclk_khz;
+		if (delta < delta_inc) {
+			if (delta > delta_dec)
+				div--;
+#if 0
+			else
+				div = div;
+#endif
+		} else {
+			if (delta > delta_dec) {
+				if (delta_inc > delta_dec)
+					div--;
+				else
+					div++;
+			} else {
+				div++;
+			}
+		}
+	}
+	/* prepare for register writting */
+	div = (div + 0x1000) << 8;
+	/* set video clock */
+	writel(div, (clk_regs+0x10));
+	/* lock register access */
+	writel(0x767B, slcr_regs);
+
+	iounmap(rst_reg);
+	iounmap(clk_regs);
+	iounmap(slcr_regs);
+
+	return 0;
+}
+
+#endif /* #if defined(CONFIG_FB_XYLON_PIXCLK_ZYNQ_PS) */
+
+#if defined(CONFIG_FB_XYLON_PIXCLK_LOGICLK)
+
+#define XYLONFB_PIXCLK_LOGICLK 2
+
+#include <linux/io.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+#ifdef CONFIG_OF
+/* For open firmware. */
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#endif
+#include "logiclk.h"
+
+int xylonfb_hw_pixclk_set_logiclk(unsigned long pixclk_khz)
+{
+#ifdef CONFIG_OF
+	struct device_node *dn;
+	const unsigned int *val;
+	int len;
+#endif
+	u32 *logiclk_regs;
+	struct logiclk_freq_out freq_out;
+	u32 logiclk[LOGICLK_REGS];
+	u32 address, osc_freq_hz;
+	int i, size;
+
+	address = 0x40010000;
+	size = LOGICLK_REGS * sizeof(u32);
+	osc_freq_hz = 100000000;
+
+#ifdef CONFIG_OF
+	dn = of_find_node_by_name(NULL, "logiclk");
+	if (dn) {
+		val = of_get_property(dn, "reg", &len);
+		address = be32_to_cpu(val[0]);
+		size = be32_to_cpu(val[1]);
+		val = of_get_property(dn, "osc-clk-freq-hz", &len);
+		osc_freq_hz = be32_to_cpu(val[0]);
+	}
+#endif
+
+	logiclk_regs = ioremap_nocache(address, size);
+	if (!logiclk_regs) {
+		pr_err("Error mapping logiCLK\n");
+		return -EBUSY;
+	}
+
+	for (i = 0; i < LOGICLK_OUTPUTS; i++)
+		freq_out.freq_out_hz[i] = pixclk_khz * 1000;
+
+	if (logiclk_calc_regs(&freq_out, osc_freq_hz, logiclk)) {
+		pr_err("Error calculating logiCLK parameters\n");
+		return -EINVAL;
+	}
+	writel(1, logiclk_regs+LOGICLK_RST_REG_OFF);
+	udelay(10);
+	writel(0, logiclk_regs+LOGICLK_RST_REG_OFF);
+
+	for (i = 0; i < LOGICLK_REGS; i++)
+		writel(logiclk[i], logiclk_regs+LOGICLK_PLL_MANUAL_REG_OFF+i);
+
+	while (1) {
+		if (readl(logiclk_regs+LOGICLK_PLL_REG_OFF) & LOGICLK_PLL_RDY) {
+			writel((LOGICLK_PLL_REG_EN | LOGICLK_PLL_EN),
+				logiclk_regs+LOGICLK_PLL_REG_OFF);
+			break;
+		}
+	}
+
+	iounmap(logiclk_regs);
+
+	return 0;
+}
+
+#endif /* #if defined(CONFIG_FB_XYLON_PIXCLK_LOGICLK) */
+
+#if defined(CONFIG_FB_XYLON_PIXCLK_SI570)
+
+#define XYLONFB_PIXCLK_SI570 3
+
+#include <linux/i2c/si570.h>
+
+int xylonfb_hw_pixclk_set_si570(unsigned long pixclk_khz)
+{
+	struct i2c_client *si570_client;
+
+	si570_client = get_i2c_client_si570();
+	if (si570_client)
+		return set_frequency_si570(&si570_client->dev, (pixclk_khz * 1000));
+	else
+		return -EPERM;
+}
+
+#endif /* #if defined(CONFIG_FB_XYLON_PIXCLK_SI570) */
+
+
+bool xylonfb_hw_pixclk_supported(int id)
+{
+	if (!xylonfb_hw_pixclk_init) {
+#if defined(XYLONFB_PIXCLK_ZYNQ_PS)
+		xylonfb_hw_pixclk_set_fn[XYLONFB_PIXCLK_ZYNQ_PS] =
+			xylonfb_hw_pixclk_set_zynq_ps;
+#endif
+#if defined(XYLONFB_PIXCLK_LOGICLK)
+		xylonfb_hw_pixclk_set_fn[XYLONFB_PIXCLK_LOGICLK] =
+			xylonfb_hw_pixclk_set_logiclk;
+#endif
+#if defined(XYLONFB_PIXCLK_SI570)
+		xylonfb_hw_pixclk_set_fn[XYLONFB_PIXCLK_SI570] =
+			xylonfb_hw_pixclk_set_si570;
+#endif
+		xylonfb_hw_pixclk_init = true;
+	}
+
+	return xylonfb_hw_pixclk_set_fn[id] ? true : false;
+}
+
+#if !defined(CONFIG_FB_XYLON_PIXCLK)
+
+int xylonfb_hw_pixclk_set(int id, unsigned long pixclk_khz)
+{
+	pr_info("Pixel clock change not supported\n");
+	return 0;
+}
+
+#else
+
+int xylonfb_hw_pixclk_set(int id, unsigned long pixclk_khz)
+{
+	return xylonfb_hw_pixclk_set_fn[id](pixclk_khz);
+}
+
+#endif /* #if defined(CONFIG_FB_XYLON_PIXCLK) */
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/Kconfig
@@ -0,0 +1,89 @@
+menuconfig FB_XYLON
+	tristate "Xylon logiCVC frame buffer support"
+	depends on FB
+	default n
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	help
+	  Choose this option if you want to use the Xylon logiCVC as frame
+	  buffer device. Without the support of PCI & AGP.
+
+choice
+	prompt "Xylon frame buffer driver type"
+	depends on FB_XYLON
+	default FB_XYLON_PLATFORM
+
+config FB_XYLON_PLATFORM
+	bool "Xylon logiCVC frame buffer platform driver"
+	help
+	  Choose this option if you want to use the Xylon frame buffer driver
+	  as platform driver type. This is usefull if OpenFirmware support is
+	  not compiled in the kernel.
+	  This is default selection.
+
+config FB_XYLON_OF
+	bool "Xylon logiCVC frame buffer Open Firmware driver"
+	help
+	  Choose this option if you want to use the Xylon frame buffer driver
+	  as Open Firmware driver type. Driver reads hardware configuration
+	  from Device Tree Blob binary file which must be loaded to
+	  system memory.
+endchoice
+
+config FB_XYLON_PIXCLK
+	bool "Xylon logiCVC pixel clock"
+	depends on FB_XYLON
+	default n
+	help
+	  logiCVC pixel clock generated from:
+	  - External generator not controllable by Xylon framebuffer driver
+	    This is default selection.
+	  - Generators controllable by Xylon framebuffer driver
+
+config FB_XYLON_PIXCLK_ZYNQ_PS
+	bool "Zynq PS PLL pixel clock generator"
+	depends on FB_XYLON && FB_XYLON_PIXCLK
+	default n
+	help
+	  Support for controlling pixel clock generation from
+	  Zynq-PS internal PLL clock generator.
+
+config FB_XYLON_PIXCLK_LOGICLK
+	bool "Xylon logiCLK pixel clock generator"
+	depends on FB_XYLON && FB_XYLON_PIXCLK
+	default n
+	help
+	  Support for controlling pixel clock generation from
+	  Xylon logiCLK FGPA IP core.
+
+config FB_XYLON_PIXCLK_SI570
+	bool "SI570 pixel clock generator"
+	depends on FB_XYLON && FB_XYLON_PIXCLK
+	default n
+	select SYSFS
+	select I2C
+	select MISC_DEVICES
+	select SI570
+	help
+	  Support for controlling pixel clock generation from
+	  SI570 clock generator.
+
+menuconfig FB_XYLON_MISC
+	bool "Xylon logiCVC frame buffer miscellaneous support"
+	depends on FB_XYLON
+	default n
+	help
+	  Choose this option if you want to use the Xylon logiCVC with
+	  miscellaneous device functionality for various improvements.
+	  Currently supported:
+	  - ADV7511 HDMI transmitter
+
+config FB_XYLON_MISC_ADV7511
+	bool "Xylon logiCVC frame buffer ADV7511"
+	depends on FB_XYLON_MISC && VIDEO_ADV7511
+	select FB_MODE_HELPERS
+	default n
+	---help---
+	  Support for ADV7511 HDMI transmitter so that logiCVC can be configured
+	  with parameters read from monitor EDID.
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_FB_XYLON_OF) += of/
+obj-$(CONFIG_FB_XYLON_PLATFORM) += platform/
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/misc/xylonfb-adv7511.c
@@ -0,0 +1,470 @@
+/*
+ * Xylon logiCVC frame buffer driver miscellaneous ADV7511 functionality
+ * interface for V4L2 adv7511 (Copyright 2012 Cisco Systems, Inc.
+ * and/or its affiliates) driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/interrupt.h>
+#include <linux/atomic.h>
+#include <linux/workqueue.h>
+#include <linux/completion.h>
+#include <linux/console.h>
+#include <linux/notifier.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/adv7511.h>
+#include "xylonfb-misc.h"
+#include "xylonfb-adv7511.h"
+
+
+#define ADV7511_NAME "adv7511"
+#define ADV7511_FLAG_INIT 0x01
+
+
+struct xylonfb_adv7511 {
+	atomic_t edid_lock;
+	struct completion edid_done;
+	struct v4l2_device v4l2_dev;
+	struct v4l2_subdev *sd;
+	struct work_struct irq_work;
+	struct workqueue_struct *irq_work_queue;
+	struct fb_info *fbi;
+	struct fb_var_screeninfo *var_screeninfo;
+	struct fb_monspecs *monspecs;
+	wait_queue_head_t *misc_wait;
+	unsigned long *xfb_flags;
+	unsigned long timeout;
+	unsigned char flags;
+	u8 edid[256];
+};
+
+
+static struct xylonfb_adv7511 *xfb_adv7511;
+
+
+static void xylonfb_adv7511_get_monspecs(u8 *edid,
+	struct fb_monspecs *monspecs, struct fb_var_screeninfo *var)
+{
+	driver_devel("%s\n", __func__);
+
+	fb_edid_to_monspecs(edid, monspecs);
+
+	if (*(xfb_adv7511->xfb_flags) & XYLONFB_FLAG_EDID_PRINT) {
+		pr_info("========================================\n");
+		pr_info("Display Information (EDID)\n");
+		pr_info("========================================\n");
+		pr_info("EDID Version %d.%d\n",
+			(int)monspecs->version, (int)monspecs->revision);
+		pr_info("Manufacturer: %s\n", monspecs->manufacturer);
+		pr_info("Model: %x\n", monspecs->model);
+		pr_info("Serial Number: %u\n", monspecs->serial);
+		pr_info("Year: %u Week %u\n", monspecs->year, monspecs->week);
+		pr_info("Display Characteristics:\n");
+		pr_info("   Monitor Operating Limits from EDID\n");
+		pr_info("   H: %d-%dKHz V: %d-%dHz DCLK: %dMHz\n",
+			monspecs->hfmin/1000, monspecs->hfmax/1000,
+			monspecs->vfmin, monspecs->vfmax,
+			monspecs->dclkmax/1000000);
+		if (monspecs->input & FB_DISP_DDI) {
+			pr_info("   Digital Display Input\n");
+		} else {
+			pr_info("   Analog Display Input:\n");
+			pr_info("   Input Voltage:\n");
+			if (monspecs->input & FB_DISP_ANA_700_300)
+				pr_info("      0.700V/0.300V");
+			else if (monspecs->input & FB_DISP_ANA_714_286)
+				pr_info("      0.714V/0.286V");
+			else if (monspecs->input & FB_DISP_ANA_1000_400)
+				pr_info("      1.000V/0.400V");
+			else if (monspecs->input & FB_DISP_ANA_700_000)
+				pr_info("      0.700V/0.000V");
+		}
+		if (monspecs->signal) {
+			pr_info("   Synchronization:\n");
+			if (monspecs->signal & FB_SIGNAL_BLANK_BLANK)
+				pr_info("      Blank to Blank\n");
+			if (monspecs->signal & FB_SIGNAL_SEPARATE)
+				pr_info("      Separate\n");
+			if (monspecs->signal & FB_SIGNAL_COMPOSITE)
+				pr_info("      Composite\n");
+			if (monspecs->signal & FB_SIGNAL_SYNC_ON_GREEN)
+				pr_info("      Sync on Green\n");
+			if (monspecs->signal & FB_SIGNAL_SERRATION_ON)
+				pr_info("      Serration on\n");
+		}
+		if (monspecs->max_x)
+			pr_info("   Max H-size %dcm\n", monspecs->max_x);
+		else
+			pr_info("   Variable H-size\n");
+		if (monspecs->max_y)
+			pr_info("   Max V-size %dcm\n", monspecs->max_y);
+		else
+			pr_info("   Variable V-size\n");
+		pr_info("   Display Gamma %d.%d\n",
+			monspecs->gamma/100, monspecs->gamma % 100);
+		pr_info("   DPMS: Active %s, Suspend %s, Standby %s\n",
+			(monspecs->dpms & FB_DPMS_ACTIVE_OFF) ? "yes" : "no",
+			(monspecs->dpms & FB_DPMS_SUSPEND)    ? "yes" : "no",
+			(monspecs->dpms & FB_DPMS_STANDBY)    ? "yes" : "no");
+		if (monspecs->input & FB_DISP_MONO)
+			pr_info("   Monochrome/Grayscale\n");
+		else if (monspecs->input & FB_DISP_RGB)
+			pr_info("   RGB Color Display\n");
+		else if (monspecs->input & FB_DISP_MULTI)
+			pr_info("   Non-RGB Multicolor Display\n");
+		else if (monspecs->input & FB_DISP_UNKNOWN)
+			pr_info("   Unknown\n");
+		pr_info("   Chromaticity coordinates:\n");
+		pr_info("      RedX:   0.%03d\n", monspecs->chroma.redx);
+		pr_info("      RedY:   0.%03d\n", monspecs->chroma.redy);
+		pr_info("      GreenX: 0.%03d\n", monspecs->chroma.greenx);
+		pr_info("      GreenY: 0.%03d\n", monspecs->chroma.greeny);
+		pr_info("      BlueX:  0.%03d\n", monspecs->chroma.bluex);
+		pr_info("      BlueY:  0.%03d\n", monspecs->chroma.bluey);
+		pr_info("      WhiteX: 0.%03d\n", monspecs->chroma.whitex);
+		pr_info("      WhiteY: 0.%03d\n", monspecs->chroma.whitey);
+		if (monspecs->misc) {
+			if (monspecs->misc & FB_MISC_PRIM_COLOR)
+				pr_info("   Default color format is primary\n");
+			if (monspecs->misc & FB_MISC_1ST_DETAIL)
+				pr_info("   First DETAILED Timing is preferred\n");
+			if (monspecs->gtf == 1)
+				pr_info("   Display is GTF capable\n");
+		}
+		pr_info("Monitor Timings\n");
+		pr_info("   Resolution %dx%d\n", var->xres, var->yres);
+		pr_info("   Pixel Clock %d MHz ",
+			(int)PICOS2KHZ(var->pixclock)/1000);
+		pr_info("   H sync:\n");
+		pr_info("      Front porch %d Length %d Back porch %d\n",
+			var->right_margin, var->hsync_len, var->left_margin);
+		pr_info("   V sync:\n");
+		pr_info("      Front porch %d Length %d Back porch %d\n",
+			var->lower_margin, var->vsync_len, var->upper_margin);
+		pr_info("   %sHSync %sVSync\n",
+			(var->sync & FB_SYNC_HOR_HIGH_ACT) ? "+" : "-",
+			(var->sync & FB_SYNC_VERT_HIGH_ACT) ? "+" : "-");
+		pr_info("========================================\n");
+	}
+}
+
+static void xylonfb_adv7511_set_v4l2_timings(struct v4l2_subdev *sd,
+	struct fb_var_screeninfo *var)
+{
+	struct v4l2_dv_timings dv_timings;
+
+	driver_devel("%s\n", __func__);
+
+	dv_timings.type = V4L2_DV_BT_656_1120;
+
+	dv_timings.bt.width = var->xres;
+	dv_timings.bt.height = var->yres;
+	dv_timings.bt.interlaced = 0;
+	dv_timings.bt.polarities = 0;
+	if (var->sync & FB_SYNC_VERT_HIGH_ACT)
+		dv_timings.bt.polarities |= V4L2_DV_VSYNC_POS_POL;
+	if (var->sync & FB_SYNC_HOR_HIGH_ACT)
+		dv_timings.bt.polarities |= V4L2_DV_HSYNC_POS_POL;
+	dv_timings.bt.pixelclock = (__u64)PICOS2KHZ(var->pixclock) * 1000;
+	dv_timings.bt.hfrontporch = var->right_margin;
+	dv_timings.bt.hsync = var->hsync_len;
+	dv_timings.bt.hbackporch = var->left_margin;
+	dv_timings.bt.vfrontporch = var->lower_margin;
+	dv_timings.bt.vsync = var->vsync_len;
+	dv_timings.bt.vbackporch = var->upper_margin;
+	dv_timings.bt.il_vfrontporch = 0;
+	dv_timings.bt.il_vsync = 0;
+	dv_timings.bt.il_vbackporch = 0;
+	dv_timings.bt.standards = 0;
+	dv_timings.bt.standards = V4L2_DV_BT_STD_DMT | V4L2_DV_BT_STD_CEA861;
+	dv_timings.bt.flags = 0;
+
+	sd->ops->video->s_dv_timings(sd, &dv_timings);
+}
+
+static int xylonfb_adv7511_update(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_misc_data *misc_data =
+		ld->xylonfb_cd->xylonfb_misc;
+	int ret;
+
+	driver_devel("%s\n", __func__);
+
+	fbi->monspecs = *(misc_data->monspecs);
+
+	console_lock();
+	misc_data->var_screeninfo->xres_virtual = fbi->var.xres_virtual;
+	misc_data->var_screeninfo->yres_virtual = fbi->var.yres_virtual;
+	misc_data->var_screeninfo->xoffset = fbi->var.xoffset;
+	misc_data->var_screeninfo->yoffset = fbi->var.yoffset;
+	misc_data->var_screeninfo->bits_per_pixel = fbi->var.bits_per_pixel;
+	fbi->flags |= FBINFO_MISC_USEREVENT;
+	misc_data->var_screeninfo->activate |= FB_ACTIVATE_ALL;
+	ret = fb_set_var(fbi, misc_data->var_screeninfo);
+	misc_data->var_screeninfo->activate &= ~FB_ACTIVATE_ALL;
+	console_unlock();
+
+	return ret;
+}
+
+static irqreturn_t xylonfb_adv7511_isr(int irq, void *dev_id)
+{
+	struct xylonfb_adv7511 *xfb_adv7511 = dev_id;
+
+	driver_devel("%s\n", __func__);
+
+	queue_work(xfb_adv7511->irq_work_queue, &xfb_adv7511->irq_work);
+
+	return IRQ_HANDLED;
+}
+
+static void xylonfb_adv7511_handler(struct work_struct *work)
+{
+	struct xylonfb_adv7511 *xfb_adv7511 =
+		container_of(work, struct xylonfb_adv7511, irq_work);
+
+	driver_devel("%s\n", __func__);
+
+	xfb_adv7511->sd->ops->core->interrupt_service_routine(
+		xfb_adv7511->sd, 0, NULL);
+}
+
+static void xylonfb_adv7511_notify(struct v4l2_subdev *sd,
+	unsigned int notification, void *arg)
+{
+	union notify_data {
+		struct adv7511_monitor_detect *md;
+		struct adv7511_edid_detect *ed;
+	} nd;
+	struct v4l2_subdev_edid sd_edid;
+	int ret;
+
+	driver_devel("%s\n", __func__);
+
+	switch (notification) {
+	case ADV7511_MONITOR_DETECT:
+		nd.md = arg;
+		driver_devel("ADV7511 monitor%sdetected\n",
+			nd.md->present ? " " : " not ");
+		if (nd.md->present) {
+			xfb_adv7511->timeout = HZ;
+		} else {
+			xfb_adv7511->timeout = 0;
+			*(xfb_adv7511->xfb_flags) &= ~XYLONFB_FLAG_EDID_RDY;
+			atomic_set(&xfb_adv7511->edid_lock, 0);
+		}
+		break;
+	case ADV7511_EDID_DETECT:
+		if (*(xfb_adv7511->xfb_flags) & XYLONFB_FLAG_EDID_VMODE) {
+			if (!atomic_read(&xfb_adv7511->edid_lock)) {
+				nd.ed = arg;
+				driver_devel("ADV7511 EDID%sread\n",
+					nd.ed->present ? " " : " not ");
+				if (nd.ed->present) {
+					atomic_set(&xfb_adv7511->edid_lock, 1);
+					pr_debug("EDID segment: %d\n", nd.ed->segment);
+
+					memset(xfb_adv7511->edid, 0, XYLONFB_EDID_SIZE);
+
+					sd_edid.pad = 0;
+					sd_edid.start_block = 0;
+					sd_edid.blocks = 1;
+					sd_edid.edid = xfb_adv7511->edid;
+					ret = v4l2_subdev_call(xfb_adv7511->sd, pad,
+							get_edid, (void *)&sd_edid);
+					if (ret) {
+						pr_warn("xylonfb ADV7511 IOCTL error %d\n", ret);
+						break;
+					}
+
+					fb_parse_edid(xfb_adv7511->edid,
+						xfb_adv7511->var_screeninfo);
+					xylonfb_adv7511_get_monspecs(xfb_adv7511->edid,
+						xfb_adv7511->monspecs, xfb_adv7511->var_screeninfo);
+					xylonfb_adv7511_set_v4l2_timings(xfb_adv7511->sd,
+						xfb_adv7511->var_screeninfo);
+
+					*(xfb_adv7511->xfb_flags) |= XYLONFB_FLAG_EDID_RDY;
+
+					wake_up_interruptible(xfb_adv7511->misc_wait);
+
+					if (xfb_adv7511->flags & ADV7511_FLAG_INIT)
+						complete(&xfb_adv7511->edid_done);
+					else
+						xylonfb_adv7511_update(xfb_adv7511->fbi);
+				}
+			}
+		} else {
+			*(xfb_adv7511->xfb_flags) |= XYLONFB_FLAG_EDID_RDY;
+			wake_up_interruptible(xfb_adv7511->misc_wait);
+		}
+		break;
+	default:
+		pr_warn("xylonfb ADV7511 false notify (%d)\n", notification);
+		break;
+	}
+}
+
+extern struct v4l2_subdev *adv7511_subdev(struct v4l2_subdev *sd);
+
+int xylonfb_adv7511_register(struct fb_info *fbi)
+{
+	struct v4l2_subdev *sd;
+	struct i2c_client *client;
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	struct xylonfb_misc_data *misc_data = cd->xylonfb_misc;
+	int ret;
+
+	driver_devel("%s\n", __func__);
+
+	if (xfb_adv7511)
+		return -EEXIST;
+
+	xfb_adv7511 = kzalloc(sizeof(struct xylonfb_adv7511), GFP_KERNEL);
+	if (!xfb_adv7511) {
+		pr_err("xylonfb ADV7511 error allocating data\n");
+		return -ENOMEM;
+	}
+
+	strlcpy(xfb_adv7511->v4l2_dev.name, DRIVER_NAME,
+		sizeof(xfb_adv7511->v4l2_dev.name));
+	ret = v4l2_device_register(NULL, &xfb_adv7511->v4l2_dev);
+	if (ret) {
+		pr_err("xylonfb ADV7511 registering V4L2 device error\n");
+		return ret;
+	}
+
+	xfb_adv7511->flags |= ADV7511_FLAG_INIT;
+	xfb_adv7511->v4l2_dev.notify = xylonfb_adv7511_notify;
+
+	init_completion(&xfb_adv7511->edid_done);
+
+	xfb_adv7511->var_screeninfo =
+		kzalloc(sizeof(struct fb_var_screeninfo), GFP_KERNEL);
+	xfb_adv7511->monspecs =
+		kzalloc(sizeof(struct fb_monspecs), GFP_KERNEL);
+	xfb_adv7511->xfb_flags = &cd->xylonfb_flags;
+	xfb_adv7511->fbi = fbi;
+
+	misc_data->var_screeninfo = xfb_adv7511->var_screeninfo;
+	misc_data->monspecs = xfb_adv7511->monspecs;
+	misc_data->edid = xfb_adv7511->edid;
+
+	xfb_adv7511->misc_wait = &misc_data->wait;
+
+	sd = adv7511_subdev(NULL);
+	if (!sd) {
+		pr_err("xylonfb ADV7511 getting V4L2 subdevice error %s\n",
+			ADV7511_NAME);
+		ret = -ENODEV;
+		goto error_subdev;
+	}
+	sd->v4l2_dev = &xfb_adv7511->v4l2_dev;
+	xfb_adv7511->sd = sd;
+
+	client = v4l2_get_subdevdata(sd);
+	if (!client) {
+		pr_err("xylonfb ADV7511 getting V4L2 subdevice client error\n");
+		ret = -ENODEV;
+		goto error_subdev;
+	}
+
+	xfb_adv7511->irq_work_queue = create_singlethread_workqueue(ADV7511_NAME);
+	if (xfb_adv7511->irq_work_queue == NULL) {
+		pr_err("xylonfb ADV7511 workqueue error\n");
+		goto error_subdev;
+	}
+	INIT_WORK(&xfb_adv7511->irq_work, xylonfb_adv7511_handler);
+
+	if (client->irq > 0) {
+		ret = request_irq(client->irq, xylonfb_adv7511_isr,
+			IRQF_TRIGGER_RISING, ADV7511_NAME, xfb_adv7511);
+		if (ret) {
+			pr_err("xylonfb ADV7511 registering interrupt error %d at %d\n",
+				ret, client->irq);
+			goto error_irq;
+		}
+	} else {
+		pr_err("xylonfb ADV7511 error no IRQ registered\n");
+	}
+
+	sd->ops->core->interrupt_service_routine(sd, 0, NULL);
+
+	if (*(xfb_adv7511->xfb_flags) & XYLONFB_FLAG_EDID_VMODE) {
+		if (xfb_adv7511->timeout) {
+			ret = wait_for_completion_timeout(
+				&xfb_adv7511->edid_done, xfb_adv7511->timeout);
+		} else {
+			ret = 0;
+		}
+		xfb_adv7511->flags &= ~ADV7511_FLAG_INIT;
+		if (ret == 0) {
+			if (xfb_adv7511->timeout) {
+				pr_err("xylonfb ADV7511 EDID error\n");
+				return -ETIMEDOUT;
+			} else {
+				return -ENODEV;
+			}
+		}
+	}
+
+	return 0;
+
+error_irq:
+	flush_work(&xfb_adv7511->irq_work);
+	flush_workqueue(xfb_adv7511->irq_work_queue);
+	destroy_workqueue(xfb_adv7511->irq_work_queue);
+error_subdev:
+	v4l2_device_unregister(&xfb_adv7511->v4l2_dev);
+
+	kfree(xfb_adv7511->monspecs);
+	kfree(xfb_adv7511->var_screeninfo);
+	misc_data->edid = NULL;
+	misc_data->monspecs = NULL;
+	misc_data->var_screeninfo = NULL;
+
+	kfree(xfb_adv7511);
+
+	return ret;
+}
+
+void xylonfb_adv7511_unregister(struct fb_info *fbi)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(xfb_adv7511->sd);
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	struct xylonfb_misc_data *misc_data = cd->xylonfb_misc;
+
+	driver_devel("%s\n", __func__);
+
+	if (!xfb_adv7511)
+		return;
+
+	free_irq(client->irq, xfb_adv7511);
+	flush_work(&xfb_adv7511->irq_work);
+	flush_workqueue(xfb_adv7511->irq_work_queue);
+	destroy_workqueue(xfb_adv7511->irq_work_queue);
+
+	kfree(xfb_adv7511->monspecs);
+	kfree(xfb_adv7511->var_screeninfo);
+	misc_data->edid = NULL;
+	misc_data->monspecs = NULL;
+	misc_data->var_screeninfo = NULL;
+
+	v4l2_device_unregister(&xfb_adv7511->v4l2_dev);
+
+	kfree(xfb_adv7511);
+	xfb_adv7511 = NULL;
+}
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/misc/xylonfb-adv7511.h
@@ -0,0 +1,27 @@
+/*
+ * Xylon logiCVC frame buffer driver miscellaneous ADV7511 functionality
+ * header file
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#ifndef __XYLON_FB_MISC_ADV7511_H__
+#define __XYLON_FB_MISC_ADV7511_H__
+
+
+#include <linux/types.h>
+
+
+int xylonfb_adv7511_register(struct fb_info *fbi);
+void xylonfb_adv7511_unregister(struct fb_info *fbi);
+
+
+#endif /* #ifndef __XYLON_FB_MISC_ADV7511_H__ */
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/misc/xylonfb-misc.c
@@ -0,0 +1,71 @@
+/*
+ * Xylon logiCVC frame buffer driver miscellaneous interface functionality
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include "xylonfb-misc.h"
+
+#if defined(CONFIG_FB_XYLON_MISC_ADV7511)
+
+#include "../misc/xylonfb-adv7511.h"
+
+static void xylonfb_misc_adv7511(struct fb_info *fbi, bool init)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+	struct xylonfb_common_data *cd = ld->xylonfb_cd;
+	struct xylonfb_misc_data *misc_data = cd->xylonfb_misc;
+
+	driver_devel("%s\n", __func__);
+
+	if (cd->xylonfb_flags & XYLONFB_FLAG_ADV7511_SKIP)
+		return;
+
+	if (init) {
+		if (cd->xylonfb_flags & XYLONFB_FLAG_MISC_ADV7511)
+			return;
+
+		if (!xylonfb_adv7511_register(fbi)) {
+			fbi->monspecs = *(misc_data->monspecs);
+			cd->xylonfb_flags |= XYLONFB_FLAG_MISC_ADV7511;
+		} else {
+			pr_warn("Warning xylonfb ADV7511 already initialized\n");
+		}
+	} else {
+		xylonfb_adv7511_unregister(fbi);
+		cd->xylonfb_flags &= ~XYLONFB_FLAG_MISC_ADV7511;
+	}
+}
+#endif
+
+static void xylonfb_misc_init_wait(struct fb_info *fbi)
+{
+	struct xylonfb_layer_data *ld = fbi->par;
+
+	driver_devel("%s\n", __func__);
+
+	init_waitqueue_head(&ld->xylonfb_cd->xylonfb_misc->wait);
+}
+
+void xylonfb_misc_init(struct fb_info *fbi)
+{
+	xylonfb_misc_init_wait(fbi);
+#if defined(CONFIG_FB_XYLON_MISC_ADV7511)
+	xylonfb_misc_adv7511(fbi, true);
+#endif
+}
+
+void xylonfb_misc_deinit(struct fb_info *fbi)
+{
+#if defined(CONFIG_FB_XYLON_MISC_ADV7511)
+	xylonfb_misc_adv7511(fbi, false);
+#endif
+}
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/misc/xylonfb-misc.h
@@ -0,0 +1,34 @@
+/*
+ * Xylon logiCVC frame buffer driver miscellaneous interface functionality
+ * header file
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#ifndef __XYLON_FB_MISC__
+#define __XYLON_FB_MISC__
+
+
+#include "../core/xylonfb.h"
+
+
+struct xylonfb_misc_data {
+	wait_queue_head_t wait;
+	struct fb_var_screeninfo *var_screeninfo;
+	struct fb_monspecs *monspecs;
+	u8 *edid;
+};
+
+
+void xylonfb_misc_init(struct fb_info *fbi);
+void xylonfb_misc_deinit(struct fb_info *fbi);
+
+#endif /* #ifndef __XYLON_FB_MISC__ */
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/of/Makefile
@@ -0,0 +1,7 @@
+obj-y += ../core/
+
+xylonfb_of-objs := xylonfb-of.o
+ifeq ($(CONFIG_FB_XYLON),m)
+xylonfb_of-objs += ../core/xylonfb_core.o
+endif
+obj-$(CONFIG_FB_XYLON) += xylonfb_of.o
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/of/xylonfb-of.c
@@ -0,0 +1,557 @@
+/*
+ * Xylon logiCVC frame buffer Open Firmware driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/of.h>
+#include "../core/xylonfb.h"
+#include <linux/of_gpio.h>
+
+static int pwr_en_gpio = ~0;
+static int bl_en_gpio = ~0;
+
+static void xylonfb_set_ctrl_reg(struct xylonfb_init_data *init_data,
+	unsigned long pix_data_invert, unsigned long pix_clk_act_high)
+{
+	u32 sync = init_data->vmode_data.fb_vmode.sync;
+	u32 ctrl = CTRL_REG_INIT;
+
+	driver_devel("%s\n", __func__);
+
+	/* FB_SYNC_HOR_HIGH_ACT */
+	if (!(sync & (1<<0)))
+		ctrl &= (~(1<<1));
+	/* FB_SYNC_VERT_HIGH_ACT */
+	if (!(sync & (1<<1)))
+		ctrl &= (~(1<<3));
+	if (pix_data_invert)
+		ctrl |= LOGICVC_PIX_DATA_INVERT;
+	if (pix_clk_act_high)
+		ctrl |= LOGICVC_PIX_ACT_HIGH;
+
+	init_data->vmode_data.ctrl_reg = ctrl;
+}
+
+static int xylonfb_parse_hw_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	u32 const *prop;
+	int size;
+
+	driver_devel("%s\n", __func__);
+
+	prop = of_get_property(np, "xlnx,display-interface", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting display interface\n");
+		return -EINVAL;
+	}
+	init_data->display_interface_type = be32_to_cpup(prop) << 4;
+
+	prop = of_get_property(np, "xlnx,display-color-space", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting display color space\n");
+		return -EINVAL;
+	}
+	init_data->display_interface_type |= be32_to_cpup(prop);
+
+	prop = of_get_property(np, "xlnx,readable-regs", &size);
+	if (!prop) {
+		pr_warn("xylonfb registers not readable\n");
+	} else {
+		if (be32_to_cpup(prop))
+			init_data->flags |= LOGICVC_READABLE_REGS;
+	}
+
+	return 0;
+}
+
+static int xylonfb_parse_vram_info(struct device_node *np,
+	unsigned long *vmem_base_addr, unsigned long *vmem_high_addr)
+{
+	u32 const *prop;
+	int size;
+
+	driver_devel("%s\n", __func__);
+
+	prop = of_get_property(np, "xlnx,vmem-baseaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address begin\n");
+		return -EINVAL;
+	}
+	*vmem_base_addr = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "xlnx,vmem-highaddr", &size);
+	if (!prop) {
+		pr_err("Error xylonfb getting VRAM address end\n");
+		return -EINVAL;
+	}
+	*vmem_high_addr = be32_to_cpup(prop);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	u32 const *prop;
+	unsigned int layers, bg_bpp, bg_alpha_mode;
+	int size;
+	char bg_layer_name[25];
+
+	driver_devel("%s\n", __func__);
+
+	prop = of_get_property(np, "xlnx,num-of-layers", &size);
+	if (!prop) {
+		pr_err("Error getting number of layers\n");
+		return -EINVAL;
+	}
+	layers = be32_to_cpup(prop);
+
+	bg_bpp = 0;
+	bg_alpha_mode = 0;
+	prop = of_get_property(np, "xlnx,use-background", &size);
+	if (!prop) {
+		pr_warn("xylonfb no BG layer\n");
+	} else {
+		if (be32_to_cpup(prop) == 1) {
+			layers--;
+
+			sprintf(bg_layer_name, "xlnx,layer-%d-data-width", layers);
+			prop = of_get_property(np, bg_layer_name, &size);
+			if (!prop)
+				bg_bpp = 16;
+			else
+				bg_bpp = be32_to_cpup(prop);
+			if (bg_bpp == 24)
+				bg_bpp = 32;
+
+			sprintf(bg_layer_name, "xlnx,layer-%d-alpha-mode", layers);
+			prop = of_get_property(np, bg_layer_name, &size);
+			if (!prop)
+				bg_alpha_mode = LOGICVC_LAYER_ALPHA;
+			else
+				bg_alpha_mode = be32_to_cpup(prop);
+		} else {
+			pr_debug("xylonfb no BG layer\n");
+		}
+	}
+
+	init_data->layers = (unsigned char)layers;
+	init_data->bg_layer_bpp = (unsigned char)bg_bpp;
+	init_data->bg_layer_alpha_mode = (unsigned char)bg_alpha_mode;
+
+	return 0;
+}
+
+static int xylonfb_parse_vmode_info(struct device_node *np,
+	struct xylonfb_init_data *init_data)
+{
+	struct device_node *dn, *vmode_np;
+	u32 const *prop;
+	char *c;
+	unsigned long pix_data_invert, pix_clk_act_high;
+	int size, tmp;
+
+	driver_devel("%s\n", __func__);
+
+	vmode_np = NULL;
+	init_data->vmode_data.fb_vmode.refresh = 60;
+	init_data->active_layer = 0;
+	init_data->vmode_params_set = false;
+
+	prop = of_get_property(np, "pixel-clock-source", &size);
+	if (!prop) {
+		pr_info("No pixel clock source\n");
+		init_data->pixclk_src_id = 0;
+	} else {
+		tmp = be32_to_cpup(prop);
+		init_data->pixclk_src_id = (u16)tmp;
+	}
+	pix_data_invert = 0;
+	prop = of_get_property(np, "pixel-data-invert", &size);
+	if (!prop)
+		pr_err("Error getting pixel data invert\n");
+	else
+		pix_data_invert = be32_to_cpup(prop);
+	pix_clk_act_high = 0;
+	prop = of_get_property(np, "pixel-clock-active-high", &size);
+	if (!prop)
+		pr_err("Error getting pixel active edge\n");
+	else
+		pix_clk_act_high = be32_to_cpup(prop);
+
+	prop = of_get_property(np, "pixel-component-format", &size);
+	if (prop) {
+		if (!strcmp("ABGR", (char *)prop)) {
+			prop = of_get_property(np, "pixel-component-layer", &size);
+			if (prop) {
+				while (size > 0) {
+					tmp = be32_to_cpup(prop);
+					init_data->layer_ctrl_flags[tmp] = LOGICVC_SWAP_RB;
+					prop++;
+					size -= sizeof(prop);
+				}
+			}
+		}
+	}
+
+	prop = of_get_property(np, "active-layer", &size);
+	if (prop) {
+		tmp = be32_to_cpup(prop);
+		init_data->active_layer = (unsigned char)tmp;
+	} else {
+		pr_info("xylonfb setting default layer to %d\n",
+			init_data->active_layer);
+	}
+
+	dn = of_get_child_by_name(np, "edid");
+	if (dn) {
+		prop = of_get_property(dn, "preffered-videomode", &size);
+		if (prop) {
+			tmp = be32_to_cpup(prop);
+			if (tmp)
+				init_data->flags |= XYLONFB_FLAG_EDID_VMODE;
+		}
+		prop = of_get_property(dn, "display-data", &size);
+		if (prop) {
+			tmp = be32_to_cpup(prop);
+			if (tmp)
+				init_data->flags |= XYLONFB_FLAG_EDID_PRINT;
+		}
+	} else {
+		init_data->flags |= XYLONFB_FLAG_ADV7511_SKIP;
+	}
+	of_node_put(dn);
+
+	prop = of_get_property(np, "videomode", &size);
+	if (prop) {
+
+		if (strlen((char *)prop) <= VMODE_NAME_SZ) {
+			dn = NULL;
+			dn = of_find_node_by_name(NULL, "xylon-video-params");
+			if (dn) {
+				strcpy(init_data->vmode_data.fb_vmode_name,
+					(char *)prop);
+				vmode_np = of_find_node_by_name(dn,
+					init_data->vmode_data.fb_vmode_name);
+				c = strchr((char *)prop, '_');
+				if (c)
+					*c = 0;
+				strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			} else {
+				strcpy(init_data->vmode_data.fb_vmode_name, (char *)prop);
+			}
+			of_node_put(dn);
+		} else {
+			pr_err("Error videomode name to long\n");
+		}
+		if (vmode_np) {
+			pwr_en_gpio = of_get_named_gpio_flags(vmode_np, "pwr_en", 0, NULL);
+			if (gpio_is_valid(pwr_en_gpio)) {		
+				if (gpio_request(pwr_en_gpio, "power en")) {
+					printk("request lcd power en gpio[%d] err\n", pwr_en_gpio);
+					pwr_en_gpio = ~0;
+				}else {
+					gpio_direction_output(pwr_en_gpio, 1);
+					gpio_export(pwr_en_gpio, 0);					
+				}
+			}
+			bl_en_gpio = of_get_named_gpio_flags(vmode_np, "bl_en", 0, NULL);
+			if (gpio_is_valid(bl_en_gpio)) {		
+				if (gpio_request(bl_en_gpio, "bl en")) {
+					printk("request lcd bl en gpio[%d] err\n", bl_en_gpio);
+					bl_en_gpio = ~0;
+				}else {
+					gpio_direction_output(bl_en_gpio, 1);
+					gpio_export(bl_en_gpio, 0);						
+				}
+			}
+			
+			prop = of_get_property(vmode_np, "refresh", &size);
+			if (!prop)
+				pr_err("Error getting refresh rate\n");
+			else
+				init_data->vmode_data.fb_vmode.refresh =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "xres", &size);
+			if (!prop)
+				pr_err("Error getting xres\n");
+			else
+				init_data->vmode_data.fb_vmode.xres =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "yres", &size);
+			if (!prop)
+				pr_err("Error getting yres\n");
+			else
+				init_data->vmode_data.fb_vmode.yres =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "pixclock-khz", &size);
+			if (!prop)
+				pr_err("Error getting pixclock-khz\n");
+			else
+				init_data->vmode_data.fb_vmode.pixclock =
+					KHZ2PICOS(be32_to_cpup(prop));
+
+			prop = of_get_property(vmode_np, "left-margin", &size);
+			if (!prop)
+				pr_err("Error getting left-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.left_margin =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "right-margin", &size);
+			if (!prop)
+				pr_err("Error getting right-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.right_margin =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "upper-margin", &size);
+			if (!prop)
+				pr_err("Error getting upper-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.upper_margin =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "lower-margin", &size);
+			if (!prop)
+				pr_err("Error getting lower-margin\n");
+			else
+				init_data->vmode_data.fb_vmode.lower_margin =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "hsync-len", &size);
+			if (!prop)
+				pr_err("Error getting hsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.hsync_len =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "vsync-len", &size);
+			if (!prop)
+				pr_err("Error getting vsync-len\n");
+			else
+				init_data->vmode_data.fb_vmode.vsync_len =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "sync", &size);
+			if (!prop)
+				pr_err("Error getting sync\n");
+			else
+				init_data->vmode_data.fb_vmode.sync =
+					be32_to_cpup(prop);
+
+			prop = of_get_property(vmode_np, "vmode", &size);
+			if (!prop)
+				pr_err("Error getting vmode\n");
+			else
+				init_data->vmode_data.fb_vmode.vmode =
+					be32_to_cpup(prop);
+
+			init_data->vmode_params_set = true;
+		}
+	} else {
+		pr_info("xylonfb using default driver video mode\n");
+	}
+
+	xylonfb_set_ctrl_reg(init_data, pix_data_invert, pix_clk_act_high);
+
+	return 0;
+}
+
+static int xylonfb_parse_layer_params(struct device_node *np,
+	int id, struct xylonfb_layer_fix_data *lfdata)
+{
+	u32 const *prop;
+	int size;
+	char layer_property_name[25];
+
+	driver_devel("%s\n", __func__);
+
+	sprintf(layer_property_name, "xlnx,layer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->offset = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "xlnx,buffer-%d-offset", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting buffer offset\n");
+		return -EINVAL;
+	} else {
+		lfdata->buffer_offset = be32_to_cpup(prop);
+	}
+
+	prop = of_get_property(np, "xlnx,row-stride", &size);
+	if (!prop)
+		lfdata->width = 1024;
+	else
+		lfdata->width = be32_to_cpup(prop);
+
+	sprintf(layer_property_name, "xlnx,layer-%d-type", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer type\n");
+		return -EINVAL;
+	} else {
+		lfdata->layer_type = be32_to_cpup(prop);
+	}
+
+	sprintf(layer_property_name, "xlnx,layer-%d-alpha-mode", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop) {
+		pr_err("Error getting layer alpha mode\n");
+		return -EINVAL;
+	} else {
+		lfdata->alpha_mode = be32_to_cpup(prop);
+		/* If logiCVC layer is Alpha layer, override DT value */
+		if (lfdata->layer_type == LOGICVC_ALPHA_LAYER)
+			lfdata->alpha_mode = LOGICVC_LAYER_ALPHA;
+	}
+
+	sprintf(layer_property_name, "xlnx,layer-%d-data-width", id);
+	prop = of_get_property(np, layer_property_name, &size);
+	if (!prop)
+		lfdata->bpp = 16;
+	else
+		lfdata->bpp = be32_to_cpup(prop);
+	if (lfdata->bpp == 24)
+		lfdata->bpp = 32;
+
+	lfdata->bpp_virt = lfdata->bpp;
+
+	switch (lfdata->bpp) {
+	case 8:
+		if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+			lfdata->bpp = 16;
+		break;
+	case 16:
+		if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+			lfdata->bpp = 32;
+		break;
+	}
+
+	lfdata->layer_fix_info = id;
+
+	return 0;
+}
+
+
+static int xylonfb_of_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	int i, rc;
+
+	driver_devel("%s\n", __func__);
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	rc = xylonfb_parse_hw_info(pdev->dev.of_node, &init_data);
+	if (rc)
+		return rc;
+	rc = xylonfb_parse_vram_info(pdev->dev.of_node,
+		&init_data.vmem_base_addr, &init_data.vmem_high_addr);
+	if (rc)
+		return rc;
+	rc = xylonfb_parse_layer_info(pdev->dev.of_node, &init_data);
+	if (rc)
+		return rc;
+	/* if Device-Tree contains video mode options do not use
+	   kernel command line video mode options */
+	xylonfb_parse_vmode_info(pdev->dev.of_node, &init_data);
+
+	for (i = 0; i < init_data.layers; i++) {
+		rc = xylonfb_parse_layer_params(pdev->dev.of_node, i,
+			&init_data.lfdata[i]);
+		if (rc)
+			return rc;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_of_remove(struct platform_device *pdev)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+static struct of_device_id xylonfb_of_match[] = {
+	{ .compatible = "xylon,logicvc-3.00.a" },
+	{ .compatible = "xylon,logicvc-3.01.a" },
+	{ .compatible = "xylon,logicvc-3.02.a" },
+	{/* end of table */},
+};
+MODULE_DEVICE_TABLE(of, xylonfb_of_match);
+
+
+static struct platform_driver xylonfb_of_driver = {
+	.probe = xylonfb_of_probe,
+	.remove = xylonfb_of_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+		.of_match_table = xylonfb_of_match,
+	},
+};
+
+
+static int xylonfb_of_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	if (platform_driver_register(&xylonfb_of_driver)) {
+		pr_err("Error xylonfb driver registration\n");
+		return -ENODEV;
+	}
+	
+	return 0;
+}
+
+static void __exit xylonfb_of_exit(void)
+{
+	platform_driver_unregister(&xylonfb_of_driver);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_of_init);
+#else
+module_init(xylonfb_of_init);
+module_exit(xylonfb_of_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/platform/Makefile
@@ -0,0 +1,7 @@
+obj-y += ../core/
+
+xylonfb_platform-objs := xylonfb-platform.o
+ifeq ($(CONFIG_FB_XYLON),m)
+xylonfb_platform-objs += ../core/xylonfb_core.o
+endif
+obj-$(CONFIG_FB_XYLON) += xylonfb_platform.o
--- /dev/null
+++ b/drivers/video/xylon/xylonfb/platform/xylonfb-platform.c
@@ -0,0 +1,249 @@
+/*
+ * Xylon logiCVC frame buffer platform driver
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * This driver was primarily based on skeletonfb.c and other fb video drivers.
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/errno.h>
+#include <linux/xylonfb_platform.h>
+#include "../core/xylonfb.h"
+
+
+static void xylonfb_get_platform_layer_params(
+	struct xylonfb_platform_layer_params *lparams,
+	struct xylonfb_layer_fix_data *lfdata, int id)
+{
+	driver_devel("%s\n", __func__);
+
+	lfdata->offset = lparams->offset;
+	lfdata->buffer_offset = lparams->buffer_offset;
+	lfdata->layer_type = lparams->type;
+	lfdata->bpp = lparams->bpp;
+	lfdata->bpp_virt = lparams->bpp;
+	lfdata->alpha_mode = lparams->alpha_mode;
+	if (lfdata->layer_type == LOGICVC_ALPHA_LAYER)
+		lfdata->alpha_mode = LOGICVC_LAYER_ALPHA;
+
+	switch (lfdata->bpp) {
+	case 8:
+		if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+			lfdata->bpp = 16;
+		break;
+	case 16:
+		if (lfdata->alpha_mode == LOGICVC_PIXEL_ALPHA)
+			lfdata->bpp = 32;
+		break;
+	}
+
+	lfdata->layer_fix_info = id;
+}
+
+static int xylonfb_platform_probe(struct platform_device *pdev)
+{
+	struct xylonfb_init_data init_data;
+	struct xylonfb_platform_data *pdata;
+	int i;
+
+	driver_devel("%s\n", __func__);
+
+	memset(&init_data, 0, sizeof(struct xylonfb_init_data));
+
+	init_data.pdev = pdev;
+
+	pdata = (struct xylonfb_platform_data *)pdev->dev.platform_data;
+	init_data.vmem_base_addr = pdata->vmem_base_addr;
+	init_data.vmem_high_addr = pdata->vmem_high_addr;
+	init_data.pixclk_src_id = pdata->pixclk_src_id;
+	init_data.vmode_data.ctrl_reg = pdata->ctrl_reg;
+	strcpy(init_data.vmode_data.fb_vmode_name, pdata->vmode);
+	init_data.vmode_data.fb_vmode.refresh = 60;
+	init_data.layers = pdata->num_layers;
+	init_data.active_layer = pdata->active_layer;
+	init_data.bg_layer_bpp = pdata->bg_layer_bpp;
+	init_data.bg_layer_alpha_mode = pdata->bg_layer_alpha_mode;
+	init_data.display_interface_type = pdata->display_interface_type;
+	init_data.flags = pdata->flags;
+	init_data.vmode_params_set = false;
+
+	for (i = 0; i < init_data.layers; i++) {
+		xylonfb_get_platform_layer_params(
+			&pdata->layer_params[i], &init_data.lfdata[i], i);
+		init_data.lfdata[i].width = pdata->row_stride;
+		init_data.layer_ctrl_flags[i] = pdata->layer_params[i].ctrl_flags;
+	}
+
+	return xylonfb_init_driver(&init_data);
+}
+
+static int xylonfb_platform_remove(struct platform_device *pdev)
+{
+	driver_devel("%s\n", __func__);
+
+	return xylonfb_deinit_driver(pdev);
+}
+
+
+void xylonfb_platform_release(struct device *dev)
+{
+	driver_devel("%s\n", __func__);
+
+	return;
+}
+
+
+/* logiCVC parameters for Xylon Zynq-ZC702 2D3D referent design */
+static struct xylonfb_platform_layer_params
+	logicvc_0_layer_params[] = {
+	{
+		.offset = 7290,
+		.buffer_offset = 1080,
+		.type = LOGICVC_RGB_LAYER,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_PIXEL_ALPHA,
+		.ctrl_flags = 0,
+	},
+	{
+		.offset = 4050,
+		.buffer_offset = 1080,
+		.type = LOGICVC_RGB_LAYER,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl_flags = 0,
+	},
+	{
+		.offset = 0,
+		.buffer_offset = 1080,
+		.type = LOGICVC_RGB_LAYER,
+		.bpp = 32,
+		.alpha_mode = LOGICVC_LAYER_ALPHA,
+		.ctrl_flags = 0,
+	},
+	{
+		.offset = 12960,
+		.buffer_offset = 1080,
+		.type = LOGICVC_RGB_LAYER,
+		.bpp = 8,
+		.alpha_mode = LOGICVC_CLUT_32BPP_ALPHA,
+		.ctrl_flags = 0,
+	},
+};
+
+static struct xylonfb_platform_data logicvc_0_platform_data = {
+	.layer_params = logicvc_0_layer_params,
+	.vmode = "1024x768",
+	.ctrl_reg = (CTRL_REG_INIT | LOGICVC_PIX_ACT_HIGH),
+	.vmem_base_addr = 0x30000000,
+	.vmem_high_addr = 0x3FFFFFFF,
+	.pixclk_src_id = 3,
+	.row_stride = 2048,
+	.num_layers = ARRAY_SIZE(logicvc_0_layer_params),
+	.active_layer = 3,
+	.bg_layer_bpp = 32,
+	.bg_layer_alpha_mode = LOGICVC_LAYER_ALPHA,
+	.display_interface_type =
+		(LOGICVC_DI_PARALLEL << 4) | (LOGICVC_DCS_YUV422),
+	/*
+		Available flags:
+		LOGICVC_READABLE_REGS
+		XYLONFB_FLAG_EDID_VMODE
+		XYLONFB_FLAG_EDID_PRINT
+	*/
+	.flags = 0,
+};
+
+static struct resource logicvc_0_resource[] = {
+	{
+		.start = 0x40030000,
+		.end = (0x40030000 + LOGICVC_REGISTERS_RANGE),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = 90,
+		.end = 90,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device logicvc_0_device = {
+	.name = DEVICE_NAME,
+	.id = 0,
+	.dev = {
+		.platform_data = &logicvc_0_platform_data,
+		.release = xylonfb_platform_release,
+	},
+	.resource = logicvc_0_resource,
+	.num_resources = ARRAY_SIZE(logicvc_0_resource),
+};
+
+
+static struct platform_driver xylonfb_driver = {
+	.probe = xylonfb_platform_probe,
+	.remove = xylonfb_platform_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = DEVICE_NAME,
+	},
+};
+
+
+static int xylonfb_platform_init(void)
+{
+#ifndef MODULE
+	char *option = NULL;
+#endif
+	int err;
+
+	driver_devel("%s\n", __func__);
+
+#ifndef MODULE
+	/*
+	 *  For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+	if (fb_get_options(DRIVER_NAME, &option))
+		return -ENODEV;
+	/* Set internal module parameters */
+	xylonfb_get_params(option);
+#endif
+	err = platform_device_register(&logicvc_0_device);
+	if (err) {
+		pr_err("Error xylonfb device registration\n");
+		return err;
+	}
+	err = platform_driver_register(&xylonfb_driver);
+	if (err) {
+		pr_err("Error xylonfb driver registration\n");
+		platform_device_unregister(&logicvc_0_device);
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit xylonfb_platform_exit(void)
+{
+	platform_driver_unregister(&xylonfb_driver);
+	platform_device_unregister(&logicvc_0_device);
+}
+
+
+#ifndef MODULE
+late_initcall(xylonfb_platform_init);
+#else
+module_init(xylonfb_platform_init);
+module_exit(xylonfb_platform_exit);
+#endif
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
+MODULE_VERSION(DRIVER_VERSION);
--- /dev/null
+++ b/include/linux/xylonfb.h
@@ -0,0 +1,78 @@
+/*
+ * Xylon logiCVC frame buffer driver IOCTL parameters
+ *
+ * Author: Xylon d.o.o.
+ * e-mail: davor.joja@logicbricks.com
+ *
+ * 2013 Xylon d.o.o.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __XYLON_FB_H__
+#define __XYLON_FB_H__
+
+
+#include <linux/types.h>
+
+
+struct xylonfb_layer_color {
+    __u32 raw_rgb;
+    __u8 use_raw;
+    __u8 r;
+    __u8 g;
+    __u8 b;
+};
+
+struct xylonfb_layer_pos_size {
+    __u16 x;
+    __u16 y;
+    __u16 width;
+    __u16 height;
+};
+
+struct xylonfb_hw_access {
+    __u32 offset;
+    __u32 value;
+};
+
+/* XylonFB events */
+#define XYLONFB_EVENT_FBI_UPDATE 0x01
+
+/* XylonFB IOCTL's */
+#define XYLONFB_IOW(num, dtype)  _IOW('x', num, dtype)
+#define XYLONFB_IOR(num, dtype)  _IOR('x', num, dtype)
+#define XYLONFB_IOWR(num, dtype) _IOWR('x', num, dtype)
+#define XYLONFB_IO(num)          _IO('x', num)
+
+#define XYLONFB_GET_LAYER_IDX           XYLONFB_IOR(30, unsigned int)
+#define XYLONFB_GET_LAYER_ALPHA         XYLONFB_IOR(31, unsigned int)
+#define XYLONFB_SET_LAYER_ALPHA         XYLONFB_IOW(32, unsigned int)
+#define XYLONFB_LAYER_COLOR_TRANSP      XYLONFB_IOW(33, unsigned int)
+#define XYLONFB_GET_LAYER_COLOR_TRANSP \
+    XYLONFB_IOR(34, struct xylonfb_layer_color)
+#define XYLONFB_SET_LAYER_COLOR_TRANSP \
+    XYLONFB_IOW(35, struct xylonfb_layer_color)
+#define XYLONFB_GET_LAYER_SIZE_POS \
+    XYLONFB_IOR(36, struct xylonfb_layer_pos_size)
+#define XYLONFB_SET_LAYER_SIZE_POS \
+    XYLONFB_IOW(37, struct xylonfb_layer_pos_size)
+#define XYLONFB_GET_LAYER_BUFFER        XYLONFB_IOR(38, unsigned int)
+#define XYLONFB_SET_LAYER_BUFFER        XYLONFB_IOW(39, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFER_OFFSET XYLONFB_IOR(40, unsigned int)
+#define XYLONFB_GET_LAYER_BUFFERS_NUM   XYLONFB_IOR(41, unsigned int)
+#define XYLONFB_GET_BACKGROUND_COLOR \
+    XYLONFB_IOR(42, struct xylonfb_layer_color)
+#define XYLONFB_SET_BACKGROUND_COLOR \
+    XYLONFB_IOW(43, struct xylonfb_layer_color)
+#define XYLONFB_LAYER_EXT_BUFF_SWITCH   XYLONFB_IOW(43, unsigned int)
+#define XYLONFB_READ_HW_REG \
+    XYLONFB_IOR(44, struct xylonfb_hw_access)
+#define XYLONFB_WRITE_HW_REG \
+    XYLONFB_IOW(45, struct xylonfb_hw_access)
+#define XYLONFB_WAIT_EDID               XYLONFB_IOW(46, unsigned int)
+#define XYLONFB_GET_EDID                XYLONFB_IOR(47, char)
+
+#endif /* __XYLON_FB_H__ */
--- a/scripts/setlocalversion
+++ b/scripts/setlocalversion
@@ -106,13 +106,13 @@
 	fi
 
 	# Check for svn and a svn repo.
-	if rev=`LANG= LC_ALL= LC_MESSAGES=C svn info 2>/dev/null | grep '^Last Changed Rev'`; then
-		rev=`echo $rev | awk '{print $NF}'`
-		printf -- '-svn%s' "$rev"
+	#if rev=`LANG= LC_ALL= LC_MESSAGES=C svn info 2>/dev/null | grep '^Last Changed Rev'`; then
+		#rev=`echo $rev | awk '{print $NF}'`
+		#printf -- '-svn%s' "$rev"
 
 		# All done with svn
-		return
-	fi
+		#return
+	#fi
 }
 
 collect_files()
--- a/drivers/gpu/drm/xylon/xylon_encoder.c
+++ b/drivers/gpu/drm/xylon/xylon_encoder.c
@@ -170,7 +170,7 @@
 	encoder->slave.base.possible_crtcs = 1;
 	ret = drm_encoder_init(dev, &encoder->slave.base,
 			       &xylon_drm_encoder_funcs,
-			       DRM_MODE_ENCODER_TMDS);
+			       DRM_MODE_ENCODER_TMDS, NULL);
 	if (ret) {
 		DRM_ERROR("failed initialize encoder\n");
 		return ERR_PTR(ret);
